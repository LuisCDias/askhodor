Popular.create(name: "JavaScript", percentage: 55.4)
Popular.create(name: "SQL", percentage: 49.1)
Popular.create(name: "Java", percentage: 36.3)
Popular.create(name: "C#", percentage: 30.9)
Popular.create(name: "PHP", percentage: 25.9)
Popular.create(name: "Python", percentage: 24.9)
Popular.create(name: "C++", percentage: 19.4)
Popular.create(name: "C", percentage: 15.5)
Popular.create(name: "Node.js", percentage: 17.2)
Popular.create(name: "AngularJS", percentage: 17.9)
Popular.create(name: "Ruby", percentage: 8.9)
Popular.create(name: "Objective-C", percentage: 6.5)

MostWanted.create(name: "Android", percentage: 15.8)
MostWanted.create(name: "Node.js", percentage: 14.8)
MostWanted.create(name: "AngularJS", percentage: 13.4)
MostWanted.create(name: "Python", percentage: 13.3)
MostWanted.create(name: "Javascript", percentage: 11.9)
MostWanted.create(name: "React", percentage: 9.2)
MostWanted.create(name: "Swift", percentage: 8.7)
MostWanted.create(name: "MongoDB", percentage: 8.1)
MostWanted.create(name: "Arduino/Raspberry Pi", percentage: 8.0)
MostWanted.create(name: "C++", percentage: 8.0)
MostWanted.create(name: "iOS", percentage: 8.0)

Trendy.create(name: "React", percentage: 311.3)
Trendy.create(name: "Spark", percentage: 163.5)
Trendy.create(name: "Swift", percentage: 74.6)
Trendy.create(name: "Cassandra", percentage: 40.6)
Trendy.create(name: "Raspberry Pi", percentage: 36.8)
Trendy.create(name: "Node.js", percentage: 26.8)
Trendy.create(name: "Cloud", percentage: 26.0)
Trendy.create(name: "Python", percentage: 19.9)
Trendy.create(name: "Wordpress", percentage: 18.5)
Trendy.create(name: "AngularJS", percentage: 14.9)
Trendy.create(name: "Javascript", percentage: 13.0)
Trendy.create(name: "MongoDB", percentage: 10.6)
Trendy.create(name: "R", percentage: 8.8)
Trendy.create(name: "Redis", percentage: 5.8)
Trendy.create(name: "Hadoop", percentage: 5.2)
Trendy.create(name: "iOS", percentage: 3.1)
Trendy.create(name: "VBA", percentage: 2.5)
Trendy.create(name: "Android", percentage: 2.0)
Trendy.create(name: "Clojure", percentage: 2.0)
Trendy.create(name: "Go", percentage: 1.9)

w1 = Writer.create(name: "Miles Matthias", skills: "JavaScript,Node.js,React,MongoDB", photo: "assets/author1.jpg")
w2 = Writer.create(name: "Jorge Palacios", skills: "AngularJS,Ruby,Swift,iOS,Clojure", photo: "assets/author2.jpg")
w3 = Writer.create(name: "Fabiano Arruda", skills: "Java,Android,Go,Ruby,C++", photo: "assets/author3.jpg")
w4 = Writer.create(name: "Stuk.io", skills: "Ruby,Javascript,React,Node.js,AngularJS,SQL,Arduino/Raspberry Pi", photo: "assets/author4.jpg")
w5 = Writer.create(name: "Miguel Silva", skills: "Ruby,JavaScript,Python,PHP,C,C++,Node.js,AngularJS,React,Cloud,iOS,Swift,Android,Java,Go", photo: "assets/author0.jpg")

r1 = Recipe.create(name: "Ruby on Rails Explained for Front End Developers")
r1.content = "<p>As you probably already know if you've downloaded this book, Ruby on Rails is an open source web application framework written in Ruby (<a href=\"https://www.ruby-lang.org\">https://www.ruby-lang.org</a>). It was created by David Heinemeier Hansson (<a href=\"http://en.wikipedia.org/wiki/David_Heinemeier_Hansson\">http://en.wikipedia.org/wiki/David_Heinemeier_Hansson</a>), quickly adopted by the ruby community, and has even come pre-shipped on every new Mac since October 2007.</p>\n\n<p>Rails, much like Ruby, has very strong opinions about what engineering patterns should be in use, and if you're not familiar with those patterns, Rails will be very hard to understand. At the very least, you need to understand the following:</p>\n\n<ul>\n<li><p><strong>Ruby syntax</strong> (<a href=\"https://www.ruby-lang.org/en/documentation/quickstart/\">https://www.ruby-lang.org/en/documentation/quickstart/</a>) This is an obvious one. You need to understand the basic syntax of ruby to understand what the code is doing.</p></li>\n<li><p><strong>Rake</strong> (<a href=\"http://rake.rubyforge.org/\">http://rake.rubyforge.org/</a>) Rake is a build program written in ruby that's similar to unix's <code>make</code>. It's used to automate a lot of tasks that you would normally do by hand.</p></li>\n<li><p><strong>Gems and Bundler</strong> (<a href=\"http://en.wikipedia.org/wiki/RubyGems\">http://en.wikipedia.org/wiki/RubyGems</a> and <a href=\"http://bundler.io/\">http://bundler.io/</a>) Gems are how ruby, and thus rails, manages dependencies. They list dependencies in <code>Gemfile</code> and then use the <code>bundle install</code> command to install all of the dependencies.</p></li>\n<li><p><strong>Object Oriented Programming</strong> (<a href=\"http://en.wikipedia.org/wiki/Object-oriented_programming\">http://en.wikipedia.org/wiki/Object-oriented_programming</a>) Rails consists of classes, many of which inherit from other classes, so you need to understand inheritance and encapsulation at a minimum.</p></li>\n<li><p><strong>MVC</strong> (<a href=\"http://en.wikipedia.org/wiki/Model-view-controller\">http://en.wikipedia.org/wiki/Model-view-controller</a>) The application code that listens for web requests, performs some operations (like manipulating data in a database), and returns a view to the user's browser is, at its core, a model-view-controller framework. Controllers listen to the requests, use models to manipulate data, and respond with a view, usually hydrated with some data from the models. If you've never used an MVC framework before, you'd do well to read up on the pattern and build a few simple practice MVC apps.</p></li>\n<li><p><strong><q>Full Stack Framework</q></strong> You're not just dealing with the browser here -- Ruby on Rails is one of many <q>full stack</q> frameworks, meaning that it provides functionality at every level of the web application stack including persisting data in a database, responding to requests, and dealing with the quirks of browsers in delivering assets (see asset pipeline).</p></li>\n<li><p><strong>Convention Over Configuration</strong> (<a href=\"http://en.wikipedia.org/wiki/Convention_over_configuration\">http://en.wikipedia.org/wiki/Convention_over_configuration</a>) This is one of the biggest patterns that Rails is based on. The idea being that if you have a controller named <q>Blog</q>, a model named <q>Blog</q>, and a view named <q>Blog</q>, the developer shouldn't need to create some configuration file that tells the framework that those objects are related. Convention over configuration is handy in that the framework will make assumptions based on naming conventions and application state, but if you're unaware of the default actions that rails takes when there is no explicit customization, you'll get really confused, really quickly.</p></li>\n<li><p><strong>ERB files</strong> (<a href=\"http://en.wikipedia.org/wiki/ERuby\">http://en.wikipedia.org/wiki/ERuby</a>) HTML files that end in <code>.erb</code> are ran through the ERB processor, which allows for templates to be written with ruby. It's similar to jade and haml, just written in ruby and more powerful. If you're unfamiliar with ERB, the views in rails will look goofy to you.</p></li>\n</ul>\n/n<p><u>Since the intended audience of this book are front end developers, we're going to skip over a lot of the rails structure and cover only the directories and files that the front end dev needs to know about to get his/her content to the browser. If you'd like to read about all of the rails structure, see the rails getting started guide (<a href=\"http://guides.rubyonrails.org/getting\">http://guides.rubyonrails.org/getting</a></u>started.html#creating-a-new-rails-project)._</p>\n\n<p>The core application code (the MVC business) in a rails project is in the <code>app</code> directory:</p>\n\n<ul>\n<li><p><strong><code>app/controllers</code></strong> is where the controllers live in a rails application. Again, the controller is responsible for processing incoming requests by getting necessary data and rendering a view to the user. This is the entry point to behavior in the application.</p></li>\n<li><p><strong><code>app/models</code></strong> is where the models live in a rails application. The models represent an instance of a data type in your application, perform functions unique to that data type, and persist and fetch data from a database.</p></li>\n<li><p><strong><code>app/views</code></strong> is where the HTML views of the application live. They're traditionally written in ERB, but you can use whatever template engine you like (even none at all if you're so brash). You'll be putting your HTML in this directory and a controller that's responding to a request will incorporate your view with the <code>render</code> function (see how controllers and views work together).</p></li>\n<li><p><strong><code>app/assets</code></strong> okay, here's where you'll be doing most of your work. Your javascript files go into the directory named <strong><code>app/assets/javascripts/</code></strong> and your css files go into the <strong><code>app/assets/stylesheets/</code></strong> directory. Also note that just like with views, you can append a filename to your file that tells rails which preprocessor to run your code through before serving it as plan javascript or css. For more on that, see <q>asset pipeline</q>.</p></li>\n</ul>\n\n<hr>\n\n<p>Within <code>app/assets</code>:</p>\n\n<ul>\n<li><p><strong><code>app/assets/images</code></strong> Put all of your images here.</p></li>\n<li><p><strong><code>app/assets/javascripts</code></strong> Your javascript code will be preprocessed, concatenated into files that you specify (the default is <code>application.js</code>), and minified for production by Rail's asset compilation engine, Sprockets (<a href=\"https://github.com/sstephenson/sprockets\">https://github.com/sstephenson/sprockets</a>).</p></li>\n<li><p><strong><code>app/assets/stylesheets</code></strong> is where the default <code>application.css</code> file lives that Sprockets will compile for you.</p></li>\n</ul>\n\n<hr>\n\n<ul>\n<li>\n<strong><code>public</code></strong> is where static pages (like a 404 page), compiled assets (your plain and minified javascript and css after any preprocessors), and other static assets (like images) are placed to be served without any application logic by Apache (<a href=\"http://httpd.apache.org/\">http://httpd.apache.org/</a>) (Rails uses Apache as its web server -- remember that bit about rails being a <q>full stack</q> framework?). The advantage of this is when a request is made for one of these assets, no rails code at all needs to be executed and the web server can simply serve the file back. This lowers stress on the rails application by not having to handle as many requests and makes for faster responses.</li>\n</ul>\n\n<hr>\n\n<p>Within <code>public</code>:</p>\n\n<ul>\n<li>\n<strong><code>public/assets</code></strong> is where Sprockets will place compiled assets (CSS/JS) to be served by the web server. They will not be visible here in development because the Rails server will use Sprockets to compile them on the fly during each request. In production, they are compiled into this directory.</li>\n</ul>\n\n<hr>\n\n<p>Lastly, like any good front-end developer, you'll want to lean on the experience of your peers by using some javascript and css libraries. Simply place those libraries in either <code>vendor/assets/javascripts</code> or <code>vendor/assets/stylesheets</code> and you'll be able to <code>require</code> them in your code in <code>app/assets</code>. Rails (technically Sprockets) will bundle everything up into one javascript or css file, put it in <code>public</code> and you'll be good to go.</p>\n/n<p>Remember that bit about convention over configuration? Well rails definitely prefers configuration to convention in one instance - routes. In the file <code>config/routes.rb</code>, you'll find direction given to the rails router on which controller method to call for a given request. Here's a simple route declaration:</p>\n;;;<p>If a user makes a request to <code>yoursite.com/articles</code>, the rails router will look for a controller called <code>ArticlesController</code> and if there's a method called <code>index</code>, it will call it, passing along the information in the request.&nbsp;</p><p>Then it's up to the controller to respond.</p>/n<p>You'll also see what rails calls <code>resources</code> in the routes file, which promotes the convention over configuration pattern. Resources handle the 85% case where your application is representing standard RESTful CRUD operations on a 'thing', such as an article. The above example route could be replaced with:</p>\n\n\n;;;\n\n<p>which would then mandate that the method names in the matching controller match the rails resourceful actions.</p>\n\n<p><u>(This is the very basic you need to know about routing to be able to do your front end magic. If you want to know more about rails routing, see <a href=\"http://guides.rubyonrails.org/routing.html\">http://guides.rubyonrails.org/routing.html</a>)</u></p>\n/n<p>With the above <code>resources :articles</code> in our routes file, if we have a controller file <code>app/controllers/articles_controller.rb</code> that simply inherits from the default application controller:</p>\n\n\n;;;\n\n<p>and a user makes a request to <code>yoursite.com/articles</code>, then rails will automatically respond with the contents at <code>app/views/articles/index.html.erb</code> because <code>/articles</code> corresponds to the <code>index</code> action.</p>\n\n<p>This is the simplest way to see the controller and view work together, but one feature of rails you'll be using quite frequently is how rails allows you to break up your views into smaller, more maintainable views using layouts and partials.</p>\n/n<p>Rails supports the concept of layouts, which are html files that provide the base skeleton of the page you'd like to return (meta tags, scripts, headers, footers, etc), to which you insert request-specific views.</p>\n\n<p>Rails decides which layout to use by first looking for a layout in <code>app/views/layouts/</code> that has the same name as the controller handling that request. In our <code>/articles</code> running example, rails would look for <code>app/views/layouts/articles.html.erb</code>. If that doesn't exist, then rails will use the application layout, which is traditionally at <code>app/views/layouts/application.html.erb</code>.</p>\n\n<p>You can, however, explicitly declare which layout to use in your controller. For example:</p>\n\n\n;;;\n\n<p>Would use the layout at <code>app/views/layouts/newspaper.index.erb</code> instead of the articles layout.</p>\n/n<p>Writing your layouts is just like writing a plain view, because, well, it is a plain view. Everything you can do in a view, you can do in a layout. However, within a layout you'll probably be using a few rails helpers to incorporate other views.</p>\n\n<h4><strong><code>yield</code></strong></h4>\n\n<p><code>yield</code> declares a point in your layout where the content from a view should be placed. The simplest example is:</p>\n\n\n;;;\n\n<p>which says, <q>when you use this layout to render a view, put the view content inside the `body` tag.</q></p>\n\n<h4><strong><code>content_for</code></strong></h4>\n\n<p>What if you want to insert multiple views into your layout? Then you can name your <code>yield</code> and then use <code>content_for</code> in the view that's going to be inserted to tell rails <q>here's the content for that named yield</q>. Here's an example layout:</p>\n\n\n;;;\n\n<p>and here's the view that would be applied to that layout:</p>\n\n\n;;;\n\n<p>So then rails renders your layout with the above view, it would result in the following html:</p>\n\n/n<p>Rails partials allow you to break your views into smaller chunks and then reuse those chunks anywhere you'd like. Create a view where you want to use a partial, create the partial view, and then use the <code>render</code> function to pull it into the view. For example:</p>\n\n\n;;;\n\n<p>and then in the file <code>app/views/shared/_nav.html.erb</code>:</p>\n\n\n;;;\n\n<p><strong>Notice</strong> the <code>_</code> in the name of the partial file. Underscores are how the rails community differentiates partials from other views, so all partials start with an underscore followed by the name of the partial. When referencing the partial in the <code>render</code> function, you do not include the underscore however.</p>\n\n<p>You can include partials in whatever directory you like, and even render the partial with its own layout, like this:</p>\n\n/n<p>Views are written in plain html. However, rails comes equipped with several helper functions that assist you in including assets and data from your rails application in the view so you don't need to write the actual html for including asset tags in your views.</p>\n\n<ul>\n<li>  <strong><code>javascript_include_tag</code></strong> results in a <code>&lt;script&gt;</code> tag being written to your view with the given source. Assuming you have some javascript in <code>app/assets/javascripts/application.js</code>, you'd include the script like this:</li>\n</ul>\n\n\n;;;\n\n<p>which would then write the following html to your view when a response is rendered:</p>\n\n\n;;;\n\n<ul>\n<li>  <strong><code>stylesheet_link_tag</code></strong> does a similar thing but for your css. Assuming you have a file in <code>app/assets/stylesheets/application.css</code>, you'd write:</li>\n</ul>\n\n\n;;;\n\n<p>which would result in:</p>\n\n\n;;;\n\n<p>The other html attributes in that <code>link</code> tag are rails' defaults, but you can override them with your own parameters:</p>\n\n\n;;;\n\n<p><strong>Note</strong> that with both the <code>javascript_include_tag</code> and the <code>stylesheet_link_tag</code>, you can include external files like so:</p>\n\n\n;;;\n\n<ul>\n<li>  <strong><code>image_tag</code></strong> also allows you to avoid having to write the full html for including an image. Just remember you <strong>need</strong> to include the file extension of the image:</li>\n</ul>\n\n\n;;;\n\n<p>which would result in the following html:</p>\n\n\n;;;\n\n<p><strong>Note</strong> that rails automatically gave your image an <code>alt</code> value - the name of the image minus the file extension and with the first letter in uppercase. You can declare your own <code>alt</code> value, along with any other html attributes as such:</p>\n\n/n<p>Remembering where the actual asset is for you to call it in your view code is a thing of the past with the asset pipeline. Just use the asset helpers above, give it simply the filename of the asset you're looking for, and since the asset pipeline dumps all of the final asset files into <code>public/assets</code>, your html will find the asset file no matter what directory and subdirectories your source files are buried in.</p>\n/n<p>Prefer to write coffeescript instead of javascript? Can't stand regular css so you write sass? That's cool. As long as you include the proper gem for each type of language you want to use and put the proper file extensions on the source file, the asset pipeline will recognize the language you're writing in and automatically run it through that language's interpreter. For instance, I like writing coffeescript over javascript, so in my Gemfile I put:</p>\n\n\n;;;\n\n<p>then write my coffeescript in a file named <code>myscripts.js.coffee</code> and when the asset pipeline goes to produce the minified, production ready javascript code, it sees the file extension as coffeescript and runs it through <code>coffee-rails</code>.</p>\n\n<p>This also works for multiple processors. For instance if you wanted to run your styles through sass and then jade to produce css (because it's Friday and you've had some drinks), then you'd name your file <code>mystyles.css.jade.scss</code>. The asset pipeline processes your source looking at the file extensions from right to left.</p>\n/n<p>As you're surely aware, the browser stores copies of the files it receives from the server in order to very quickly show files to the user when things haven't changed on the server. This is the browser cache. It's very nice when nothing has changed on the server, but what happens when you update some javascript code and want to make sure everyone who visits your site sees the new code, even if they've previously visited your site and have some of your asset files in their browser cache?</p>\n\n<p>Apache (rails' web server) tries to help with this by sending special HTTP headers to the browser (more on this at <a href=\"http://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-3-add-expires-header-7181.html\">http://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-3-add-expires-header-7181.html</a>) if you're interested), but unfortunately, different browsers handle this situation differently. Worst of all, some browsers (<u>ahem, IE</u>) ignore Apache's headers all together and always show the user cached assets so your user will never, ever see the updated version!</p>\n\n<p>The asset pipeline shines here by actually changing the filename of your asset each time you update it so that the browser doesn't know it's actually the same file. The browser thinks you switched out the asset file with a completely different (unrelated and not updated) file, so every browser ignores its cache in that scenario and shows the user your latest and greatest asset.</p>\n\n<p>How? Well when you use the asset helpers above, rails appends the MD5 digest to the filename so that the filename is guaranteed to be different every time you make an edit to that file. For example, if we use the <code>javascript_include_tag</code> helper to include our <code>application.js</code> file in one of our views, rails will actually write:</p>\n\n\n;;;\n\n<p>Rails' default configuration is to use this technique in production and not use it in all other environments. If you'd like to manually enable it in different environments, you can use the following in your <code>config/application.rb</code>:</p>\n\n/n<p>As we said before, rails' asset pipeline will compile assets and put them into the <code>public/assets</code> directory in production mode. Depending on your deployment strategy, you may want to compile these assets locally and the deploy your code to the server, in which case you'd use the rake task <code>rake assets:precompile</code>, which would result in all of your source files getting compiled and placed in <code>public/assets</code>.</p>\n\n<p>In development mode, this compilation doesn't occur ahead of time. It actually happens as you request each asset, allowing for compilation errors to show up at runtime. One thing that trips up even the most experienced rails developers from time to time is the fact that if you're in development mode and you previously compiled your assets to <code>public/assets</code>, the assets in the <code>public</code> directory are always served instead of compiling your new asset on the fly. This results in you making some changes to your javascript or css, refreshing the page, not seeing your changes, and not understanding why your changes aren't showing up. Use the rake task <code>rake assets:cleanup</code> to remove all of the files in <code>public/assets</code> and rails will compile your source files on the fly again and you'll see your changes.</p>\n/n<p>Here's where the controller/model hardcore ruby work that your server buddies do really meets the beautiful html/css/js work that you do. If you get a good grip on how data from rails models is passed to and represented in views, you'll be in the cool kids club.</p><p>Suppose in our articles example above we wanted the main page at <code>mywebsite.com/articles</code> to list all of the articles in our database? We'd have our <code>ArticlesController</code> look something like this:</p>\n;;;<p>Notice that we didn't need to explicitly call <code>render</code> in the <code>index</code> function definition. Since rails follows convention over configuration as much as possible, it will automatically render a view at <code>app/views/articles/index.html.erb</code> if it exists since we're in the articles controller and in the index function. Here's our view:</p>\n;;;<ul><li><strong><code>url_for</code></strong> is a helpful function that you'll most likely become accustomed to using to link to a specific data object. If we wanted to provide some direct link to viewing each article for the purpose of sharing on twitter above, we could use the following:</li></ul>\n;;;<ul><li><strong><code>link_to</code></strong> is another helpful function that allows you to link to an action in the controller, passing along the data that the link is in the context of. For example, we could add the following element in <code>&lt;div class=\"article\"&gt;</code> to give the user the ability to view the individual article:</li></ul>\n;;;<h6>Acknowledgements</h6><p>Thanks to Noah Larsen, Steve Bailey, and Ryan Cook for reviewing and editing early drafts. (@earlatron, @wouldthatiwere, and @cookrn respectively.)</p><p>Also thanks to the terrific Ruby on Rails guides at <a href=\"http://guides.rubyonrails.org/\">http://guides.rubyonrails.org/</a>, where much of the inspiration for this book was taken.</p>"
r1.writer = w1
r1.save

r2 = Recipe.create(name: "Developing an HTML5 Brick-breaker Game With Phaser")
r2.content = "<p><u><strong>Creating a Brick-breaker Game With Phaser</strong></u> is the result of teaching HTML5 game development by example at a local institute, focused on web technologies with a philosophy of <u>teaching concepts, methodologies and standards</u> in a practical way.</p>\n\n<p>This book is intended to be a hands-on introduction to HTML5 game development using the Phaser framework by developing a <em>complete</em> game with well-known mechanics. It is bundled with all the necessary assets, so we can focus on the code and not finding extra resources or developing <q>programmer artwork</q>.</p>\n\\n<p>By the end of the book, you'll have learned to:</p><ul><li>Set up an organized file structure for developing games for the web</li><li>Create a blank game and test everything runs OK</li><li>Import images and sounds</li><li>Show and move sprites on the screen</li><li>Manage a group of sprites</li><li>Play sound effects and background music</li><li>Show text on the screen with custom web fonts</li><li>Handle touch and keyboard input</li><li>Detect collisions and use the Arcade physics system</li><li>How to start using the particle system</li><li>Manage game states</li><li>Create a loading screen</li><li>Optimize the game for mobile devices</li></ul><p>You can play a version of this game on <a href=\"http://pctroll.itch.io/html5-breaker\">itch.io</a>, where you can also find the Android version.</p>\\n\n\n<p>It is aimed to programmers with some experience with JavaScript and want to learn by doing (<em>and finishing</em>). It is not a guide to JavaScript, but each step is explained and the source code is well-commented so you can get it right away and keep focusing on the big picture.</p>\n\n\\n\n\n<p>The Phaser web site has a <a href=\"http://phaser.io/tutorials/getting-started/index\">well-documented section</a> on how to get started. However, I invite you to test and develop the code from this book using the <a href=\"http://brackets.io/\">Brackets</a> editor. The code was developed and tested on it, and works well on Windows, Linux and Mac. Besides, testing the examples is far too easy:</p>\n\n<ol>\n<li>Install Brackets</li>\n<li>Make sure you have Chrome / Chromium browser installed</li>\n<li>In the menu bar, go to <strong><em>File -&gt; Open Folder...</em></strong>\n</li>\n<li>Locate a directory with an <code>index.html</code> file. For example: <code>brick-breaker-phaser/01core_mechanics/01paddle/</code>\n</li>\n<li>Select it</li>\n<li>In the menu bar, go to <strong><em>File -&gt; Live Preview</em></strong>\n</li>\n</ol>\n\n<p>There are other editors and tools, but the coding-testing pipeline on Brackets is very straightforward if you're new to web development.</p>\n\n\\n\n\n<p>The following people helped in the development of this book or the game associated with it:</p>\n\n<ul>\n<li>Richard Davey - creator of Phaser</li>\n<li>Christian Chomiak - editing and title page</li>\n<li>Kenney - artwork and some sound effects</li>\n<li>Joe Powell, courtesy of Freesound - background music (Electric Air)</li>\n<li>Sergio Marin, and the whole team at <a href=\"https://www.escuelaweb.net/\">Escuela Web</a>, for giving me a place to unite two of my passions; game development and teaching</li>\n<li>Luis Miguel Delgado - content review</li>\n<li>Ángel León - technical review</li>\n</ul>\n\\n\n\n<p>This chapter is focused on organizing our project to keep a tidy file structure. It will allow us to get a good start, and test the installation of Phaser. It is worth mentioning that we'll be using Phaser v2.3, <a href=\"https://github.com/photonstorm/phaser/releases/download/v2.3.0/phaser.min.js\">available here for download</a>.</p>\n\n\\n\n\n<ol>\n<li>\n<p>Create the following file structure: an empty <code>index.html</code> file and four additional directories; <code>css</code>, <code>img</code>, <code>js</code>, and <code>snd</code>, respectively. As we can see, it's a standard file structure for web development. As games grow, teams tend to specialize the file structure but right now it's not our case:</p>\n\n<pre><code>game\n|   index.html\n+---css\n+---img\n+---js\n\\---snd\n</code></pre>\n</li>\n<li>\n<p>Add the phaser <code>.js</code> file in the <code>js/</code> directory. Here we will store all of our scripting files:</p>\n\n<pre><code>+---js\n|       phaser.min.js\n</code></pre>\n</li>\n<li><p>Modify the <code>index.html</code> with the following code. This declares the type of document, its character encoding, includes the <code>phaser.js</code> file in the html, and creates a place for the game to be rendered:</p></li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a file named <code>main.js</code> in the  corresponding directory. This file will store the initialization code of our game:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Now include the previous file into the html file with the proper <code>&lt;script&gt;</code> tag. It must be included <em>below</em> the phaser include:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>\n<p>Finally, test the game by running it in the browser.  If we open the browser's JavaScript console, we can read a message from the Phaser API stating that it is initialized and everything runs smoothly.</p>\n\n<p><img src=\"https://codeplaceepubsassets.s3.amazonaws.com/311-6540501682-00_empty_game.png\" alt=\"Phaser output message\"></p>\n</li>\n</ol>\n\n\\n\n\n<p>Now that we know how to set up an empty Phaser project, I can tell you that inside the downloadable content there is a directory called <code>00empty_game</code> with the previous code, <em>plus</em> all the images and sounds that we will use to build our game.</p>\n\n<p>In case you're getting the book from Amazon, you can download the at: <a href=\"http://jorge.palacios.co/brick-breaker-book-resources/\">http://jorge.palacios.co/brick-breaker-book-resources/</a></p>\n\n<p>In the following chapters we will build our game, starting from the core mechanics. </p>\n\n\\n\n\n<p>This is the base chapter where most of the magic will happen, and that's because gameplay is the most important thing in our game (at least in the beginning). We will learn how to build our core mechanics progressively, starting with the paddle and user input, and finishing with collisions and high-level rules.</p>\n\n<p>Also, we'll learn the basics of handling game states but only for the purpose of coding the gameplay screen. How to handle state transitions will be covered in the following chapter.</p>\n\n\\n\n\n<p>Programming the paddle will teach us how to load images and get the user input, simple mouse input (like its position), and check whether a key is pressed.</p>\n\n<ol>\n<li>Create the <code>state_main.js</code> file in the <code>/js</code> directory. This file will hold the code for the state that handles the core mechanics:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the <code>preload</code> function. Here we will load all the assets to be used in the game. Right now it's just the paddle sprite, but that will change in the following sections:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the <code>create</code> function. This functions runs once and is used for setting up the sprite:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the member variables for handling paddle horizontal velocity and previous mouse position. We declare the movement to be 500px/sec and a member variable for storing the mouse position in the previous frame:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add the paddle sprite on the screen by using the game object's factory. Also,  set its anchor point to the bottom-center and finally create a custom member variable for storing the sprite's half size for future reference:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Call the function for restarting the paddle into its original position (not coded yet):</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the <code>update</code> function. It keeps running as long as the browser tab is focused, and here we'll code most of the loop-based and time-based game logic:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Declare and assign the variables for getting keyboard input from the arrow keys:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Assign the paddle position according to the mouse or keyboard input. If the mouse hasn't moved (this is why we declared <code>prevX</code>), then we check for keyboard input. It's important to mention that in this game the arrow keys are mutually exclusive:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Assign current mouse position as the previous:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Limit the movement of the paddle to the screen bounds:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the <code>resetPaddle</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Set the paddle's anchor point and place the paddle a little higher than the bottom of the screen:</li>\n</ol>\n\n\n;;;\n\n<p>It's time to link the <code>state_main.js</code> file to <code>index.html</code>:</p>\n\n\n;;;\n\n<p>This is how our <code>index.html</code> file should look like:</p>\n\n\n;;;\n\n<p>Finally, add <code>StateMain</code> to the game object and start the game with it:</p>\n\n\n;;;\n\n<p>By the end of this section, we should have a nice paddle moving along the X axis with the keyboard's arrow keys or following the mouse position.</p>\n\n\\n\n\n<p>Adding the bricks will teach us the basics of Phaser groups. As its name implies, the <code>Group</code> class is used to keep objects referenced in a set and easily change their shared properties (which we will learn in the next section).</p>\n\n<ol>\n<li>Load the bricks' images in the corresponding <code>preload</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Now, let's move on to the <code>create</code> function and declare the variables for the number of columns and rows:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a new empty <em>group</em> of sprites. This is basically a managed array of sprites to help us change shared values and properties easily; most of the time without having to iterate through them:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Declare an array for storing the list of image names for the bricks:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Finally, implement two nested loops in order to set up the brick rows. Take a look on how we place the bricks initially at <code>(0,0)</code> and then use the reference to the newly created sprite in order to change its properties. This will come in handy later when dealing with physics and collisions:</li>\n</ol>\n\n\n;;;\n\n<p>By the end of this section we should be able to see four rows and ten columns of bricks.</p>\n\n\\n\n\n<p>Now we will learn how to <u>get the ball rolling</u>, introducing physics and collisions; the bread and butter of game development. We will also have to tune some other objects in order to work well with the ball, so that's why we will split it into sub-sections in order to better understand each step.</p>\n\n<h3>Setting up</h3>\n\n<ol>\n<li>Load the ball in the preload function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the ball sprite and add a custom member variable for setting its <u><q>shot</q></u> state. The code must be placed <strong>before</strong> calling <code>this.resetPaddle()</code>:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Place the ball on top of the paddle and set the <u>shot</u> state to <code>false</code>, *<em>inside</em> the <code>resetPaddle</code> function: </li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Move the ball according to the paddle's position <strong>inside</strong> the <code>update</code> function, considering its <u>shot</u> state:</li>\n</ol>\n\n\n;;;\n\n<h3>Shooting and basic collision</h3>\n\n<ol>\n<li>Start the physics system to be used, <strong>at the beginning</strong> of the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Enable the physics system on the ball and its rigid body properties for bounding and colliding with the world:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add two more member variables to the ball for setting its initial velocity:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a new function named <code>shootBall</code> and define its behavior. We want to set the rigid-body velocity according to the initial values we created above, randomize whether it shoots right or left, and validate if it has been shot or not:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Enable the shooting via mouse click, at the end of the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Enable the shooting via keyboard, in the <code>update</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Set the ball's body velocity to 0 in the <code>resetPaddle</code> function:</li>\n</ol>\n\n\n;;;\n\n<h3>Colliding the ball with other objects</h3>\n\n<ol>\n<li>Enable the physics system on the paddle, and also make it immovable to the ball's collision, in the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Enable the physics system on the group of bricks. Notice that there's a little difference between enabling physics on a group and what we previously did with single sprites:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Set the immovable property on the bricks, one by one (inside the <code>for</code> loop):</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the collisions in the physics system <strong>at the beginning</strong> of the <code>update</code> function:</li>\n</ol>\n\n\n;;;\n\n<h3>Removing bricks</h3>\n\n<ol>\n<li>Create the function for removing a brick when colliding with the ball.:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Modify the <code>collide</code> function call for calling <code>removeBrick</code> when it checks the collision:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Turn off collisions with the bottom of the world, right after we set up the physics system:</li>\n</ol>\n\n\n;;;\n\n<p>By the end of this section we should have a shooting ball that collides with the paddle and destroys bricks when colliding with them.</p>\n\n\\n\n\n<p>Now we'll learn how to use the TileSprite object in order to create seamless backgrounds and the Text object to include readable content on the screen.</p>\n\n<ol>\n<li>Load the seamless sprites in the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the background TileSprite <strong>before</strong> creating the paddle:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the black-line TileSprite <strong>after</strong> calling <code>resetPaddle</code>, in the <code>create</code> function. We also want to reuse the previous variables for width and height:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a new file called <code>global.js</code> and place the string variables for holding text. The spaces are completely intentional:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Import the <code>global.js</code> file into the html <strong>before</strong> importing any other game code, and <strong>after</strong> importing Phaser:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create member variables for holding the player's lives and score, in the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the text objects <strong>after</strong> including the black-line tile sprite. Start with the one for showing the number of lives:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add the text object for showing points, only this time we will use a JSON object to configure it:</li>\n</ol>\n\n\n;;;\n\n<p>By the end of this section we should have a seamless starry background and a black line with the number of lives and points.</p>\n\n\\n\n\n<p>Finally, we will implement some additional rules for finishing the gameplay.</p>\n\n<ol>\n<li>Load the audio samples in the <code>preload</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the reference to the samples:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Set the background music to loop and play:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a new function to be triggered when the ball collides with the paddle and plays the sound:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Modify the function to check the collision:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Play the sound when the ball is shot, in the <code>shootBall</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a function for losing a life and resetting the paddle:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Enable the ball to check whether it is inside the world bounds, and add an event to call the <code>loseLife</code> function if the ball is out of bounds:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Expand the <code>removeBrick</code> function by adding the following lines:</li>\n</ol>\n\n\n;;;\n\n<p>After improving the gameplay screen it's time to create other states for the next screens, so we have a finished game. This was probably the longest chapter because here lies the basis for the rest of the book.</p>\n\\n\n\n<p>Previously we created our main state which handles the gameplay. Now we will create more states in order to have a little finished game.</p>\n\n<p>In this chapter we will learn about game states, which are commonly referred to as game <em>screens</em>, so to speak. When we talk about main screen, welcome screen, and over screen, we're talking about game states.</p>\n\n<p>We will use the skills from the previous chapter in order to speed up the process, reducing the number of steps and increasing the lines of code per step.</p>\n\n\\n\n\n<p>We will start by creating the introductory screen to welcome the player.</p>\n\n<ol>\n<li>Create a new JavaScript file named <code>state_intro.js</code> inside the <code>js</code> directory</li>\n<li>Include the previously created file in the html:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the new state:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Load the background and logo images:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Place the background and logo:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Check if the spacebar is pressed:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the function for moving into the next state:</li>\n</ol>\n\n\n;;;\n\n<p>Sometimes the games are embedded into web sites and need an initial click to focus the browser tab/window controls into it. Besides, we want the player to stablish an initial connection by clicking (because it's not common to use spacebar to start a game). That's why we will add a button. The process is similar but we will make use of the spritesheet loader.</p>\n\n<ol>\n<li>Load the button image as a spritesheet. The last parameters are related to the width and height of each spritesheet's frame:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the button, binding it to the <code>goToMain</code> function and placing it at the center of the screen:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Finally, modify the <code>main.js</code> file in order to include the new state and start the game with it:</li>\n</ol>\n\n\n;;;\n\n<p>By the end of this section we will have an introductory screen like the one below that changes to the gameplay screen after clicking the button or pressing spacebar.</p>\n\n\\n\n\n<p>We will now prepare everything to receive the player after removing all the blocks (or failing to do so).</p>\n\n<ol>\n<li>Add a couple of lines in the <strong><code>globals.js</code></strong> file:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create a new file named <code>state_over.js</code> in the <code>js</code> directory</li>\n<li>Include the file in the html:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the body of the state:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Load the background and the button we will use. Note that this is the button for going <strong>back</strong>:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Declare the <code>create</code> function. We will build it later because it's the most extensive one:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the <code>update</code> function for going back when pressing spacebar:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the function for going back:</li>\n</ol>\n\n\n;;;\n\n<p>Now it's time to build the <code>create</code> function in order to put everything in place.</p>\n\n<ol>\n<li>Declare the variables to hold the number of lives and points:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Include the background tile sprite as before:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Implement the code for creating and placing the button for going back</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Define the text configuration for the <q>*Game Over*</q> message:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the <q>*Game Over*</q> text object:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Validate the change of color and text, depending on the number of lives the player arrived with:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the text configuration for showing the number of points:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add the text object for the points:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add the current state in the <code>main.js</code> file:</li>\n</ol>\n\n\n;;;\n\n<p>If we test the state by starting the game with it, instead of using <code>StateIntro</code>, we will have the screen presented below.</p>\n\n\\n\n\n<p>We will add some rules, so we can transition to the <em>over</em> screen correctly.</p>\n\n<ol>\n<li>Add the function for going to the <em>over</em> state. Look how we make use of JavaScript in order to add new member variables to the Game object. This helps us in passing values between states without creating new global variables:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add the following validation <strong>at the end</strong> of the <code>removeBrick</code> function. The <code>countLiving</code> function (part of the Group object) helps us in counting the number of bricks alive:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Implement the validation for when the player runs out of lives, <strong>at the end</strong> of the <code>loseLife</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Go to the <code>state_over.js</code> file and change the following lines at the beginning of the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<p>We have completed a basic game with Phaser. *<em>Congratulations!!</em></p>\n\n<p>In the next chapter we will polish it a little bit more, but now we can show our friends the game and enjoy the results of our work.</p>\n\\n<blockquote><p><em>The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time</em>.</p></blockquote><p>-Tom Cargill</p><p>Like almost every game, our current game has some things we could polish before releasing it to the world.</p><p>In this chapter we will make some changes, as well as learning a couple of extra things about Phaser in order to improve the game. Let's start right away!</p>\\n\n\n<p>We will animate the tile-sprite background in the introductory screen and play a win/lose sound in the final screen</p>\n\n<ol>\n<li>Increment the <code>tilePosition</code> member of the <code>this.bgk</code> member variable in order to animate the seamless background in the <code>update</code> function of the <code>state_intro.js</code> file. We could also use the same technique in <code>state_main.js</code>:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Load the following audio sample in the <code>state_main.js</code> file:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Also, add the reference in the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Play the sample in the <code>loseLife</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Load the following sound samples in <code>state_over.js</code>:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Play one sample or the other in the <code>create</code> function, according to the number of lives:</li>\n</ol>\n\n\n;;;\n\n<p>There are more ideas to improve/change the gameplay. We could change the ball's direction depending on the side of the paddle it collides with, or increasing the ball's vertical speed after hitting more than two bricks in a row. We could also define special-purpose bricks (more resistant bricks, power-up bricks, blockers, etc). There's a wide range of possibilities!</p>\n\n\\n<p>Adding custom fonts is pretty easy and improves the way we show texts in our game</p>\n\n<ol>\n<li> Go to Google fonts website</li>\n<li>\n<p>Search for a font you'd like to use in the game. In our case we'll be using <strong>Overlock</strong> to illustrate the process</p>\n\n<p><img src=\"https://codeplaceepubsassets.s3.amazonaws.com/311-9490908253-3_01_fonts.png\" alt=\"\"></p>\n</li>\n<li>\n<p>Go to the <q><u>quick-use</u></q> section via the little button on the right</p>\n\n<p><img src=\"https://codeplaceepubsassets.s3.amazonaws.com/311-5718684903-3_02_fonts.png\" alt=\"\"></p>\n</li>\n<li><p>Add the JavaScript code shown into our html file <strong>after</strong> the <code>title</code> tag. For the Overlock font it would be the following:</p></li>\n</ol>\n\n\n;;;\n\n<ol>\n<li> Change all the <code>sans-serif</code> text to <code>Overlock</code>\n</li>\n</ol>\n\n<p>After selecting and including the font, we will be able to have a new font face in our game.</p>\n\n\\n\n\n<p>We want to celebrate the player's victory by placing a particle emitter in order to create some fireworks for the player who removes all the blocks</p>\n\n<ol>\n<li>Load the fireworks' image and sound sample in <code>state_over.js</code>:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the sample's reference in the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create and set up the particle emitter for the fireworks:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add a couple of member variables to set up the fireworks' timer:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Place the following line at the end of the <code>update</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create the fireworks validation and placement <strong>after</strong> the previous validation:</li>\n</ol>\n\n\n;;;\n\n<p>We have improved the reward for those players who survived until the end!</p>\n\n\\n<p>Let's face it, we're aiming for the web and despite this being a little game, we will probably make something more elaborate in the future. Besides, there are players from underdeveloped countries with slow connections (because I'm one of them). That's why we'll learn how to create a load screen.</p><ol><li>Create two new files; <code>state_init.js</code> and <code>state_load.js</code></li><li>Include them in the html file</li></ol>\n;;;<ol><li>Build the <code>state_init.js</code> file. This state just loads the images for creating the load bar:</li></ol>\n;;;\n\n<ol>\n<li>Start building the <code>state_load.js</code> file:</li>\n</ol>\n\n\n;;;<ol><li>Declare the <code>preload</code> function. The following four steps are to be coded <strong>inside</strong> the <code>preload</code> function:</li></ol>\n;;;\n\n<ol>\n<li>Create and place the background of the loading bar:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Create and place the foreground of the loading bar:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Set the foreground image as the preloading sprite:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Move <strong>ALL</strong> the asset-loading sentences here, from the <code>preload</code> functions in <code>state_main.js</code> and <code>state_over.js</code>. Don't touch the previously created <em>init</em> file:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Implement the <code>create</code> function for moving onto the intro screen:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Add the previously created files in <code>main.js</code>:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Finally, set the initial state to <code>StateInit</code>:</li>\n</ol>\n\n\n;;;\n\n<p>This is an important feature if we don't want our players to believe that our game is broken when they have slow connections.</p>\n\n\\n\n\n<p>Right now a lot of players don't come from personal computers, but from mobile devices. We're now going to implement the changes to support mobile devices <strong>fullscreen</strong>.</p>\n\n<ol>\n<li>Add the following tags in the html <strong>after</strong> the title tag:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Modify the body of the <code>create</code> function in <code>state_init.js</code>. We are using some Phaser capabilites for modifying canvas in order to adjust the resolution and center the game in the browser:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Move to <code>state_main.js</code> in order to make additional changes</li>\n<li>Create new variables for handling touch movement, in the <code>create</code> function:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Implement the routine for handling the touch movement, in the <code>update</code> function <strong>after</strong> the routine for handling input:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Implement a new function to be triggered when click/touch is down:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Implement a new function to be triggered when click/touch is up:</li>\n</ol>\n\n\n;;;\n\n<ol>\n<li>Modify the code for detecting click/touch and add the code for detecting click/touch release, near the end of the <code>create</code> function:</li>\n</ol>\n\n\\n\n\n<p>Now that we have our finished game, it's time to go out there and show it to the world. I know a couple of places to host the game freely: <a href=\"http://itch.io/\">itch.io</a> and <a href=\"http://gamejolt.com/\">GameJolt</a>. The process of creating an account and uploading the game is beyond the reach of this book, but it's very easy in both cases.  </p>\n\n<p>The process of uploading the game to these sites is very easy and it consists of taking every file in the root directory (the one with <code>index.html</code>), <em>zipping</em> them, and uploading the <code>zip</code> file. </p>\n\n\n;;;\n\n<p>That's it, we made it!!!</p>\n\n<p>We now have a polished game that displays  on mobile devices, works on slow connections and a couple more features. It feels really great, doesn't it? Let's go to the next chapter to wrap-up everything and release our game.</p>\n\\n\n\n\n\n<p>Congratulations for reaching this far and completing the game. They say that <em><q>releasing is a feature</q></em> and you have just released a game. How does it feel?</p>\n\n<p>Now you have the skills to start making, <strong>and finishing</strong>, your own games by following a similar pipeline to the one we learned here:</p>\n\n<ol>\n<li>Create the core gameplay</li>\n<li>Implement the basic screens: <em>beginning, middle, end</em>, as if we're telling a story</li>\n<li>Polish (or cut corners)</li>\n<li>Release!</li>\n</ol>\n\n\\n\n\n<p>There are game jams every now and then to take ideas from in order to define a theme and set a deadline. These are just a couple of sites that I love:</p>\n\n<p><a href=\"http://compohub.net/\">CompoHub</a></p>\n\n<ul>\n<li> This is a huge calendar with probably every game jam, competition and development event there is. It's worth checking to see the next events, and get ready to test your skills.</li>\n</ul>\n\n<p><a href=\"http://onegameamonth.com/\">One Game a Month</a></p>\n\n<ul>\n<li> 1GAM is a never-ending game jam to be held each month, each year. The idea is to master our game development skills by submitting 12 games in a year.</li>\n</ul>\n\n\\n\n\n<p>Again, I cannot express how grateful I am you're supporting this book but, most of all, <strong>finishing it</strong>. I'm learning the hard way how to finish and release things (specially games) and it's not as easy as it probably looks. That's why the book is structured the way it is. It took me a lot of time realizing that and I want you to be better, to learn early and release often.</p>\n\n<p>In case you find a mistake (and there could be plenty despite my efforts and the dear friends who proof-read the book), you're more than welcome to contact me via Twitter or email.</p>\n\n<p>You're also welcome to show your support, ask questions or write just about life; I'm a developer and human being like you. By the time of writing the book, I'm focusing my efforts on Unity and HTML5, as well as gameplay and AI programming (besides teaching, of course). I'm open to discuss ideas and say hi back.</p>\n\n<ul>\n<li>Twitter account: <a href=\"\">@pctroll</a>\n</li>\n<li>Web site: <a href=\"http://jorge.palacios.co\">http://jorge.palacios.co</a>\n</li>\n<li>Email: <a href=\"mailto:jorge@palacios.co\">jorge@palacios.co</a>\n</li>\n<li>También hablo Español: <a href=\"http://pctroll.net\">http://pctroll.net</a>\n</li>\n</ul>\n\n<p>Thank you.</p>\n"
r2.writer = w2
r2.save

r3 = Recipe.create(name: "Build your first API with Rails and Grape")
r3.content = "<p>In this tutorial we are building a Rest API on top of an existing Rails application. So after we are done we should have 2 ways of interacting with our application: The first is the tradicional way a Rails app works, i.e. via a web browser. The second is a API that can be accessed by external clients like a mobile App, an Angular app or, a third-part website for example.</p><p>For this we are using the Grape gem. Grape is a Rack application that can run on its own, or ride along with web applications like Rails or Sinatra.</p>\\n<p>For this tutorial we have a sample rails app to start with. Clone the project:</p>\n;;;<p>Install dependencies:</p>\n;;;<p>We will be using Paperclip for image uploads, so you must have <a href=\"http://www.imagemagick.org\" target=\"_blank\">Imagemagick</a> installed on your system.</p>\n;;;<p>On Mac OS, install it using <a href=\"http://On Mac OS, install it using Homebrew:\" target=\"_blank\">Homebrew</a>:</p>\n;;;<p>If you are on Debian/Ubuntu:</p>\n;;;<p>Run the app.&nbsp;</p><p>This sample comes with a small <span class=\"\" data-original-title=\"\" title=\"\">Sqlite</span> database already set up, so you don't need to run migrations. Just start it up:</p>\n;;;<p>Go to your browser <span class=\"\" data-concept=\"/select_concept?tech=rails&amp;val=ActiveJob\" data-original-title=\"\" title=\"\">and</span> enter <a href=\"http://localhost:3000\" target=\"_blank\">http://localhost:3000</a>. You should see something like this:</p>\n;;;<p>Go ahead and explore the web app. Try inserting some new manufacturer or vehicle. We will be doing this same operations later via our new Rest API.</p>\\n<p>Add the gem to your Gemfile:</p>\n;;;<p>Now run:</p>\\n<p>The first thing to be defined is the mounting point for our API. Following the best practices, it is recommended that you aways version an API. So we should have something like this:</p><p>&nbsp;<a href=\"http://mydomain.com/api/v1\"></a><a href=\"http://mydomain.com/api/v1\"></a><a href=\"http://mydomain.com/api/v1\">http://mydomain.com/api/v1</a>&nbsp;</p><p>This way, once our API is made available to the public we wont brake compatibility with clients already accessing it. Any edition that alters endpoints should be done in a new version of the API.</p>\n;;;<p>Create the folder structure for the API classes. They will reside at <code>lib/api/v1/</code>.&nbsp;</p>\n;;;<p>Create the main API class:</p>\n;;;<p>The first 2 options declared should be self explanatory. We are telling Grape to mount the API in the path <code>/api/v1/</code>. Then we say that it should respond with <span class=\"\" data-original-title=\"\" title=\"\">JSON</span> format. Grape automatically handles serialization for us.</p>\n;;;<p>We must tell Rails to load our API Classes folder, by adding it to autoload paths:</p>\n;;;<p>Finally, we should declare the mounting point in <code>routes.rb</code>:</p>\n;;;<p>Now if you run <code>rake routes</code> in terminal you will notice something new:</p>\n;;;<p>The resulting code for this section is available <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/a02fe5f6d8bd546fc4fdb765c8062c1b06de9794\" target=\"_blank\">here</a>.</p>\\n<p>Lets create the manufacturers endpoint. We should provide a way to list the records of manufacturers on our application.</p><p>For each model we have on our Rails App we will be creating a separated file for its API endpoint. Go ahead and create a new file named <code>manufacturers.rb</code> inside the folder structure we just created.</p>\n;;;<p>This class will inherit from the <code>Grape::API</code> class.</p>\n;;;<p>Edit the base API class to mount the new endpoint</p>\n;;;<p>Lets check what we have so far. Restart the server and point your browser to <a href=\"http://localhost:3000/api/v1/manufacturers\"></a><a href=\"http://localhost:3000/api/v1/manufacturers\">http://localhost:3000/api/v1/manufacturers</a>.&nbsp;</p><p>You should see a JSON response like this:</p>\n;;;<p>Not much yet, but its working.</p><p>Also, lets use a more appropriate tool to test our API: <a href=\"http://www.getpostman.com/\" target=\"_blank\">Postman</a>. It is available as a Google Chrome extension for any platform, or a native app for Mac.</p>\n;;;<p>Select the method GET, enter the url and hit Send. Now we can see the response with more details, like HTTP Headers and other stuff. Click on 'Pretty' to see the response in a nice formatted shape.</p><p>The resulting code for this section can be seen <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/dd430dd7399d222722f0a21bdacd99415d0eea75\" target=\"_blank\">here</a>.</p>\n;;;<p>Now lets create another GET method, this time for presenting a specific Manufacturer, assuming that a manufacturer's id is provided.</p>\n;;;<p>Go back to Postman and enter the url <a href=\"http://localhost:3000/api/v1/manufacturers/1\">http://localhost:3000/api/v1/manufacturers/1</a></p>\n;;;<p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/4c90d1cad605d6cfe308cc3aaccc3b4edb54e1e7\" target=\"_blank\">here</a>.</p>\\n<p>What happens if we provide an invalid manufacturer id in the endpoint we crafted earlier? Let's try <a href=\"http://localhost:3000/api/v1/manufacturers/5\">http://localhost:3000/api/v1/manufacturers/5</a></p>\n;;;<p>Notice that the response status changed from \"200 OK\" to \"404 Not Found\". But we raised an Active Record error because such record with id 5 doesn't exist. This causes Rails to respond with HTML content, i.e. the standard Rails error page. Our API must handle this kind of error and respond in JSON instead. Let's fix this.</p>\n;;;<p>Open our API base class and add this:</p>\n;;;<p>Basically we are telling Rails to rescue whenever an error <code>ActiveRecord::RecordNotFound</code> happens; we intercept it and send a nice formatted JSON response with the <code>rack_response</code> method.</p><p>By inserting this code in the Base class we are making sure that all endpoints of our API will be covered, as they will inherit from it.</p><p>That's better:</p>\n;;;<p>We should also handle some other unexpected errors. For example let's say our database goes down. In production environment Rails would raise an error and send to the client the default HTML page for Error 500 (Internal server error). Let's handle that too:&nbsp;</p>\n;;;<p>What is happening here?</p><p>Early we were telling Rails to rescue from a specific error. After that in line 13 we are saying that anything else, whatever the error is, should be rescued also. We pass <code>:all</code> as parameter, and the variable <code>exception</code> passed in the block will receive the error contents.&nbsp;</p><p>Then we proceed concatenating the error message and the backtrace, to be added to the logger. For the client we wont be passing any details of the error of course, but just a generic error 500 message.</p><p>As a result any unexpected error will return this nice and clean JSON to the client.</p>\n;;;<p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/6b42de4ccb54d6d9fff7948c59a52937a8cb90f8\" target=\"_blank\">here</a>.</p>\\n<p>Let's create the Vehicles endpoint. Besides getting vehicles, we need methods to insert new ones, and also to edit them.</p>\n;;;<p>Create vehicle endpoint class:</p>\n;;;<p>Mount it:</p>\n;;;<p>Open Postman and visit <a href=\"http://localhost:3000/api/v1/vehicles\">http://localhost:3000/api/v1/vehicles</a>&nbsp;<a href=\"http://localhost:3000/api/v1/vehicles\"></a></p>\n;;;<p>It works, but the outputs can be greatly improved. There is a lot on data that don't need to be there. We will fix that in the next section.</p><p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/19bfbd521d4c0a48e05a6b86975165a37f4b02d2\" target=\"_blank\">here</a>.</p>\\n<p>We need to improve the output of our GET method. As we saw in the last section, there is a lot of data we don't need to expose via the API, like the image attributes created by Paperclip, and the timestamps.</p>\n;;;<p>We should use the gem <a href=\"https://github.com/ruby-grape/grape-entity\" target=\"_blank\">grape-entity</a>, which allow us to have more advanced options when presenting our data. add the gem to your Gemfile and run <code>bundle install</code> again.</p>\n;;;<p>Create a new file called <code>entities.rb</code>.</p>\n;;;<p>We just created our first Entity. You do that by declaring a class, usually with the same name of the Model we want to expose, and making it inherit from <code>Grape::Entity</code>. Then you declare only the attributes you want exposed, with the option <code>expose</code>.</p><p>Now back in the <code>vehicles.rb</code> file, we will use this Entity to present the model. Use the option <code>with</code> and pass to it an Entity we declared before:</p>\n;;;<p>We can make more improvements. First lets make adjustments to manufacturer also.</p>\n;;;<p>As you can see, you can have nested Entities. The result is this:</p>\n;;;<p>We can go further and do 2 more things. First we can expose the date the vehicle was created in our catalog.</p>\n;;;<p>Here we are using the <code>format_with</code> helper, that allow us to create a custom format for attributes. It takes a block which is passed as the value of the exposed attribute. We are just taking created_at attribute and formatting it to be more readable. Lastly, we call the <code>expose</code> method in conjunction with our formatter, identified as <code>timestamp</code>.&nbsp;</p>\n;;;<p>Second, we can expose the image url:</p>\n;;;<p>Paperclip only provides a relative path for the image, so we must complete the rest so it can become an absolute path. With <code>opts[:env]['HTTP_HOST']</code> we catch the host according to the environment. For example, when running on development, it will be <em>localhost:3000</em>.</p>\n;;;<p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/cf732c94f047e94ce0cbea31a1aefac4c8dc95e3\" target=\"_blank\">here</a>.</p>\\n<p>We need a way to insert new vehicles in our catalog. Lets make a new POST method.</p>\n;;;<p>In the <code>params</code> block we are declaring 3 required params and 1 optional. We are also validating the type of each param. Then we define a post block. It will receive the request, and inside it we create a new vehicle object, save it and respond whit the object we just created.</p>\n;;;<p>There is one more thing we need for it to work though. Add the gem <a href=\"https://github.com/Maxim-Filimonov/hashie-forbidden_attributes\" target=\"_blank\">hashie-forbidden_attributes</a> in <code>Gemfile</code> and run <code>bundle install</code> again. An explanation for why this is needed can be found <a href=\"https://github.com/ruby-grape/grape/issues/553\" target=\"_blank\">here</a>.</p>\n;;;<p>Finally, lets test the insertion of a new Vehicle.&nbsp;</p><p>1. Open Postman, change method to POST and enter the url <a href=\"http://localhost:3000/api/v1/vehicles\"></a><a href=\"http://localhost:3000/api/v1/vehicles\">http://localhost:3000/api/v1/vehicles</a>;</p><p>2. Click in \"Body\" tab, and enter the values as illustrated on the figure bellow;</p><p>3. Go ahead and hit send.&nbsp;</p>\n;;;<p>Notice 2 things here: first the response status 201, meaning the resource was successfully created. Second, The API responded whit the object we just created.</p>\n;;;<p>&nbsp;What happens when any of the required params is not provided in the request? An error will be raised. So we need to rescue from it. Lets add another <code>rescue_from</code> block in ou Base class:</p>\n;;;<p>We use the Grape method <code>error!</code> to respond. It takes 2 arguments: The message and the HTTP response type. Status 400 means 'Bad Request'. Grape automatically adapts the response to the format we declared earlier in line 7 with method <code>format</code>, which is JSON.</p><p>Now, lets see how our API responds to an invalid POST request.&nbsp;</p><p>1. Enter the url <a href=\"http://localhost:3000/api/v1/vehicles\">http://localhost:3000/api/v1/vehicles</a>. Don't forget to use POST;</p><p>2. Click in the Body tab, enter only 'price' as the <code>key</code> and, any <strong>no numeric</strong> text in <code>value</code>. See the example in the image. We want to simulate an invalid price.</p><p>3. Without providing any other attribute, hit send and watch the result.</p>\n;;;<p>As you can see it returned a nice JSON telling what is wrong.</p>\n;;;<p>There is one thing left: the image upload.</p>\n;;;<p>To start, we declare our required image parameter. But before creating our object, we need to manually build the uploaded file passed in params, and attach it later to our vehicle object.&nbsp;</p><p>The result is returned as expected:</p>\n;;;<p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/821da0da5c2358fdc45a2d03b846068fc703fd73\" target=\"_blank\">here</a>.</p>\\n<p>Making PATCH (for editing a register) and DELETE methods is not much different from what we have done earlier.</p>\n;;;<p>First the PATCH method:</p>\n;;;<p>This is the result of a PATCH request.</p>\n;;;<p>Let's add the DELETE method in the sequence.</p>\n;;;<p>There is just one thing different here. When responding a DELETE request, it is recommended that the server respond with a status code <code>204 No content</code>, and an empty body. Line 73 does just that.</p><p>As aways, we can test it with Postman to see how it look. Change the method to DELETE, accessing the same endpoint <a href=\"http://localhost:3000/api/v1/vehicles/17\">http://localhost:3000/api/v1/vehicles/17</a>.</p>\n;;;<p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/8fd54fcd5f3120550256400f466a54b0170b5530\" target=\"_blank\">here</a>.</p>\\n<p>Until now we are testing our API making requests from localhost to localhost. The client (Postman) is in the same machine in which our application is runing (rails server). But in the real world an API is likely to receive requests from clients in different domains, i.e a <em>cross-site request</em>. Just to clarify: Cross-site requests are HTTP requests for resources from a different domain than the domain of the resource making the request.&nbsp;</p><p>Due to a security feature, such kind of clients will be blocked by our API by default. However there is a method we can use to make secure cross-site requests, and its called CORS(Cross-Origin Resource Sharing).</p><p>For our convenience, there is a <a href=\"https://github.com/cyu/rack-cors\" target=\"_blank\">gem for that</a>. &nbsp;Let's use it in our application.&nbsp;</p>\n;;;<p>Add the gem to our Gem file and run <code>bundle</code> again.</p>\n;;;<p>Insert this in <code>application.rb</code>:</p>\n;;;<p>Whats happening here?&nbsp;</p><p>First, in line 30 we are accepting requests from any domain over the internet.</p><p>At line 31 we are declaring that any resource is available, and then we allow any headers; &nbsp;finally we declare the methods that are allowed.</p><p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/f24b29d2012cea1202b82403c4cc85bce315974c\" target=\"_blank\">here</a>.</p>\\n<p>When working with rails applications, there is a very useful command to list all the routes configured in your application. Running the command <code>rake routes</code> we can see all the routes configured in the <code>routes.rb</code> file.&nbsp;</p>\n;;;<p>One thing you will notice though is that, besides the routes for the views, we only see here the mounting point for our API. The complete routes for the endpoints are missing.</p><p>We can easily fix that by customizing the routes task. Create a new file under tasks named <code>routes.rake</code>.</p>\n;;;<p>We just created another routes task under api namespace. This task will list all routes &nbsp;under the API.</p><p>Now, run the command <code>rake api:routes</code> and watch the output:</p>\n;;;\n\n<p>The resulting code for this section can be found <a href=\"https://github.com/fabianoarruda/tutorial-grape-api/tree/11047ceb341d88fc5ffd48a76ed579aad99ab3e1\">here</a>.</p>\n"
r3.writer = w3
r3.save

r4 = Recipe.create(name: "Using MongoDB with Rails")
r4.content = "<p>In this lesson, we are going to create a Rails app to play around with using MongoDB as a database.</p><p><br></p><p>It is going to be a simple book reference application.</p>\r\n\\n<p>The first step of every Rails application is to generate it. This is exactly, what this lecture is about.</p>\n;;;<p>First you want to generate a new Rails application without ActiveRecord. The name will be&nbsp;<strong>mongorail</strong>.</p>\n;;;<p>Change to the application's directory to start using it.</p>\\nThis is this section introductory text. You must provide a good summary of the content of the section. Only text input is allowed.\n;;;<p>Add the <strong>mongoid</strong> gem to the &nbsp;<code>Gemfile</code>&nbsp;.</p>\n;;;<p>After adding the&nbsp;<code>Gemfile</code>&nbsp; you have to run bundler to install your added gems.</p>\n;;;<p>You have to create the necessary configuration files for connecting to the database, much like &nbsp;<code>database.yml</code>&nbsp;&nbsp;in ActiveRecord.</p>\\n<p>Twitter Bootstrap is a quick and easy way to style your application. We are going to use it in this recipe as well.</p>\n;;;<p>Change your &nbsp;<code>application.html.erb</code>&nbsp;&nbsp;layout file to add the includes from <a href=\"http://getbootstrap.com/getting-started/\" target=\"_blank\" rel=\"nofollow\">Bootstrap's Getting Started</a> page. In the same step, wrap the&nbsp;<code>yield</code>&nbsp; &nbsp;call in a container div.</p>\\n<p>While MongoDB is a schemaless database, that is organized around documents, it doesn't mean, you don't need a data model in your Rails application. Most of your objects you are going to store have a certain schema. The only difference is, we don't have to run migrations if we add or remove fields.</p>\n;;;<p>Create the&nbsp;<code>Book</code>&nbsp; model by running the Rails generator. The book has the following attributes:</p><p><br></p><ul><li>title <em>(String)</em>&nbsp;– The title of the book</li><li>isbn <em>(String)</em> – The 13 digit ISBN of the book</li><li>abstract <em>(String)</em>&nbsp;– A short description about the books contents</li><li>pages <em>(Integer)</em>&nbsp;– The number of pages of the book</li><li>price <em>(Float)</em>&nbsp;– The price of the book</li><li>released_at <em>(Date)</em>&nbsp;– The release date of the book</li></ul><p><br></p><p>Don't forget to add the&nbsp;&nbsp;<code>--no-stylesheets</code>&nbsp;&nbsp;option to avoid a SCSS file from being created.</p>\n;;;<p>When you look at the generated model file, you can see how fields are defined in Mongoid.</p>\n;;;<p>A model doesn't inherit from any class. It is a plain old Ruby class, that includes the &nbsp;<code>Mongoid::Document</code>&nbsp;&nbsp;module. It is a concern, that extends the class to be used to interact with MongoDB.</p><p><br></p><p>The schema is defined by the &nbsp;<code>field</code>&nbsp;&nbsp;method, that needs the attribute name and a hash with the type (that defaults to &nbsp;<code>String</code>&nbsp;) &nbsp;as arguments.</p><p><br></p><p>Fields can have a number of native Ruby data types, including&nbsp;<code>Array</code>&nbsp;,&nbsp;<code>Hash</code>&nbsp; or &nbsp;<code>Range</code>&nbsp;. You can find a full list of supported fields in the <a href=\"https://docs.mongodb.org/ecosystem/tutorial/ruby-mongoid-tutorial/#fields\" rel=\"nofollow\" target=\"_blank\">Mongoid</a><a href=\"https://docs.mongodb.org/ecosystem/tutorial/ruby-mongoid-tutorial/#fields\" rel=\"nofollow\"> documentation</a>.</p>\\n<p>Normally inheritance in Rails is quite a pain. When using MongoDB it is very easy and convenient. Since you don't have a schema, you don't have to worry about the restrictions of STI (Single Table Inheritance).</p>\n;;;<p>Manually create a new&nbsp;<code>ChildrensBook</code>&nbsp; model.</p>\n;;;<p>A children's book just uses object inheritance to be a sub-model of &nbsp;<code>Book</code>&nbsp;. It gets stored in the same collection, but can be queried either separately or together.</p>\n;;;<p>Change the &nbsp;<code>BooksController</code>&nbsp;&nbsp;to explicitly query for &nbsp;<code>ChildrensBook</code>&nbsp;&nbsp;items.</p>\n;;;<p>Change the &nbsp;<code>books/index</code>&nbsp;&nbsp;page to have a separate section for children's books.</p><p><br></p><p>Also change the paths, of the Show and Destroy links to point to &nbsp;<code>book_path(book)</code>&nbsp;.</p>\n;;;<p>Using the Rails console, create a children's book.</p>\\n<p>Of course each book has an author. We want to store this in a separate document and associate the books to the author object.</p>\n;;;<p>First, scaffold the &nbsp;<code>Author</code>&nbsp;&nbsp;resource.</p>\n;;;<p>Associate the &nbsp;<code>Author</code>&nbsp;model with the&nbsp;<code>Book</code>&nbsp;model using a &nbsp;<strong>one-to-many relationship</strong>.</p>\n;;;<p>Since the two models are now connected we can change the views to reflect this. Change the &nbsp;<code>book/index</code>&nbsp;&nbsp;and &nbsp;<code>book/show</code>&nbsp;&nbsp;pages to show the author.</p>\n;;;<p>Change the book's form to be able to select an author during creation and editing.</p>\n;;;<p>To avoid hitting the database for on the&nbsp;&nbsp;<code>books/index</code>&nbsp;page&nbsp;for every author (which is referred to as the N+1 problem), change the&nbsp;<code>BooksController</code>&nbsp; to eager load the authors.</p>\n;;;<p>On the author's page, we can also display all the books he's written. Change the &nbsp;<code>authors/show</code>&nbsp;&nbsp;page to include this information.</p>\\n<p>Mongoid has a query language, that is similar to JavaScript. It also takes a lot of programming patterns out of there. One of those patterns is <strong>MapReduce</strong>, an algorithmn where you first map the interesting values to a key, and then reduce those values to one value per key.</p>\n;;;<p>Create the map/reduce functions in the &nbsp;<code>AuthorsController</code>&nbsp;'s&nbsp;<code>index</code>&nbsp; method.</p>\n;;;<p>This will go through each book in the database, and in the map function, extract the number of pages and associate it with the author if there is one. The reduce function will count all pages for each author together and also count the number of books up by one.</p>\n;;;<p>Change the &nbsp;<code>authors/index</code>&nbsp;&nbsp;page to include the total number of books and pages for each author.</p><p><br></p><p>In the same step, change the table's classes to use Bootstrap CSS.</p>\\n<p>In MongoDB the context of embedding data into a documehnt exists. You can think of it as a sub-document of sorts. This means, that is tightly coupled to its associated document, and can't be queried without knowing its parent. This makes sense, when an object can't exist without its association (like reviews of a book need the book to exist).</p>\n;;;<p>Scaffold the &nbsp;<code>Review</code>&nbsp;&nbsp;model.</p>\n;;;<p>Change the&nbsp;<code>Review</code>&nbsp; model to reflect its association with&nbsp;<code>Book</code>&nbsp;. Additionally, add the &nbsp;<code>Mongoid::Timestamps</code>&nbsp;&nbsp;concern, to enable the use of&nbsp;<code>created_at</code>&nbsp; and&nbsp;<code>updated_at</code>&nbsp;.</p>\n;;;<p>Change the&nbsp;<code>Book</code>&nbsp; model to reflect its association with &nbsp;<code>Review</code>&nbsp; and add an order condition, so that the newest reviews will be first in the list.</p>\n;;;<p>Now that the association is made, we can work on the controller and views to reflect this relationship in the user interface.</p><p><br></p><p>First let's show a listing of the reviews on the &nbsp;<code>books/show</code>&nbsp;&nbsp;page. It loops through all reviews and shows them.</p>\n;;;<p>The reviews all feature a score, which can be used to display an average score on the &nbsp;<code>books/index</code>&nbsp;&nbsp;page. This can be done using standard Rails aggregates.</p>\n;;;<p>Right now displaying the reviews should work fine, but we can't really test it, since there is no way to add new reviews through the user interface.</p><p><br></p><p>Create a new partial for the &nbsp;<code>Review</code>&nbsp;&nbsp;form.</p>\n;;;<p>Create a ReviewsController, that is responsible for creating the reviews. It only has one action: &nbsp;<code>create</code>&nbsp;.</p>\n;;;<p>Also change your routes.rb file to include the reviews resource.</p>\n;;;<p>Finally enable the form on the &nbsp;<code>books/show</code>&nbsp;&nbsp;page above the other reviews.</p>"
r4.writer = w4
r4.save

r5 = Recipe.create(name: "Trailblazer")
r5.content = "\n\n<p>In the late summer of 2006 I had my first date with Rails. Oh, I remember it, I was nervous and had sweaty palms. Tobi, a good friend of mine, walked me through models, views, controllers and tests. He was so excited about it that he could already recall two dozens of TextMate shortcuts for arbitrary things you apparently needed for writing Rails apps.</p>\n\n<p>Coming from Perl and PHP, both used with a strict and very object-oriented discipline, but both incredibly ugly languages to look at, I was fascinated by Ruby and its beautiful syntax. And I loved ActiveRecord! I had been working on a object-relational mapper in Perl myself for years, its name <u>DataObjects</u>, its implementation far away from ActiveRecord's maturity.</p>\n\n<p>And I remember digging the integration of tests in Rails. Tests have been an integral part of my work before Rails, but it was always a bit messy and felt clumsy. Now, a framework that ships with automatic testing - amazing!</p>\n\n<p>So I set up a basic Rails app for tracking how many beers I was having at parties and to calculate my blood-alcohol value at every time of the night. Well, that was the goal, and I'm still working on it, haha. Ridiculous, I know.</p>\n\n<p>After about two hours I had models and first unit tests in place and I was just enjoying the simplicity how SQL was abstracted and how controllers would let me create dynamic web pages without all that pain.</p>\n\n<p>While I'd still create users via the console, I wanted to display a small box in several pages, showing the users who recently joined the project, a bit like a sidebar. Even though there wasn't even a form to sign up, yet, I found this an important feature.</p>\n\n<p>And this was the birth of Trailblazer.</p>\n\n<p>Of course, I didn't know that by the time.</p>\n\n<p>I literally spent days to find out how to encapsulate a piece of Ruby logic along with a part of a view in Rails. Forums (yeah, back then, we used forums), IRC chats (yeah, back then we were using <q>chat systems</q>) and talking to some fellow Rails developers in town (yeah, back then we used to actually <u>talk</u> to each other in real life) didn't help.</p>\n\n<p>Everyone kept telling me to use a partial, a shared controller action, a shared <code>before_filter</code> and a helper. And people told me that this is perfect and exactly how it's done and everything else is just a waste of time and no one needs more encapsulation.</p>\n\n<p>That's what they said, back then.</p>\n\n<p>I wasn't happy with that at all. It felt wrong to spread code of a single component across all the layers of the framework.</p>\n\n<p>Eventually, I'd stumble upon a small Ruby script called <code>cells.rb</code>, written by the great Ezra Zygmuntowicz<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>. I never had the chance to say Thanks to Ezra in person for these few lines of code he'd written, but they have changed my life.</p>\n\n<p><u>Cells</u> was a little script that provided plain Ruby classes with the ability to use the Rails rendering stack - exactly what I wanted!</p>\n\n<p>Cells became a Rails plugin, then a Ruby gem, then moved to Github, and it has kept my life busy with programming for years. Of course, it wasn't only Cells.</p>\n\n<p>Once I was in that mindset of questioning Rails and its architectural concepts, I couldn't stop. It was too late. Everytime I ran into a problem with Rails, I instantly started writing a gem to solve it. Every gem grew its own ecosystem and users soon started to use other gems from my alternative stack, too, which made me work even harder on integrations between the different layers.</p>\n\n<p>Many years, ten-thousands of lines of code written, tested, deleted, a few dozens Ruby conferences and hundreds of beers later, I present you Trailblazer.</p>\n\n<p>This is my distill, my extraction from almost a decade in the Ruby and Rails community, a mesh-up of the gems I found helpful and an attempt to introduce desperately needed abstraction layers into this great framework.</p>\n\n<p>Enjoy the ride, and never forget: Hydration is key.</p>\n\n\\n\n\n<p>You might wonder how to read this book, an my answer is <u><q>In a cosy place with a coffee or a beer at hand.</q></u> All the code to understand the concepts is printed in the book, so you not necessarily need a computer. However, it is helpful to browse the tagged versions for additional code. For example, I don't discuss every single test case I wrote.</p>\n\n<p>I spent a remarkable amount of time structuring this book. The structure aims to allow you to skim over or skip entire chapters. Even if you don't know how forms exactly work or what's a twin's job you will be able to understand it from the context. So, what I'm saying is, I encourage you to jump to chapters that attract you most. Although not harmful, there's no need to read this book from the first page to the last.</p>\n\n<p>Also, please take breaks. The chapters are designed to roughly take you 45 minutes to read and to flick through the corresponding code on Github. At the beginning of each chapter I will link to a branch on the <a href=\"https://github.com/apotonick/gemgem-trbrb\">gemgem-trbrb</a> repository which contains all the code of the running application at that very state of the book.</p>\n\n<p>Chapter 2, <u>The Trailblazer Architectural Style</u>, is a comprehensive summary of the patterns and concepts used throughout this book. It aims to be a formulation of the architectural style with minimal code examples. All following chapters contain a lot of code where we actually use Trailblazer to build a real application.</p>\n\n<p>I advise you to jump directly into chapter 3, <u>Operations And Forms</u>, for now! Chapter 2 is a very interesting, but also a bit longer read, and might be even more fascinating after you've played with Trailblazer a bit.</p>\n\n\\n\n\n<p>For every Rails project, there is exactly two outcomes. Either someone in the team's an experienced architect and leads the software to an advanced design with service layer, view components, maybe forms, and so on. Or, and that's the classic way, the project strictly follows the <u>Rails Way</u> and will end up as a code disaster.</p>\n\n<p>Explaining why a conventional Rails architecture fails is simple: There <u>is</u> no architecture.</p>\n\n<p>The fatal delusion that three abstraction layers, called <q>MVC</q>, are sufficient for implementing complex applications is failure by design.</p>\n\n<p>This is not because Rails is <q>Omakase</q> and everyone is supposed to mix in what they feel is right, no, that is not the purpose of a framework! A framework's job is to provide boilerplate code and architectural guidance. Claiming that Rails is <q>Omakase</q> is an excuse for the complete lack of the latter.</p>\n\n<p>Shortly after its inception in 2004 the Rails core team has completely stopped innovation on the architectural level. Probably assuming that the degree of abstraction is good enough, an incredible work load has been put into making it faster, cleaner, less coupled, adding fantastic features to ActiveRecord, a master-piece of software craftsmanship, integrating it with other products like test frameworks or CoffeeScript - the list could go on for pages.</p>\n\n<p>And now don't get me wrong. I couldn't express how much respect I have for all those people and all the work that has been done on Rails and its ecosystem. It is beyond my imagination how many hours have been spent on all that, and that mostly because people believe in Open Source and want to share benefits of their work with others.</p>\n\n<p>What made me work on an alternative stack for Rails is the realization that the core team doesn't want change. The fact that thousands of projects that had a quick start with Rails are now in an unmaintainable state of chaos bubbles up the <u>Rails Ivory Tower</u>™ only slowly, like the hang-over when brushing your teeth the next morning after a wild party night without decent hydration.</p>\n\n<p>On an architectural level, everything in Rails is crying for separation and encapsulation. But those cries go unheard, mostly.</p>\n\n<p>Instead of identifying and implementing new layers like form objects, things get violently pressed into the controller and the model, both in the framework itself and in your application code. All that just because of fearing over-abstraction. Why on earth is Rails constantly trying to solve incredible complex problems in one gigantic, monolithic class?</p>\n\n\\n\n\n<p>When I was younger I tended to stand up for hard-core encapsulation. When it came to Rails, I saw the problems of the monolithic design and I wanted to solve all the dependencies by separating things in a very strict way. While I still believe in separation of concerns and encapsulation more than ever, I've learned an important lesson.</p>\n\n<p>The reality is, people use Rails because it helps them shipping products, getting stuff done in a very fast way. It takes a few hours and you might have a first presentable version of a shop, for instance. This is a result of zero encapsulation in Rails. You just build things without thinking too much about where goes what. This is why Rails is so popular: you knock together a project with a minimum of conventions, interfaces and specifications. And this is awesome!</p>\n\n<p>Of course, a software project of any size takes several months to get production-ready. It will grow and the architecture - or better: the lack of architecture - will become a problem at one point. This is when people realize the down-side of the <u>Rails Way</u>. This is when you start visualizing your application as a hairy, growling mountain creature that might attack and eat you if you don't watch out.</p>\n\n<p>I've learned to understand this desire to ship stuff. It is extremely motivating to get something up and running in days. And a nice side effect: you make money faster than your competitors. I've also learned to never give up architecture in trade for shipping. This will always end in the aforementioned disaster. Sustainability is my maxim when writing code.</p>\n\n<p>Now, what am I trying to say? I believe the puristic <u>Rails Way</u> isn't appropriate for projects with a complexity greater than a 5-minute blog. Full stop. I also believe that writing an application with J2E specifications sucks. I don't want to be constantly thinking about types and interfaces and builders and how to wire them together.</p>\n\n<p>Of course, my last statement is a provocative one.</p>\n\n<p>That Rails actually is capable of running real world apps has been proven by thousands of production apps out there. Nevertheless, the question is: what price do we pay for Rails' <u>simplicity</u> in trade for <u>maintainability</u>?</p>\n\n<p>Is it worth writing models with thousands of lines of code and building a throw-away software kludge that is impossible to maintain, just for the sake of development speed? Is it worth blindly hacking away and following the Rails conventions without thinking about whether this is the right place for that code?</p>\n\n<p>On the other hand: is it worth to introduce a high level of framework complexity and to constantly question your code design? Is it worth sacrifying time for a clean, well-design system?</p>\n\n<p>As far as I can see, Trailblazer is the only framework in the Rails world that tries to pursue middle grounds. And this is my learning. Introduce a higher-level architecture than Rails does, but keep it low. And simple.</p>\n\n<p>And the cool thing is: Ruby allows that!</p>\n\n<p>If I decide that it's better to manually validate input of an operation, I can do that instead of using the operation's contract. If my view is simple, I don't need a cell but use a standard Rails view. If view and representer code are identical, I don't need to introduce a twin. Don't confuse this with <q>Omakase</q>, though! Trailblazer has clear rules and patterns for all kinds of problems in Rails, but it offers you a high degree of freedom at the same time.</p>\n\n<p>Dynamic languages require discipline and Trailblazer gently enforces this by offering a few more abstraction layers without taking away Rails' awesomeness<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>RIP, brother. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>Yesssss, I've always wanted to end a book chapter with this expression! <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>Trailblazer is not only a cool name and an architectural style for building your applications, it is also a gem you can install into your application to help you to implement that style!</p>\n\n<p>Unfortunately, it needs a little bit more than just running <code>bundle install</code> to take advantage of Trailblazer.</p>\n\n<p>Of course, architectural styles can't be enforced solely with a Ruby gem. You as the programmer have to adopt patterns in your code from this style and use them throughout your system whereever you feel more encapsulation would be beneficial. Luckily, Trailblazer aims to make this very easy, comprising just a few conventions and classes implementing those patterns, along with this fine book to guide you through the process.</p>\n\n<p>Oh, and did I mention that you are welcome to email me at anytime? Great.</p>\n\n\\n\n\n<p>The real question is: why not Rails?</p>\n\n<p>Actually, that’s a trick question because Trailblazer sits on top of Rails. You're free to use as much <u>Rails Way</u> as you want. So, why do we need Trailblazer? Isn't it a backward step to introduce more technical complexity into this amazing framework?</p>\n\n<p>The answer is: No. Rails needs more abstraction layers.</p>\n\n<p>Over the past years, for whatever odd reasons I became a <q>refactoring expert</q>. A <q>refactoring expert</q>. At least, that's what people think I am. I disagree. <q>Refactoring expert</q>. Say it aloud and try not to laugh.</p>\n\n<p>Companies would hire me to <q>improve</q> their Rails apps on an architectural level. That means that I wasn't supposed to write new features or fix bugs but to re-structure their legacy code into a manageable, extendable architecture. And I loved doing this - and still do!</p>\n\n<p>To make a long story short: in every app, and it didn't matter whether this project was in Berlin or in Munich or in Cape Town or in Sydney, in every project I found the same problems. Problems that get shipped with Rails itself, it seems.</p>\n\n<p>The monolithic design of Rails basically led every application I've worked on into a cryptic code hell. Massive models, controllers with 7 levels of indentation for conditionals. Callbacks, observers and filters getting randomly triggered and changing application state where you don't want it.</p>\n\n<p>Views and helpers lacking any kind of structure, partials with a ridiculous amount of ifs to make them <q>reusable</q>. Tests that basically test if the mocked mocks are mocked properly. If you touch a mailer, you probably break a model in a completely unrelated area, if you ran a migration customers would suddenly get unsuspected emails about their account confirmation, and so on.</p>\n\n<p>Now, please don't tell me your applications are clean and awesome, and everything I just said is wrong. I believe you are awesome and your apps do kick ass (I really do!), because you know what you're doing. However, many Rails developers might not have that level of expertise to judge their design, yet, they need structure and architectural guidance. That is the whole point of a framework.</p>\n\n<p>When it comes to architecture, Rails has its famous <q>MV and C</q>, and that's it. Oh, and, sorry, <q>concerns</q>.</p>\n\n<p><u>Vanilla Rails</u> doesn't give you any kind of high-leveled structure.</p>\n\n<p>The question I hear most from developers is <q>Where do I put this kind of logic?</q>. Eventually, I figured that this is clearly a design flaw in Rails itself and I stopped blaming the other poor developers for all those thousands of emails that had just been sent to all the customers, all because I ran a migration updating some models.</p>\n\n<p>And that brings me to the next problem: third-party gems hook into the same low-level mechanisms as you do. Filters and callbacks are magically added. Simple workflows, like changing a model's attributes, suddenly develop a bizarre life of their own. While this was all made with simplicity for the programmer in mind, the side effects of those hidden semantics can be devastating and ruin your day.</p>\n\n<p>Some charismatic leaders in Rails core dislike encapsulation. The <u>Fear Of The Class</u>, the freedom of a dynamically typed programming language and the strong will to make it different to Java and its <q>over-abstraction</q> has led a generation of developers to unlearn what object-orientation really is about - and neglect this ingenius concept.</p>\n\n<p>I like structure and reasonable encapsulation. And that's what Trailblazer gives you.</p>\n\n\\n\n\n<p>It is a design goal to allow you to step-wise introduce the Trailblazer style into your existing application without having to rewrite the entire thing from scratch.</p>\n\n<p>Play with Trailblazer when implementing the next new requirement in your project. Or give it a go one afternoon and refactor a piece of existing legacy code into a concept. Extract business code and validations into an operation, write tests and watch yourself deleting code from models and controllers. It feels great.</p>\n\n<p>Trailblazer was created while reworking Rails code and does absolutely not require a green field with grazing unicorns and rainbows. It is designed to help you restructuring existing monolithic apps that are out of control.</p>\n\n<p>While Trailblazer was developed mostly in Rails applications, and that is the main focus of this book, the Trailblazer style can be applied to any system design. Its concepts are easily transferable to other languages and frameworks and absolutely not bound to Ruby or Rails. I love Ruby, and the Rails community, that's why I created Trailblazer in this beautiful environment.</p>\n\n<p>Trailblazer's pattern implementations found in the gem itself have zero or very little coupling to Rails. I know of many projects where Trailblazer is is used in other frameworks like Roda, Sinatra or Grape and make more people happy. Oh, excuse me, <q>Sinatra is not a framework</q><sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>.</p>\n\n<p>This loose cohesion makes Trailblazer a, what I call, <q>non intrusive framework</q>. As stated in the README it does not missionize you. You decide where and how much Trailblazer you want and where the Rails Way is sufficient. They don't interfere with each other.</p>\n\n<p>You can also pick which components from Trailblazer you find helpful. Trailblazer is a collection of gems that implement different patterns. It is up to you to judge and remove layers you don't like. The different gems integrate with each other. For example, operations use form objects per default and form objects use representers. That doesn't mean that you <u>have</u> to use all of those gems and patterns, though. Freedom.</p>\n\n\\n\n\n<p>I would like to introduce the architecture and technical aspects of Trailblazer with this incredible diagram I made for you in my sleepless nights.</p>\n\n\n;;;\n\n<p>As you can see Rails' original components are still there, along with new abstraction layers. Here's a brief overview, then we're going to discuss the layers with a bit more detail.</p>\n\n<p>The sleepless nights was a lie. My sleep is excellent.</p>\n\n<p>The diagram is to be understood from top to bottom, where the top represents the incoming request endpoint and the bottom compiles the response.</p>\n\n<ol>\n<li>Controllers become lean HTTP endpoints. They handle authentication (if not handled elsewhere), differentiate between request formats like HTML or JSON and then instantly delegate to the respective operation. No processing logic is to be found in the controller.</li>\n<li>An operation contains all the business logic.</li>\n<li>Every operation validates its input using a form object.</li>\n<li>Models are lean persistence endpoints. No logic but configuration is allowed in model classes.</li>\n<li>Operations and forms can change and persist models.</li>\n<li>Representers can be used to parse incoming documents and to render API representations. Since form objects internally use representers they can be used for that directly without having to specify a representer.</li>\n<li>Controllers can render views or delegate to Cells (a.k.a. View Models) and provide a better abstraction for rendering complex UIs.</li>\n<li>Controllers might also use responders to render responses. Cells and operations can be passed directly into a responder and completely remove the rendering logic from controllers.</li>\n<li>Operations replace test factories, and can be used in scripts and console, too.</li>\n</ol>\n\n<p>Now let's check how this all works together.</p>\n\n\\n\n\n<p>The thing I always mention first about Trailblazer is my favorite one.</p>\n\n<p>Your data models become stupid, empty classes that solely contain persistence configuration.</p>\n\n<p>Experiences from the past decade have taught us that it is a not-so-good idea to push all kinds of business logic into your model layer. With relational mappers like ActiveRecord, this often ends up with huge <q>model</q> classes that contain hundreds of lines of code and ugly conditional configurations to re-use the <q>model</q> in different contexts.</p>\n\n<p>A model in Trailblazer typically looks like this.</p>\n\n\n;;;\n\n<p>Beautiful, isn't it?</p>\n\n<p>It's got something innocent, a model without business logic, no callbacks and no validations. <u><q>Where are the validations and all that?</q></u> you might wonder now, a drip of sweat running down your panicking face. Relax, it's all still there, but not in the model anymore.</p>\n\n<p>In Trailblazer, the model class becomes the place for persistence, only, making the model a low-level <u>data object</u> with a very simple set of functions: Retrieving and writing data to a database.</p>\n\n<p>Yes, I know the term <a href=\"http://www.martinfowler.com/eaaCatalog/activeRecord.html\">ActiveRecord</a> originally does include <q>domain logic</q>.</p>\n\n<blockquote>\n<p><u>An object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.</u></p>\n</blockquote>\n\n<p>I doubt that the author's intention was to legitimise the creation of monstrous super objects that basically do everything, though. Martin's examples limit the <q>domain logic</q> to query methods.</p>\n\n<p>And this is exactly how models are handled in Trailblazer. You can use query methods and scopes to retrieve objects. You can use models to write or update rows. And nothing more. This is the lesson learned from Rails and its monolithic <q>fat model</q> approach.</p>\n\n<p>While this might seem confusing it has proven to be an extremely powerful and clean approach - and I've spoken to quite a few people who have a similar design without Trailblazer. The logicless model is nothing new.</p>\n\n<p>What I love about it is the fact that I still use all of the ORM's awesomeness: I admire how ActiveRecord takes away the pain of SQL, joining tables, escaping queries, and so on. That means I use finder methods, <code>where</code>, scopes and what not to deal with the database - I just don't put any specific business logic into my models.</p>\n\n<p>Of course, you are not limited to ActiveRecord but may use any mapper library you fancy, whether that is DataMapper, Mongoid or NoBrainer, the framework does not care.</p>\n\n<p>The business logic for both reading and writing along with validations is abstracted into new layers: Operation, Form and Twin are patterns that Trailblazer brings to your architecture.</p>\n\n<p>Let me now briefly outline those <q>patterns</q>.</p>\n\n\\n\n\n<p>Rails organizes the implementation of your domain into models, controllers and views.</p>\n\n<p>For example, to create a comment via a web page, this will usually be triggered in a controller. The controller then invokes one or several methods on models. After processing, a view is rendered.</p>\n\n\n;;;\n\n<p>Even though this code belongs into the same logical group - <u><q>Create a comment!</q></u> - the actual code files are spread into different directories and separated by technology.</p>\n\n<p>I found it hard sometimes to navigate in Rails apps, you keep flicking through a million directories and it makes me cry when I decide to rename a model as I also have to rename at least one more directory and several files. Extracting or removing a model and its friends is the same story - it feels wrong.</p>\n\n<p>In Trailblazer, you structure your app by domain into real components. I call them <u>concepts</u>. You implement a concept for every entity in your high-level domain. That means you have comment, profile, thing, feed, or a dashboard concept.</p>\n\n\n;;;\n\n<p>Those concepts sit in <code>app/concepts</code> in their own directory. All classes and views belonging to that concept, forms, operations, and so on, are in that very directory.</p>\n\n<p>Assuming that we're both talking about the same component I can say <q>the index view</q> and <q>the notification cell</q>. You will know exactly where to look.</p>\n\n<p>Personally, I find this new file structure way more intuitive and it makes it easy to see the complexity of a concept with a simple glance into its directory. If there are too many files floating around in a single concept, it might be time to split it up or extract functionality to a separate concept.</p>\n\n<p>Also, this emphasizes the component character of a concept. By having a group of files in one directory you can remove, reuse or temporarily disable an entire component with one click. In case you need a finer leveling, concepts can be nested into concepts, too.</p>\n\n\\n\n\n<p>Now let's get to the fun part: code!</p>\n\n<p>Trailblazer's approach here is to decouple your actual application code from the underlying framework without sacrificing all the Rails goodies. By encapsulating your business, tasks like updating Rails itself, writing isolated tests or replacing entire components become less painful.</p>\n\n<p>I'll start from the top.</p>\n\n<p>Using a web application means you send requests, that queries or changes application state, then you get a response. The browser hides that from you, but behind the scenes this is exactly what happens. I want you to think of every <u>function</u> of a web application as a request-response cycle. It's not relevant if that request is triggered by clicking a <q>Create</q> button, or if it comes from an AJAX request or some sophisticated JavaScript logic.</p>\n\n<p>Fact is, you operate your application by triggering requests.</p>\n\n<p>As an example, this could be the following typical session.</p>\n\n<ul>\n<li>Visit the Trailblazer page and read the summary.</li>\n<li>Write a comment using the page's form and submit it.</li>\n<li>Click the <q>Follow Trailblazer</q> button as you're interested in the further discussion.</li>\n<li>Go to your dashboard and see new comments for <q>Trailblazer</q>.</li>\n</ul>\n\n<p>These are four <u>functions</u> of the application, and they are all triggered with a separate request.</p>\n\n\n;;;\n\n<p>It doesn't matter what happens behind the scenes - those four functions somehow need to be implemented on the server-side. The <q>functions</q> are what I call the <u>High-level Domain</u> in Trailblazer.</p>\n\n<p>In Domain-Driven Design (DDD), this is called a <u>Use Case</u>. In CQRS, this kind of <q>function</q> is called <u>Command</u>. This is your public API you're presenting to the user of your application.</p>\n\n<p>Often, very often, high-level domain functions can be invoked via the web UI, via a document-based HTTP API, e.g. by exposing JSON-consuming and rendering endpoints, and sometimes, very rarely in Rails, you can trigger the exact same function by invoking a method on a model.</p>\n\n<p>While Rails does provide a high-level domain in the form of controller endpoints, the implementation thereof is fuzzy. Is it implemented in the controller? Or the model? Or a service object and the controller?</p>\n\n<p>You might think that code to create a comment all sits in one place, e.g. the model, but this is wrong. Code that logically belongs together is partly located in the controller, partly in the model. The high-level domain is not encapsulated in an atomic object, but distributed over several layers.</p>\n\n<p>For example, the following snippet is code you will find in many Rails controllers.</p>\n\n\n;;;\n\n<p>Or, another misleading example for implementing a high-level domain function. This is actually from Rails' documentation.</p>\n\n\n;;;\n\n<p>In both snippets, the controller clearly contains business logic. Even if that's just assigning the current user, or invoking a builder on a model - this is code that is part of your domain, and not related to HTTP in any way.</p>\n\n<p>It's impossible to replicate the above behavior somewhere else without replicating the controller code itself.</p>\n\n<p>Keep in mind that once we hit the model further logic is triggered as in validations and callbacks. Speaking of validations, this is when controllers really start to get messy.</p>\n\n\n;;;\n\n<p>Again, the controller gets stuffed with knowledge about model internals. Why is a HTTP endpoint aware of projects and tasks, their relationship to each other and their validity constraints? There is no way to re-use this function without duplication.</p>\n\n<p>Going through the controller you will find more places where business code is implemented - in the wrong place. Other examples are the usage of <code>strong_parameters</code> where the controller suddenly knows which attributes go to which model, and so on. Or, my favorite, when <code>before_filter</code>s contain additional model validation logic that should clearly sit somewhere else.</p>\n\n\\n\n\n<p>In Trailblazer, the implementation of a high-level function goes into an <u>Operation</u>. Surprisingly, this is a class!</p>\n\n<p>Maybe it's easiest to think of an operation as <q>everything that happens in a request after the HTTP overhead is sorted</q>. Or in other words: the controller only knows about the HTTP layer. Business is immediately dispatched to the operation.</p>\n\n<p>This underlines how each operation embraces a complete action (or <u>function</u>) of your public domain.</p>\n\n<p>Without even understanding internals of this new concept have a look at how controllers typically end up in Trailblazer.</p>\n\n\n;;;\n\n<p>No business logic in controllers and an immediate dispatch to the target operation are fundamental concepts of Trailblazer. We will soon learn that the messy code is not just put away into another module but restructured into different layers of Trailblazer.</p>\n\n<p>An operation class exposes a single public method, per default. I know, you might think this is clumsy and backward, but throughout this book we're gonna work a lot with operations and I think I will manage to demonstrate why I love this functional feature and the simplicity of an operation.</p>\n\n\n;;;\n\n<p>Operations usually get implemented in their concept's namespace. Here, the create code gets encapsulated into a separate class and namespaced into <code>Comment::Create</code>, making it pretty obvious what is the classes' responsibility.</p>\n\n<p>Note that putting classes into classes is simply namespacing and doesn't involve inheritance or any sort of coupling.</p>\n\n<p>An operation always has to implement one method: <code>#process</code>. This is where the implementation of that use case sits.</p>\n\n<p>Usually, you'd invoke an operation using the <u>call style</u>.</p>\n\n\n;;;\n\n<p>And here we are, this is our high-level <u>entry point</u> for creating a comment!</p>\n\n<p>That being said, the controller really boils down to dispatching to <q>its</q> operation.</p>\n\n\n;;;\n\n<p>Now, wait! That's only half of it. An operation can also be used from the console or as a test factories.</p>\n\n\n;;;\n\n<p>An operation provides a single entry point for domain functions: There's only one way to create a comment and that is the operation - unless you provide additional operations to do so.</p>\n\n<p>This is a good thing. Conventional factories in tests create redundant code that never produces the exact same application state as in production - a source of many bugs. While the tests might run fine production crashes because production doesn't use factories. In Trailblazer factories get superseded by using operations.</p>\n\n<p>Operations can easily be subclassed and extended, for example, to parse or <q>understand</q> a JSON string instead of a hash.</p>\n\n\n;;;\n\n<p>Without going too much into the details: An operation doesn't just blindly traverse through a deserialized JSON hash. It knows about the document structure and semantics because you configured it. We'll come to this very shortly.</p>\n\n<h3>An Operation is a Service Object</h3>\n\n<p>Those specific concepts and behavior of operations are pretty unique to Traiblazer, I haven't seen this anywhere else. However, the idea of encapsulating code from controller and model into a service layer is old.</p>\n\n<p>An operation is pretty similar to a <q>service object</q>.</p>\n\n<p>The Ruby community is becoming obsessed with service objects - a result of Rails' lack of a defined layer for domain logic. People now start to extract code into separate <q>service objects</q>, whenever you ask someone where to put this or that code the answer is gonna be <u><q>Use a service object!</q></u>.</p>\n\n<p>Especially for unexperienced developers this advise is not helpful at all. It might end up with a set of different <q>service objects</q> implementations in one app, varying interfaces and concepts being applied. This defeats the purpose of Rails' conventions, which are said to make it easy for fresh developers to understand new projects.</p>\n\n<p>Instead of leaving it up to the programmer how to design their <q>service object</q>, what interface to expose, how to structure the services, Trailblazer's <code>Operation</code> gives you a well-defined abstraction layer for all kinds of business logic. Its implementation is incredibly simple but it is offers a bunch of neat features that implement a lot of best practices I've found handy in the last years.</p>\n\n<h3>Business Logic</h3>\n\n<p>Once you map your high-level endpoint to an operation, all kinds of business logic will go into this class, or into nested operations.</p>\n\n<p>This is not limited to classy CRUD code. An operation can implement all kinds of public API, such as following a user, cropping an avatar image, retrieving a list of comments for a search term, and so on.</p>\n\n<p>Even though this happens explicitely in a separate class per function, you don't have to code everything yourself. Trailblazer comes with many helpful modules to extend operations so you don't need to do all the work. For example, creating or finding models is implemented in the <code>Model</code> module. I am not going to use any of those helpers for now to give you a clear image of what is the point of <code>Operation</code>. We'll come to those features later in the book.</p>\n\n<p>You may run any logic you want in your <code>#process</code> method - Trailblazer doesn't impose any limitations. It guides you, but you're still free.</p>\n\n\n;;;\n\n<p>Here, it becomes obvious that each operation maps to one CRUD action (and more). Well, admittedly just calling the <code>create</code> method in a clumsy operation doesn't really convince me to model my business code with this new structure. The real power of operations comes with the validation, processing and post-processing of the data, and Trailblazer structures this workflow in a pipelined fashion.</p>\n\n\\n\n\n<p>Again, everything that happens between the interception of the request by the endpoint, and the delivery of the rendered result, in Trailblazer is business logic and embraced by one operation.</p>\n\n<p>The operation here acts as an <u>orchestrator</u> dispatching between the different layers of Trailblazer. The layers are all separate objects that have no idea about the context they're being used in, or what an operation is.</p>\n\n<p>Often, the operation is criticized as a <u>God Object</u>, but those people confuse <u>implementation</u> and <u>orchestration</u>. Somewhere in your code, regardless of whether this is a set of Elixir functions or a super object-oriented Ruby system, somewhere you have to dispatch the actual steps to process the request and run your business logic.</p>\n\n\n;;;\n\n<p>And in Trailblazer, this is the operation. The operation doesn't know about implementation-specifics, only where and how to invoke the responsible objects.</p>\n\n<p>Since we all do appreciate diagrams, here's a typical web workflow schematized.</p>\n\n<p>In Trailblazer, we chunk the processing of a request into deserialization, validation, persistence, processing and post-processing and presentation. Each step maps to a dedicated layer in the operation and is implemented using one or more self-contained objects.</p>\n\n<ol>\n<li>\n<strong>Deserialization</strong> means transforming the incoming request data into an object graph. This happens with a representer.</li>\n<li>\n<strong>Validation</strong> we call the process of verifying this object graph is in valid state. Validation's done by the form object. In Trailblazer, we often say <u>contract</u> instead of <u>form</u>.</li>\n<li>\n<strong>Persistence</strong> will write the application state from the object graph to the database. Usually, this happens by syncing the graph to models.</li>\n<li>\n<strong>Post-processing</strong> is what happens before and after data gets persisted. In operations, you have callback objects that can be invoked to run additional logic.</li>\n<li>\n<strong>Presentation</strong> is not directly the operation's responsibility. However, operations can assist rendering a JSON document using a representer, or by providing data to view models.</li>\n<li>\n<strong>Authorization</strong> realistically is a task orthogonal to this flow stack and can happen at any point leveraging policy objects.</li>\n</ol>\n\n<p>Structuring and implementing the typical requirements of a web request in Trailblazer is called <u>High-level Architecture</u> and is the missing piece of frameworks like Rails. Without a high-level architecture, developers often complain about missing structure in their code and problems that arise from lack of encapsulation.</p>\n\n\\n\n\n<p>When writing Trailblazer I didn't really know about the role of <code>Operation</code> and if it's worth introducing. This was until I combined it with a form object. Guarding your business logic with a validation simply makes sense and feels very natural.</p>\n\n<p>Another free feature is that the contract can be used for deserializing (and serializing) incoming documents, e.g. for a JSON endpoint. Let me come to this later, but keep in mind that a contract is a <u>schema</u> of the data structure.</p>\n\n<p>An operations lets you define a form object, or <u>contract</u>. Internally, this simply creates a <a href=\"https://github.com/apotonick/reform\">Reform</a> form class. If you've used this gem before, you will recognize the API.</p>\n\n\n;;;\n\n<p>This is pretty straight-forward, isn't it? In the contract block you can define properties of your form and their validations. If your form is more complex and needs to validate, create or update compositions of models you might define nested properties and populators.</p>\n\n<p>Likewise, since Reform uses <code>ActiveModel::Validations</code>, you can use all kinds of standard validations like length or inclusion. Specific logic e.g. to validate multiple parameters can be achieved using the good ol' <code>::validate</code>.</p>\n\n<p>Ok. Fine. We got a class that is supposed to contain our business logic. This <q>operation</q> has a form object that defines the incoming document structure and specifies validations to assert a valid application state. Now, how does this all play together?</p>\n\n<p>As soon as you define a contract for an operation you can use it for deserializing the incoming parameters and validate the object graph that was created. This sounds crazy but is extremely simple. Check out the <code>#process</code> method now.</p>\n\n\n;;;\n\n<p>The operation gives you the <code>#validate</code> method to take advantage of your contract. This is a totally optional feature: you don't have to use a contract and the validation if you don't need it.</p>\n\n<p>Again, the <u>contract</u> is simply a Reform object. Bear with me, I'm gonna talk about Reform in detail throughout this book. For now, let's focus on what <code>#validate</code> does internally.</p>\n\n<ol>\n<li>The operation instantiates a contract and passes its <code>@model</code> to it. In our case that's the <code>Comment</code> model. We will soon learn why the form wants to wrap a model.</li>\n<li>\n<p>It then instructs the freshly created form to validate the params hash.</p>\n\n<p>It is absolutely mission-critical to understand that this step does <u>not</u> touch the model at all. Validation will only operate on the form instance. And this is different to Rails: Validations in ActiveRecord happen on the model itself. Reform cleanly separates that and embraces the entire validation workflow in the form object.</p>\n</li>\n<li><p>If the validation was successful without errors, the block passed to <code>#validate</code> is run. This is where you put your business logic for processing the form.</p></li>\n<li><p>If the input was invalid, the block is <u>not</u> run.</p></li>\n</ol>\n\n<p>And that's basically it.</p>\n\n<p>I find it important to mention how <code>strong_parameters</code> becomes obsolete using operations and forms. The <code>#validate</code> method knows which parameters of the hash go into the form and what is to be ignored.</p>\n\n<p>How does it know that? Well, you configured the form's fields and validations in the <code>::contract</code> block! The contract just needs to pick the keys it wants from params. Explicitly defining structures instead of guessing is a cornerstone of this framework - and will help us a lot in our quest to a cleaner architecture.</p>\n\n<h3>Processing Data</h3>\n\n<p>Let's see how a real <code>#process</code> method looks like in order to discuss the data processing steps.</p>\n\n<p>Again, this is a bare-bones operation without using any of <code>Operation</code>'s built-in functions to ease your life. Even though it might look un-appealing to you, I do this on purpose. This section is not a show-off of how much less code or how much more readable structure this pattern gives you - I want you to understand what is going on on the fundamental level. Then we can move on to abstractions.</p>\n\n\n;;;\n\n<p>In case of a successful validation, what we're all really hoping for, the logic in the block gets executed. In my simple example, two things are happening.</p>\n\n<p>The <code>#validate</code> method yields the contract instance to the block. This is helpful to access the validated data. As we're gonna discover in the next chapters, the Reform contract comes with a handful of public API methods. One of them is <code>#save</code>.</p>\n\n<p>All this invocation does is push changed values from the form to the <code>Comment</code> model (this is called <u>syncing</u> in Reform). Afterwards it calls <code>#save</code> on the model itself, and thereby persists the validated changes from the form. This is what usually happens in <code>Comment.create(..)</code> or <code>update_attributes</code> call when using models directly in controllers.</p>\n\n<p>While letting the form take care of persisting the data here it is fully up to you how you work with the database layer and the models. In later chapters we're gonna go through other ways how to store models in the database, by-passing the form object's save semantics.</p>\n\n<p>After persisting the model, I run arbitrary code which is similar to <code>:after_create</code> hooks in ActiveRecord. I just outlined this by calling <code>notify!</code> and <code>log!</code> so it becomes obvious that you can do whatever you want. The operation provides you access to the model and the contract.</p>\n\n<p>This is where you'd also expire page caches, send out emails or invoke further business logic. This doesn't have to be hand-coded in this very operation but can be delegated to other classes, nested operations, or callback objects as we're gonna discover in chapter 8.</p>\n\n<p>Operations provide a clean way to group callbacks. Instead of adding ActiveRecord callbacks with conditionals you explicitely invoke the hooks in your operation class. In Rails, this is often done with ugly <code>:unless</code> or <code>if:</code> lambdas and the like. You never know whether or not a callback gets triggered when saving an object. This creates fear. In Trailblazer, you ideally expose a new operation if you decide you need the same behavior without any <q>callbacks</q>. Trailblazer offers some nice techniques to derive operations with inheritance.</p>\n\n<p>This code is very explicit. Some might call it verbose, because <q>in Rails, this is one line</q>. Well, this might be true in some rare cases. However, we haven't looked into <code>Operation</code>'s beautiful add-ons, yet, that can abstract most of this code. Even in Rails you still need to define validations (probably with conditionals) and callbacks. These callbacks are then later gonna shoot you in the foot.</p>\n\n<p>Have you ever tried to change what happens <u>in</u> your <q>Rails one-liner</q>? Exactly, mission impossible. It requires a shocking amount of patience to step through ActiveRecord's magic of deserialisation, validation, callbacks and persistence logic all happening in one class.</p>\n\n<p>The goal of the <u>Operation - Contract - Model</u> design is to separate concerns. This does not only make it easier to follow the flow of your logic it also maximizes reusability. You can reuse massive parts of the operation for other domain actions like updating a comment, to process differing formats like JSON and also reuse the operation in other contexts, for instance in an admin backend.</p>\n\n\\n\n\n<p>In a perfect CRUD world, create and update semantics are identical. They consume the exact same set of attributes.</p>\n\n<p>There's no borders - users and admins share the same rights and privileges, you simply re-use forms and validations for both the frontend and the admin interface.</p>\n\n<p>You also don't need configuration for different request formats. You simply pass the <code>params</code> hash into your model's <code>create</code> or <code>update</code> method without even having to worry about who or where this JSON request or a form submission was magically deserialized into a hash.</p>\n\n<p>Your HTTP API works identical to your forms, the incoming JSON document and the serialized form have the same structure, you can even pass a self-made hash to the <code>create</code> method, everything works automatically, everything is great.</p>\n\n<p>In your dreams.</p>\n\n<p>What really happens is: Your update action requires a sub-set of the create parameters. Your JSON API consumes completely different documents that do not have much in common with your form submission hash, and the form needs different fields for processing than the manual hash you use in the console.</p>\n\n<p>A form to create a comment in the user's UI has a set of fields and validations that has almost nothing in common with the way an admin can post and edit comments. You realize how many different contexts you have for one model and get frustrated.</p>\n\n<hr>\n\n<p>Trailblazer was designed with differing endpoints in mind. Where the <q>Rails Way</q> offers a baffling amount of tools to solve this problem in the controller with ifs and else and strong<u>parameters and `before</u>filter`s and responders and variants and format deciders and additional logic and configuration in the models, Trailblazer copes with this using a completely different approach.</p>\n\n<p>Per context you can maintain a sub-class of the original operation. A context might be a document request format as JSON, a follow-up action like <code>Update</code> or a differing environment, for example the admin backend. Ideally, in the above mentioned dream-world, you'd handle this with one and the same operation class in every context.</p>\n\n<p>However, when things get dirty - and software engineering is dirty - when different formats need different flows, structures and semantics, you have a sub-class to deal with that, without interfering with the other format operations and without any ifs and elses in your control flow.</p>\n\n<p>The explicit nature of Trailblazer might seem clumsy at first glance. Nevertheless, when dealing with different contexts, you will feel the power and ease of real object-orientation.</p>\n\n<p>Subclassed operations will inherit behavior, the contract and representer.</p>\n\n\n;;;\n\n<p>Often, it is sufficient to simply subclass. I prefer a two- or three-liner over implicit semantics, however, note that this can happen automatically, so you don't have to write a single line of code.</p>\n\n<p>After inheriting you're free to change, override or rewrite contracts, business logic and representers. Besides Ruby's built-in object-orientation, Trailblazer offers you some helpful ways to tweak operations and contracts.</p>\n\n\n;;;\n\n<p>An update is never identical to a create. And Trailblazer makes it as simple as possible to map these requirements to code - using clean polymorphic classes without conditionals.</p>\n\n<p>Especially when extending operations to handle JSON inheritance becomes a powerful tool you're gonna love.</p>\n\n\n;;;\n\n<p>The explicit code makes it straight-forward to understand what behaviour is changed in format-specific operations and contracts, here for a JSON request.</p>\n\n<p>And this is because Trailblazer is designed to handle polymorphic domain logic, this is not just another <q>quick</q> feature you push into the existing codebase using if/else and the like, as I have found it in many vanilla Rails projects.</p>\n\n\\n\n\n<p>Instantiating sub-operations, forms and cells according to the environment is built into Trailblazer - you define when to create which object and the framework will take care of the rest. This is extremely helpful to keep your controllers clean while still allowing access to all your subclasses explicitly, for example when working from the command line.</p>\n\n<p>The trick with builders is that the caller doesn't know about the polymorphic semantics of the operation - polymorphism in OOP was introduced to hide internals like that.</p>\n\n\n;;;\n\n<p>Here, the controller simply invokes the top operation. Now what if we need to distinguish between creating a normal comment and a moderated comment? You'd implement that with an operation <code>Comment::Create</code> and then inherit and extend in <code>Comment::Create::Moderated</code>. The latter would send out additional notifications for moderators, and so on.</p>\n\n<p>I don't want my controller to know about all that. Where the controller dispatches to <code>Create</code> the operation class itself takes control of building its concrete instance.</p>\n\n<p>How does the operation know which subclass to instantiate? You configure it using the builder API.</p>\n\n\n;;;\n\n<p>This will create different instances for different environments: The operation will run the builder block to figure out which concrete class is appropriate to handle the environment. Note that the params hash needs to contain all necessary data to figure that out! This is the only requirement to the caller - which usually is the controller.</p>\n\n\n;;;\n\n<p>Keeping that knowledge in the operation and out of the caller environment like the controller allows to use your domain virtually everywhere without having to replicate logic.</p>\n\n<p>The builder feature is a fundamental concept found in all layers of Trailblazer. I started experimenting with it in Cells where it allows to render polymorphic widgets and collections without magic - and got positively surprised by the level of acceptance in the community.</p>\n\n\\n\n\n<p>Another critical requirement that Rails completely leaves up to the developer is that every application needs authorization for different actions. Different users have different permissions. I don't want everyone to screw with my profile or to post comments in my name. There's no dedicated place for this in Rails, every application has a slightly different approach.</p>\n\n<p>This logic usually ends up in as a mix of <code>before_filter</code>s in controllers and conditionals in model methods. It's not only hard to follow what is going on, also does it create redundant code. Neither the HTTP layer nor my database is the place to put authorization into. The lack of a permission system is a grave design flaw in Rails resulting from the core team's resistance to introduce new abstraction layers.</p>\n\n<p>In fact, authorizing actions for differing environments is an essential part of your system requirements. This cannot just be handled in controller filters. Authorization needs knowledge about the domain and access to the environment. In other words: it needs to be integrated into your business.</p>\n\n<p>Trailblazer offers you to sort authorization as part of an operation, taking this logic back to where it should be: your domain layer.</p>\n\n<p>The simplest place for permission handling is in builders. The benefit here is that the created class doesn't need to know anything about rules and can perform its task without looking back. Permissions are computed in the builder and then the permission is granted by creating subclassed operations with differing behavior.</p>\n\n\n;;;\n\n<p>Right, I use ifs and else here - this is builder code and all decisions are made in one place. In fact, builders are the only place where deciders of that level should be tolerated.</p>\n\n<p>Just like the operation, the preceding builder has access to the params passed into the operation call. It's up to you what authorization framework you use here. Use cancancan, rolify, pundit, or write your own, everything is allowed (or denied). While we build our app in this book, we will use pundit-style authorization.</p>\n\n<p>By building different sub-operations we implicitly give out permissions. The sub-operation is decoupled from the authorization process which makes it simply to bypass the permissions: by calling the sub-operation directly the builders are ignored.</p>\n\n\n;;;\n\n<p>This is extremely helpful for console work, scripts or tests.</p>\n\n<p>Another way to let an operation do the permission work is using a <u>policy</u> block in your operation. As you might have guessed already a policy block will skip the operation if it evaluates to false. Of course, builders and policies can be combined if you need that fine level of permissions.</p>\n\n\n;;;\n\n<p>The policy block is run after the setup of the operation but before the processing, allowing you to access the model and other objects from setup.</p>\n\n<p>I like to stress how you may use permission gems as much as you please. Trailblazer does not try to replace all the excellent gems but provides a structural location to call them.</p>\n\n\\n\n\n<p>Signing in users and distributing cookies to authenticate them in subsequent request is not handled in Trailblazer itself. This task is mostly coupled to HTTP and thus happening in controllers.</p>\n\n<p>You're free to use <a href=\"https://github.com/plataformatec/devise\">Devise</a>, however, don't hit me up if things suddenly go wrong and you don't know where to look. Devise is incredibly hard-wired into Rails itself and I find it surprising that it is not officially part of core like strong_parameters or turbolinks.</p>\n\n<p>The developers of this gem absolutely deserve respect for their work - Devise covers an astonishing range of features and makes signup, signin, password maintenance and confirmation mails a no-brainer as long as you don't try to change anything.</p>\n\n<p>The way Devise hooks into models, controllers, routes and views makes it a bit unattractive, in my opinion. I would prefer if devise had a decoupled core engine with additional Rails bindings. When in recent devise versions it turned out that the only way the get the confirmation token for the signup mail is via a global view instance variable <code>@token</code> I knew it's time to look for an alternative.</p>\n\n<p>And this is why we will use an extended version of <a href=\"https://github.com/apotonick/tyrant\">Tyrant</a> in this book to authenticate users and cookie managment.</p>\n\n\n;;;\n\n<p>Tyrant itself is built using Trailblazer operations, and in chapter 9 we will learn how to use this decoupled gem for authentication.</p>\n\n<hr>\n\n<p>So far we covered how an operation replaces most of the controller logic. It validates incoming data using a form object and then processes the sane data. Now, I want to show you how an operation can be used on the other side, the presentation, e.g. to render its form in a view.</p>\n\n<h3>Working With API Documents</h3>\n\n<p>In most Rails applications, controller actions act as endpoints for HTTP APIs, too. Usually they render and consume documents of a certain format, e.g. JSON or XML. Rails comes with several rendering engines to compile JSON formats.</p>\n\n<p>To name some, there's the built-in and loathsome <code>Object#to_json</code> method that creates generic representations, <a href=\"https://github.com/rails/jbuilder\">jbuilder</a>, <a href=\"https://github.com/nesquena/rabl\">rabl</a> or <a href=\"https://github.com/rails-api/active_model_serializers\">ActiveModel::Serializer</a>.</p>\n\n<p>Those are all excellent gems that do a great job rendering documents. However, they are all one-way template engines, nothing more. What is completely ignored in the vanilla stack is how to handle POST, PUT and PATCH requests that actually change application state by parsing and processing documents.</p>\n\n<p>Unfortunately, there is no consuming layer in Rails. Parsing the document happens automatically somewhere in a Rack middleware. Unless you're using <code>accepts_nested_attributes</code> (I don't hope so) you're completely left alone to populate objects from the parsed hash.</p>\n\n<p>You still have to process incoming documents yourself and populate objects manually by crawling through deeply-nested hashes and many <code>if</code>s. This is not a pleasant task, and in my opinion, it's wrong, as you distribute your document syntax and semantics over the entire stack. If a key in the document changes, you need to fix it in the template or the serializer <u>and</u> in your parsing code.</p>\n\n<p>Again, Trailblazer handles this with a different approach. I hope you're not getting tired of this.</p>\n\n\\n\n\n<p>Rendering and parsing documents in Trailblazer happens with the help of representers - another pattern you're gonna use a lot in this book.</p>\n\n<p>Representers in Trailblazer come from the <a href=\"https://github.com/apotonick/representable\">Representable</a> gem.</p>\n\n<p>Maybe it will help to actually show you how representers look like and work? I promise it won't take long as they're really simple.</p>\n\n\n;;;\n\n<p>That looks pretty much like a form without validations, right? And the truth is: a form is nothing more but a representer with some data transformation logic and validations!</p>\n\n<p>You can then render documents.</p>\n\n\n;;;\n\n<p>When rendering, the representer will follow the document structure you defined and compile a document that can be nested, contain collections, hypermedia, whatever you fancy. Even better, representers can also handle XML and YAML in case you want to be the first person alive exposing a YAML-Hypermedia API.</p>\n\n<p>Representers would be lame if that's it. They can also do the same the other way round and parse documents back to objects.</p>\n\n\n;;;\n\n<p>This will populate the <code>comment</code> instance with new attribute values from the document, deserialize nested objects, instantiate or build new objects, and so on. We'll learn everything about representers in chapters 11 and 12.</p>\n\n<p>The crucial thing about representers is that they maintain any kind of knowledge about the document in one place. While rendering documents is provided with fantastic implementations, Rails underestimates the complexity of deserializing documents manually. Many developers got burned when <q>quickly populating</q> a resource model from a hash. Representers make you think in documents, objects, and their transformations - which is what APIs are all about.</p>\n\n\\n\n\n<p>Skipping the details I want to jump right into how we can use all this. Let's extend the <code>Comment::Create</code> operation to render JSON. Extending to handle new formats is implemented in a subclass, per convention.</p>\n\n\n;;;\n\n<p>This creates a subclass <code>Create::JSON</code> that is responsible for building new comments using JSON. It also inherits the contract. Now, the most generic use-case in a controller is parsing an incoming JSON document, creating a comment, and then rendering a JSON representation of the fresh comment. This could work as follows.</p>\n\n\n;;;\n\n<p>This minimal code will automatically instantiate the <code>Comment::Create::JSON</code> subclass for JSON requests and run it. The operation then deserializes the document using the representer from the contract, runs the business logic and then gets passed to <code>#respond_to</code>.</p>\n\n<p>Now, it's back to the controller to invoke rendering and handle the HTTP response. The responder typically calls <code>#to_json</code> on the operation which was passed into it. The operation will use its representer to serialize a document, and the controller simply uses this for the response.</p>\n\n<p>This keeps the controller free of any business logic. The operation in turn delegates rendering to the representer staying free of any representing code. Note that you don't change anything for the business logic. If you need to, you can override the <code>#process</code> method.</p>\n\n<p>Naturally, the form's structure won't exactly match your JSON document. No big deal, an operation makes it really easy to extend or completely override the representer.</p>\n\n\n;;;\n\n<p>You can customize the operation's representer using the <code>::representer</code> block. Just like the <code>::contract</code> method internally creates a Reform form, this simply works on a <code>Representable::Decorator</code> class that is generated for you from the operation.</p>\n\n\\n\n\n<p>Representers are designed to implement object-oriented documents for REST APIs. This implies a strong focus on embedding and consuming hypermedia in the documents. And luckily, we can use the <a href=\"https://github.com/apotonick/roar\">Roar</a> gem which extends Representable and makes using hypermedia a pleasure for creatures great and small.</p>\n\n<p>In chapter 11 and 12 we will dive into building hypermedia APIs with Roar and Trailblazer. As an appetizer here's an example how simple it is to render and parse HAL-JSON compliant documents with Ruby objects.</p>\n\n\n;;;\n\n<p>The rendered JSON document representing the comment will now include a <code>self</code> link following the HAL-JSON standard. Of course, the <code>HAL</code> module comes with plenty of more features to support rendering and parsing HAL documents.</p>\n\n<p>If you decide that JSON-API is more suitable for you as you're maintaining an Ember.js frontend you can do so.</p>\n\n\n;;;\n\n<p>Roar supports HAL and JSON-API media formats out-of-the-box, including hypermedia, embedded resources (called <u>compound</u> in JSON-API) and link templates. It took a while for the community to realize that Roar is more than a template gem that renders documents. People now appreciate Roar's ability to also deserialize documents back into objects using the same definition schema.</p>\n\n<p>Processing HTTP APIs using Trailblazer's representer pattern is a very joyful experience as we will see in later chapters. Often, the integration with forms and controllers allows it to implement a full-blown API with very little code. And Representable and Roar have some nice features to make deserializing complex object graphs as painless as possible.</p>\n\n\\n\n\n<p>Now after all this backend talk I want to become human again and speak about the visual user interface side of Rails. This is how Rails got big back then.</p>\n\n<p>View <u>helpers</u> make it incredibly simple to put up complex forms, links or display images without having to fight with markup and HTML specifications. I find the implementation of helpers in Rails questionable but I love how form helpers make my life easier - they actually <u>help</u>.</p>\n\n<p>Unfortunately, the view layer in Rails is one of the most neglected components in this framework. It's surprising, and not in a good way, that it actually takes five major Rails versions to finally decide to <q>refactor ActionView</q>. Since its inception in 2005 the Rails view layer hasn't changed a single bit from an architectural perspective.</p>\n\n<p>It provides parsing templates and substituting placeholders via controller instance variables and locals. Helpers are global functions (not methods) you can use to <q>encapsulate</q> behavior in your template. ActionView also allows rendering partials, again, to <q>encapsulate</q> template markup and make it reusable. The entire rendering process is run in one instance, every helper and partial can <u>and does</u> access global state.</p>\n\n<p>Frankly, I can't see any difference to PHP scripts here. What I totally <u>can</u> see is how this is sufficient and efficient for simple pages. Everyone instantly grasps how to push data into the views and arrange it nicely. That's why Trailblazer still allows you to work with controller views.</p>\n\n<p>Controller actions can invoke <code>#render</code> the way you know it from Rails. Earlier we learned that we can use the form object from an operation in views and present HTML forms. Operation also provides you the model and the operation instance itself if you need it.</p>\n\n\n;;;\n\n<p>Here it is... good old Rails view rendering. Running the operation will yield the instance to the block which is only executed for a successful validation. The <code>#run</code> call also assigns <code>@model</code> and <code>@operation</code> instance variables in case you need them in your view.</p>\n\n<p>That means you don't even need to rewrite your views when replacing controller/model logic with Trailblazer's operation.</p>\n\n<p>Nevertheless, controller views should be handled with care. There is a great temptation to quickly add this and that instance variable and render another partial in another partial. Soon you lose track of the dependencies between views and the controller - because there <u>is</u> no interface for views and absolutely no encapsulation.</p>\n\n\\n\n\n<p>Out of my very early frustration with the Rails view layer emerged the <a href=\"https://github.com/apotonick/cells\">Cells</a> gem. Cells provides proper object-oriented encapsulation for views. It has moved on a long time ago and we no longer use ActionView in the 4.0 release which makes me sad and happy at the same time.</p>\n\n<p>Sad because we were constantly attempting to improve ActionView with the learnings from Cells but no one in core was really interested. Happy because removing this jurassic dependency has sped up the rendering several times and minimized logic to a few dozens lines of code.</p>\n\n<p>Cells let you implement parts or blocks of your UI in a separate component, like a separated mini-MVC stack.</p>\n\n<p>Older versions of Cells had a pretty controller-like semantic. You'd assign instance variables in <u>states</u> (like actions in controllers) and that would make the data available in the cell views. This all still works in Cells 4.0, however, I want to quickly introduce you to the new way of writing cells called <u>view model</u>.</p>\n\n<p>Rendering a cell (or, view model) ironically works via a helper. Cells can be invoked just anywhere but mostly you're gonna use them in views and controllers to replace a helper/partial-mess with a decent view component.</p>\n\n\n;;;\n\n<p>The above snippet could be in a controller view or the application layout.</p>\n\n<p>Here, the <code>concept</code> helper will call the cell's <code>#show</code> state. Note that I pass the latest comment model into the cell - every cell requires an object to wrap, whether that is a model, a collection or an <code>OpenStruct</code> is completely up to you.</p>\n\n<p>And now guess how a cell is implemented? Right, as a class! So many classes, who's gonna clean up that mess?</p>\n\n\n;;;\n\n<p>Per convention, the <code>#show</code> method is invoked once the cell is used. The above state does nothing more but rendering its view.</p>\n\n<p>Cell views are not in the global directory. They are components so views do reside in the concept's view directory, for instance <code>app/concepts/comment/views/show.haml</code>.</p>\n\n<p>At first glance, cell views look identical to ordinary views in Rails.</p>\n\n\n;;;\n\n<p><u><q>This view is nice and tidy. That doesn't look like an ordinary Rails view!</q></u> you might think now, and you're correct. In Cells, instance variables and locals are still available but proscribed. The preferred way of getting data into the view is with reader methods.</p>\n\n<p>An interesting change in Cells is that the concept of <q>helpers</q> doesn't exist anymore. Methods in the view are always called on the cell instance itself. The cell <u>is</u> the view context.</p>\n\n<p>To make this view working we need to provide those two reader methods in the cell class.</p>\n\n\n;;;\n\n<p>Again, every method in the view is called on the cell instance which is why I added <code>#body</code> and <code>#author_link</code> to the cell. These two methods provide a solid interface to the view and will be my exclusive way to populate the view with data. As you have already noticed you got access to the comment instance via the <code>#model</code> reader that is provided by Cells.</p>\n\n<p>Have you also seen that it is totally ok to use helpers in a cell? No one ever said that helpers suck. As long as they <u>help</u> they're fine. In this example I call <code>#link_to</code> to render a hyperlink while making use of a URL helper to compile the address.</p>\n\n<hr>\n\n<p>Accessing attributes from the decorated model is a task so common that Cells offers you a quicker way to do this. Check out the following code and how simple the cell is now.</p>\n\n\n;;;\n\n<p>Just as in representers and contracts, cells allow you to define properties of the wrapped model. A property in cell is automatically exposed as a reader to the view.</p>\n\n<p>Cells is my oldest gem and I've been working on it for almost 10 years now. The first time I actually used it was about a half year ago. I have to say I really enjoy Cells. They allow encapsulating a certain page block without having to worry about the environment. Cells, once implemented and tested, will just work.</p>\n\n<p>View models are the perfect counterpart for operations in Trailblazer. They embrace view logic that is only for the HTML user interface and provide an implementation standard for reusable widgets.</p>\n\n<p>There's many other features we're gonna explore in the book. Cells allow nesting, polymorphic collections, have a clean way of caching states and offer you view inheritance. In upcoming versions Cells will have a neat mechanism to inherit and override blocks in views.</p>\n\n<p>View inheritance is something that is completely ignored in Rails. This is not because view inheritance is a bad thing or overly complicated but because Rails views are all bound to controllers. No one wants to derive controllers just to inherit views.</p>\n\n<p>What I'm trying to say is: Rails' view architecture is far from being sophisticated. I don't want to critizise Rails too much but every other MVC framework has a much richer view tier. I honestly don't know what is the reason for this development in Rails. And I don't care anymore because we got Cells to fix it - and you're gonna learn everything about helpers, object-oriented partials, reusable templates and polymorphic views in this book.</p>\n\n\\n\n\n<p>While most of the logic is gonna happen in operations you still need a place for presentation and decoration of models. A typical example would be a reader method <code>#public?</code> that returns a boolean stating the visibility of a single comment.</p>\n\n<p>Going further, this method is then to be used in a cell for UI presentation and in an operation. We all agreed to not put any logic into the model: you're free to put this code into a decorator.</p>\n\n<p>Trailblazer comes with a simple decorator pattern called <u>twin</u>. Twins are used everywhere behind your back and the concept is so useful that I made it a public conceptual pattern.</p>\n\n\n;;;\n\n<p>A twin decorator makes logic reusable and we're gonna take advantage of them in some cases when we need to share behavior between layers.</p>\n\n<p>Twins can also help you re-modelling your data. This is a helpful tool when working on an existing codebase with a legacy table structure. Say you want to combine the <code>comments</code> table and the <code>authors</code> table into one object in your domain to hide the fact that this entity requires two database rows.</p>\n\n<p>A twin can implement a <code>Composition</code> for you.</p>\n\n\n;;;\n\n<p>When instantiating the twin needs both objects.</p>\n\n\n;;;\n\n<p>The user of this twin object doesn't need to know about the internal data structure. There's a couple of more nice structuring helpers in twins that we will see later.</p>\n\n\\n\n\n<p>I honestly haven't followed the whole <u><q>Is TDD dead?</q></u> debate and from the little pieces I read I can tell that there's a lot of misunderstandings going on between the fighting parties.</p>\n\n<p>If you want to write sustainable code and maintain good sleep quality simultaneously you have to write tests for your code. Period. Arguing about <q>yes</q> or <q>no</q> is simply ridiculous and a waste of sleeping time. And I don't think anyone meant to say <u><q>Testing is bad!</q></u>.</p>\n\n<p>When writing gems you learn to write tests. Edge-cases, bugs, implementation details, new features, and so on. Everything has to be tested properly. It is a terribly awkward moment when you release a new version and break people's code.</p>\n\n<p>You also learn <u>how</u> to test. I used to test the shit out of every private class. This is redundant and blocks you when refactoring. It's not always easy to decide what to test but I prefer having more tests than necessary.</p>\n\n<p>That said, testing is another fundamental concept in Trailblazer. The layered architecture, using operations for both domain and factories, and simple access to your business code makes testing actually enjoyable. It is different to Rails and we will see why in the countless tests I will make you write in the book.</p>\n\n<p>Trailblazer makes you write four different levels of tests.</p>\n\n<p>Integration tests assure that your endpoints (or, actions) do the right thing per request format. They are what I call <u>smoke tests</u> that test the happy path and the failing alternative.</p>\n\n<p>This is really simple to identify since every controller action maps to exactly one operation, that has a valid and invalid state, only.</p>\n\n\n;;;\n\n<p>Integration tests usually cover the raw HTTP-specific details, only. I don't check the integrity of the created comment, but the wiring between controller action and operation.</p>\n\n<p>Operation tests are the bread and butter of your application test suite. Since operations embrace your business, you're gonna test everything that could go wrong and right.</p>\n\n\n;;;\n\n<p>The clumsy class of an operation suddenly becomes extremely simple to use and test. I can tell you testing operations is actually fun.</p>\n\n<p>And what is incredibly convincing is the fact that we will use operations as test factories.</p>\n\n\n;;;\n\n<p>No more leaky factories that consistently result in a different application state. Instead use <q>production code</q> in your tests. I cannot repeat how much simpler and better my tests became with the <u>operation-as-factory</u> technique.</p>\n\n<p>Models and twins can have rudimentary tests for scopes and their decorating logic. They are read-only tests and similar to what you already do in your Rails apps (hopefully).</p>\n\n<p>Cells and integration tests test your UI. Since business is covered in the operation tests you can stay focused on visual testing here.</p>\n\n\n;;;\n\n<p>I was playing a lot with different approaches and found the results very satisfying. A good test suite is the guarantee for a good sleep.</p>\n\n\\n\n\n<p>Trailblazer introduces a new level of complexity into your application. Where teams previously had to deal with only models and controllers, there's now operations, forms, representers and more. Is this good or bad?</p>\n\n<p>Trailblazer brings something that is missing in Rails: Standards. Standards that go further than table names and rake tasks. It brings guidance for architectural questions and standards that have very clear scopes and use-cases. Where Rails has a wishy-washy <q>put this into the model, because... skinny controller!</q> convention Trailblazer clearly identifies the different layers of web applications and provides abstractions.</p>\n\n<p>Trailblazer is no <q>complex web of indirections</q> but a layered system architecture that handles many problems of Rails with mature gems and very loose coupling.</p>\n\n<p>It brings more layers to learn but at the same time relieves the conventional <q>MVC</q> components and encourages maintainable code by splitting up concerns into different components.</p>\n\n<p>It's a matter of communication to train developers to think in a high-level domain, endpoints, forms, representers, and Cells instead of confusing them by pushing every possible line of code into the model and helpers.</p>\n\n\\n\n\n<p>Trailblazer is very explicit. Instead of letting the framework guess what you want you have to define it - using a simple and consistent declarative language.</p>\n\n<p>High-level domain functions are implemented in operations that can be used as controller endpoints, as test factories, in the console or scripts. HTTP-related code is handled in controllers, operations embrace the business logic.</p>\n\n<p>Every operation has a form object. This is used to deserialize and validate the incoming data. All further logic and persistence happens in the operation, which can use the form object to push data to the model and persist data. Also, callbacks as known from ActiveRecord are moved to the specific operation.</p>\n\n<p>Presentation happens in Rails controller views or Cells. It's your choice which degree of encapsulation you want: Rails views may render models, operations or form objects. Cells decorate models and implement parts of the page.</p>\n\n<p>A third way of presenting is via HTTP APIs. Trailblazer offers you representers to render and parse JSON, XML and YAML including hypermedia and all the cool stuff. Again, representers need to be explicitely defined. Luckily, contracts use representers internally and can be re-used for serialization and deserialization of models.</p>\n\n<p>Twins provide a simple way for reusable decorators and data structuring like compositions. They can be used in any layer of Trailblazer.</p>\n\n<p>And now, let's go and do some actual coding. I'm tired of this lecturing.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>Konstantin Haase's famous last words... <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n\n\n<p>Throughout the course of this book we're gonna implement a real running Rails application called <u>Gemgem</u><sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>. The concept of Gemgem is simple: Comment on things.</p>\n\n<p>You literally present <u>things</u> on their own shiny page. A thing can be just anything, like a book, a band, or a Ruby gem. Besides information about the presented object, the thing page also allows commenting. <u>Comments</u> will have a weight which can be either positive or negative. And that's basically it.</p>\n\n<p>Additional features like moderated comments, notifications for comments, a slim in-page admin mode and user authentication will make this book a hopefully interesting read for you, dear reader, as I try to cover everything realistic found in a typical Rails application.</p>\n\n<p>While this might sound pretty tedious and boring let me explain why Gemgem is important to me. Gemgem is actually planned to become a feedback aggregator that matters.</p>\n\n<p>One thing I've been missing in the Ruby world is a place where I can easily collect user voices about gems. As a gem author it is very important to have a constant feedback flow from your users. This is not only beneficial for productiveness, but also stability. For an author, proper feedback can be extremely encouraging and continually motivating to keep working on something. Likewise, reviews and ratings help users to find gems suitable for solving their problems.</p>\n\n<p>Feedback drives a community and its products.</p>\n\n<p>I am aware of awesome pages out there like the <a href=\"https://www.ruby-toolbox.com/\">Ruby Toolbox</a>. There's numerous other projects that allow commenting and the like. Did anyone say Reddit?</p>\n\n<p>However, I always wanted a web app to keep all feedback about a certain thing in one persistent place and streamline the way feedback is collected and presented. And this is Gemgem.</p>\n\n<p>Going further, I am planning to let Gemgem grab and reference comments about a thing from other pages, making it really simple for authors and users to track what's word on the street.</p>\n\n<h3>Preparations</h3>\n\n<p>Gemgem can be found online on the incredible Github, and so a working version of this chapter's Rails application <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-03\">can be found on Github</a>!</p>\n\n<p>I've prepared branches that correspond to concise stages of every chapter. These branches will help you to see the entire application at this stage.</p>\n\n<p>As a trade-off for this I won't walk you through every little code change in this book. We're going to discuss all the relevant steps and conceptual necessities in detail but I'm not permanently gonna explain why I added this <code>div</code> tag to that view or how a particular collection of records were found. This saves both of us from wading through a million code lines per page.</p>\n\n<p>Trust me, you're gonna understand how Trailblazer works with Rails. It's gonna be fun. I actually can't wait to jump into the code. Let's do it!</p>\n\n<h3>Gemfile</h3>\n\n<p>As with every framework, Trailblazer needs to be loaded, and as always, this happens via the <code>Gemfile</code>. Here are the relevant lines.</p>\n\n\n;;;\n\n<p>The <code>trailblazer-rails</code> gem will load the core gem and run some more initialization code for you convenience (line 1). For example, ActiveModel support for Reform is automatically included, and so on.</p>\n\n<p>Since Trailblazer introduces a different file structure we decided a <code>trailblazer-loader</code> gem will nicely bridge Rails autoloading and our super primitive, explicit class loading (line 2).</p>\n\n<p>Trailblazer runs with all kinds of Reform versions, and since we're gonna make extensive use of the form gem, I lock it to 2.1.0 which is the newest release by the time of writing this (line 3).</p>\n\n<p>We will do integration tests using Capybara and MiniTest, so I include the <code>minitest-rails-capybara</code>, too (line 6). Note that you are free to use RSpec in your own apps, if you prefer that.</p>\n\n<h3>File layout</h3>\n\n<p>In many tutorials I've seen so far, writing an application starts with implementing a <code>User</code> class or table or whatever. The first thing to create then is the sign up page. I hate that.</p>\n\n<p>Even though I know that my application will have users logging in at some point, at this very moment I feel like cranking out the application's actual <u>domain</u>: allowing to comment on things. Why would I waste time with a stubborn user registration form now?</p>\n\n<p>This workflow becomes even more significant in a money-driven environment: imagine you were to present your business idea to some lame business dude. This person doesn't care about whether users can sign up using a captcha-backed form or via Facebook login. They want to see what makes your app awesome, they want to see your <u>domain</u> in action.</p>\n\n<p>And this is why we will implement how to create things now. Hey, don't get me wrong, I'm not a lame business dude at all. Money for me is printed paper. Nothing more.</p>\n\n<p>In Trailblazer, this development approach is built-in. Trailblazer makes you think about your domain, your business and not about what table is to be migrated and which association needs to be pointing to what join table. That is all stuff to be refined when it becomes a problem.</p>\n\n<p>The first thing we do is we create a new <u>concept</u>. The <code>thing</code> concept. While we have generators for that in Trailblazer we're gonna do that manually in this chapter. Yepp, some extra workout for you.</p>\n\n<p>I start by setting up the following file and directory layout.</p>\n\n\n;;;\n\n<p>Code for the <u>thing</u> concepts goes into a separate directory in <code>concepts/thing</code>. We will group all CRUD operations in the <code>operation.rb</code> file. I'll come back to that in a second.</p>\n\n<p>Trailblazer uses models, views and controllers the way Rails established them. There is no replacement for controllers, yet. Rails' model layer is just fine as it allows you to use ActiveRecord, or any other ORM. Views can be modularized or replaced using Cells.</p>\n\n<p>This is why the original three <q>MVC</q> directories are still there. If this annoys you because you were expecting Trailblazer to make everything different, wait until you see how slim the original layers become and how code gets pushed into new, more appropriate tiers.</p>\n\n\\n\n\n<p>In order to start using our software, let's start with an operation to create a thing. As already discussed in chapter 2, operations are an application's endpoint for the high-level domain. They implement all the public operations a user can perform.</p>\n\n<p>In a Trailblazer project, your high-level domain will automatically evolve. It's a side-effect of moving business code into operations that embrace or define your domain. No one requires you to formulate your complete high-level API right now! You're gonna be surprised how thinking about building applications shifts from <u><q>Where do I add this in which model?</q></u> to writing a new operation whenever you expose a new function to the public.</p>\n\n<h3>Persistence</h3>\n\n<p>You might have noted that there's an <code>app/models/thing.rb</code> file. This is a standard <code>ActiveRecord::Base</code> model class.</p>\n\n\n;;;\n\n<p>Following the Trailblazer style, it only contains persistence configuration. Here, a <code>has_many</code> directive for comments which we're going to use soon. There's no callbacks, no validations and no additional business code in this class - and that is a good thing.</p>\n\n<p>I chose to use ActiveRecord in this book to make it easier for developers to relate to their own project, but you can literally use any ORM framework you want.</p>\n\n<p>Note that there's also migrations that create an initial database. What matters for us is the following snippet, only.</p>\n\n\n;;;\n\n<p>A thing always has a name and a description. This is pretty amazing.</p>\n\n<h3>The Operation Class</h3>\n\n<p>Ok. We wanted to allow the user to create a <u>thing</u>, right? This is our first high-level domain action that will reside in a fresh <code>Operation</code> class. After playing with several file layouts I ended up putting CRUD operations into the <code>operation.rb</code> file in the concept's directory. I am talking about <code>concepts/thing/operation.rb</code>.</p>\n\n<p>This file will contain all CRUD code for things. Let's have a look at this file.</p>\n\n\n;;;\n\n<p>I usually put operations for a model into the model's namespace. This is why I create a class inside the <code>Thing</code> class which results in the global name <code>Thing::Create</code>. Reading this you instantly know what is the responsibility of this operation.</p>\n\n<h3>Ruby's namespaces</h3>\n\n<p>Please note that this absolutely does not tie the operation to the ActiveRecord model! All we do here is reusing the model's namespace.</p>\n\n<p>Namespacing helps grouping operations that belong to one <u>concept</u>. Putting classes into other classes does not extend, derive, bundle or tie anything to anything. The inner class doesn't know about the outer class, and vice-versa. This is a pure structural Ruby technique that has - admittedly - caused some confusion for new Trailblazers.</p>\n\n<p>Another benefit of namespacing is that you don't pollute the global namespace. Instead of nesting classes as we do it, the operation could also be called <code>CreateThing</code>, <code>ThingCreate</code> or whatever on the global namespace. In Rails, this would probably end up as <code>ThingCreateOperation</code>, which, frankly, looks horrible. Trust me, the namespacing is really helpful for structuring.</p>\n\n<p>Later in the book, we will introduce concepts that don't have a direct 1-to-1 mapping to a model. The <q>feed</q> and <q>follow thing</q> concepts are a good example for that. Instead of using the model class we will use a concept namespace. Also, we will learn that operations are not limited to CRUD semantics but can implement just anything.</p>\n\n<h3>The process Method</h3>\n\n<p>Coming back to the operation implementation you will notice that there's only one method present, called <code>#process</code>. This is the only requirement that needs to be implemented.</p>\n\n\n;;;\n\n<p>You are going to write a lot of process methods in this book. They always receive the parameters hash that was passed to the operation from the caller, which could have been a controller action, a test or a console call.</p>\n\n<p>Presently, I simply by-pass any validations and call <code>Thing.create</code>. Note that operations require the <code>params</code> hash to contain the model attributes under a separate hash key (here <code>params[:thing]</code>). This makes it work seamlessly with Rails' well-established <code>params</code> concept and allows passing additional environment data into the operation.</p>\n\n<p>Passing the entire params hash into the operation might appear awkward. It actually took me weeks and months to figure out what's the best way to provide data to the operation. As usual, the simplest approach wins.</p>\n\n<h3>Testing Create</h3>\n\n<p>The above code is enough to hook our operation into a controller.</p>\n\n<p>No. No no no! We're not gonna do that until we've written a test for that operation. I know how tempting it is to simply plug it onto a route and see what's happening. However, this book's hidden agenda is all about testing. So let's write a test.</p>\n\n<p>In Trailblazer, business logic is tested by testing your operations. In Rails, this usually is split into controller tests and model tests, making it hard to figure out behavior from tests.</p>\n\n\n;;;\n\n<p>Usually, all tests for a particular concept sit in the same directory. This groups tests for cell, operation, representer and twin and again embraces the component structuring. Tests for our operations go into <code>test/concepts/thing/crud_test.rb</code>.</p>\n\n<p>This test first calls the <code>Create</code> operation and passes in the parameters that define this test case. Since the operation <u>call style</u> will return the operation itself I invoke <code>#model</code> on it to retrieve the created model (line 4-6).</p>\n\n<p>The following three lines assert that the created model was populated and saved correctly. This is nothing too fancy (line 8-10).</p>\n\n<hr>\n\n<p>You might find my test style funny because I barely use the test framework's sugar. All I do is grouping test cases using <code>describe</code> containing one or more <code>it</code> blocks. The <code>it</code> block embraces multiple assertions.</p>\n\n<p>While you're free to use whatever test framework and style you want there's several reasons I do write my tests like this.</p>\n\n<p>Firstly, I hate indentations. Using <code>describe</code> was originally designed to create reusable environments, and that is great. However, the more levels of <code>describe</code> you nest to achieve a reusable setup the more you lose track of why you actually nest blocks and what is being tested. Or, in other words: The less I nest the better readable my test code gets and the easier I find it to restructure blocks.</p>\n\n<p>The other thing I've seen lots of tests incredibly overloaded with <code>it</code>s. In my above example, I could easily split the one block into three separate <code>it</code>s. This not only creates unnecessary noise, this is just wrong. My particular test is about asserting the result of one single create operation - and that means I explicitely do <u>not</u> want to run this operation for every assertion.</p>\n\n<p>Regardless of the outcome of our test style battle: the operation is now good to go. Let's hook it into a controller.</p>\n\n\\n\n\n<p>To use an operation the simplest way is to use Trailblazer's <code>run</code> method in controllers. <code>run</code> is imported automatically by the <code>trailblazer-rails</code> gem.</p>\n\n\n;;;\n\n<p>This runs the operation and then returns flow control back to the controller (line 3). It's probably easier to understand when I show you what happens inside <code>#run</code>. Here's what basically happens when you use <code>run</code> in a controller.</p>\n\n\n;;;\n\n<p>As you can see, <code>run</code> automatically passes the <code>params</code> hash into the operation invocation. I know, this looks as if you could easily do it yourself. In later chapters we'll see how helpful that is when composing parameters before passing them to operations. For instance, <code>run</code> can merge the current user into <code>params</code> to allow an operation to handle authorization, too.</p>\n\n<p>It is important to mention here that you can still use the existing controller rendering. Trailblazer comes with Cells to encapsulate parts of the page, but we still use global views for controllers. Moving code from the controller into operations doesn't limit you - it is a structural improvement.</p>\n\n\n;;;\n\n<p>See, you can invoke an operation and still do conventional Rails view rendering.</p>\n\n<p>Running an operation with <code>run</code> comes with another benefit. Every operation has exactly two states: success or invalid. The block style for <code>run</code> integrates these two different scenarios with your controller.</p>\n\n\n;;;\n\n<p>The block is only run when the operation was invoked successfully, resulting in a redirect to the freshly created thing (line 3). Since that block returns from the <code>create</code> method, the remaining code is not run. In turn, given that the operation is invalid, the code below the block is executed. That will re-render the form and show possible validation errors (line 6).</p>\n\n<p>Beside the fact that this is an extremly handsome controller action, two things are a bit awkward at this current moment: We don't have a <code>new</code> action and view, yet, and even if we had one, how would that look like, and how would the form to create a new thing be rendered?</p>\n\n<p>The second point is, and I don't know if you remember it, but our operation doesn't do any validation checks and the like, so how would it know whether or not it was run successfully?</p>\n\n<p>The answer is: it doesn't. Without validations, the operation always <q>thinks</q> it was run successful. While this reflects an extremely positive attitude towards life this is not quite what we want for our business rules.</p>\n\n<p>Our next step is to add validations to the create operation. In Trailblazer, this happens by adding a form object - exciting times!</p>\n\n\\n\n\n<p>In order to add validations to the create operation, I would like to introduce you to Reform's form object, first. It won't take long and when we see how operations and forms integrate you will understand why I am insisting on talking about Reform now.</p>\n\n<p>Please, for two minutes, forget about the operation we just built and imagine we were to implement a form for creating things and its processing code directly in a controller.</p>\n\n<p>Reform allows you to define fields and validations in a separate class - the <u>form</u> class. In Vanilla Rails, validations go directly into ActiveRecord classes and make it extremely hard to reuse validations in different contexts.</p>\n\n<p>Here's the Reform class I'd write for the <code>Thing::Create</code> workflow.</p>\n\n\n;;;\n\n<p>This class is pretty straight-forward, I believe. Fields are defined using <code>property</code>, optional validations can be specified using the well-known <code>validates</code> method with all the goodies known from Rails.</p>\n\n<p>Form objects can validate input and mediate the sanitized data to models.</p>\n\n<p>Furthermore, a controller action could also use this class for rendering a form. Presenting the form could happen using <code>simple_form</code> or any other form builder gem. In order to take advantage of the form builder we need to instantiate the form first.</p>\n\n\n;;;\n\n<p>When creating a form object, you always need to provide a model to the form. Here, this is a new <code>Thing</code> instance. I assign the form object to the <code>@form</code> instance variable to use it in the view (line 3).</p>\n\n<p>All additional abstraction layers in Trailblazer usually decorate - or wrap - a model. This is a pattern found in forms, cells, representers and twins.</p>\n\n<p>Check out the corresponding <code>app/views/things/new.html.haml</code> view and how I use the form object with simple_form as an intermediate object between presentation and persistence.</p>\n\n\n;;;\n\n<p>See how the form instance can then be used directly with a form builder? The latter doesn't even know it is presenting a Reform object, it still thinks that this is an ActiveRecord model.</p>\n\n<p>This view will render a cute form to create new things for Gemgem. After filling it out, clicking the submit button will hit the controller's <code>#create</code> action where the form input is validated and processed.</p>\n\n<p>The following snippet outlines how such a create action could look like.</p>\n\n\n;;;\n\n<p>While this looks pretty familiar please note how we make heavily use of the form object.</p>\n\n<p>To validate the submitted input we use the form's <code>validate</code> method that accepts a hash of parameters and then in turn uses the validators we defined earlier (line 4). When validating the input, Reform does <u>not</u> write anything to the model, yet, cleanly separating the persistence layer from the business.</p>\n\n<p>After a successful validation the form can update attributes and save the wrapped <code>Thing</code> model using <code>save</code> (line 5). What an incredible API - both methods do exactly what their name says!</p>\n\n<p>In case the validation failed the form provides a Rails-compatible list of errors. This can be retrieved using <code>@form.errors</code>.</p>\n\n<p>Check out the controller code surrounding the form invocations: this is nothing more than orchestrating instructions that delegate view rendering and redirection according to the form's state.</p>\n\n<p>And that's Reform. Let me summarize what we just did.</p>\n\n<ol>\n<li>We defined a form with properties and validations.</li>\n<li>When instantiating forms you need to pass an existing or a new model into the constructor.</li>\n<li>The form instance can then be used in the view to render a HTML form, e.g. in the <code>new</code> action.</li>\n<li>Likewise in <code>create</code> or <code>update</code>, processing the submitted data works with the form's <code>#validate</code> method.</li>\n<li>Dependent on the validation result, the form can also push validated data back to the model and save it.</li>\n</ol>\n\n<p>Ok, we got an operation to embrace the entire process of creating a thing. We got a form object as <u>a part</u> of that to validate and process the incoming data. Now, how do these two play together? Do you have to manually create an operation and a form and somehow use the form inside of the operation, or what?</p>\n\n<p>Of course not. You could do that manually, now that you understand the principles of both pattern. However, the form object is integrated into the operation.</p>\n\n\\n\n\n<p>Instead of having to define the form separately you can do that in the operation. In Trailblazer, you usually have a form object and an operation combined, making it surprisingly simple to use the form's deserialization and validation mechanics in the operation.</p>\n\n<p>Let's check out how an operation with a form object looks like.</p>\n\n\n;;;\n\n<p>The familiar <code>Thing::Create</code> operation gets extended with a form. Additionally, I changed the processing code to consider validations.</p>\n\n<p>In operations, a form is called <u>contract</u>. Basically, I copied the form's content into the <code>::contract</code> block (line 3-9). This DSL method does nothing more but creating a Reform class behind the curtain for you. It also helps dealing with inheriting contracts to other operations, this is why I originally introduced the <code>::contract</code> method.</p>\n\n<p>That said, it becomes obvious that you may use any of Reform's goodies in the contract block. Again, this block is simply a Reform class, you're free to use advanced validations or nested forms, which we're gonna learn about later.</p>\n\n<p>After adding the form (or contract) I also modified the <code>#process</code> method in the operation. The original call to <code>Thing.create</code> got replaced and I now use <code>Thing.new</code> to instantiate a fresh model for the create (line 12).</p>\n\n<p>Creating the form object, populating it with the incoming data and validating the input all happens in the <code>validate</code> invocation (line 14). The required arguments here are the actual parameters from the form submission and the model the form will wrap.</p>\n\n<p>After verifying the input, the <code>validate</code> method invokes the passed block <u>only</u> if the validation was successful (line 15). The form that gets yielded into the block offers me a convenient way to update attributes and save the model - by calling the form's <code>#save</code> method I avoid doing just that manually.</p>\n\n\\n\n\n<p>Operations are designed to cover an entire application's high-level domain. Looking at conventional Rails projects (or all kinds of applications) you will see that more than 85% of your domain is CRUD logic: creating and updating objects, whether they are persistent or not, is the main task of every project.</p>\n\n<p>Trailblazer comes with CRUD, or model semantics for operations that standardize a few steps so you don't have to think about them anymore.</p>\n\n<p>Please, have a look at our operation after using the <code>Model</code> module.</p>\n\n\n;;;\n\n<p>This is getting really simple.</p>\n\n<p>I first include <code>Model</code> into the operation, this will resolve to and load the <code>Trailblazer::Operation::Model</code> module (line 2).</p>\n\n<p>Instead of creating the model manually I tell the operation what to do (line 3). Using <code>::model</code> will instruct the operation what kind of model to instantiate for processing.</p>\n\n<p>This greatly simplifies the <code>#process</code> method (line 13). The model is now created automatically in the invisible <code>#model!</code> method that we're gonna discuss in a few chapters. Also note that I don't need to pass the model into <code>validate</code> anymore (line 14). Only the parameters go in, the rest is handled by the <code>Model</code> module which I find extremely convenient.</p>\n\n<hr>\n\n<p>Fantastic. Even if I didn't manage to make you entirely understand how things work together, you get a pretty good idea about what the operation does and is supposed to do. The code we just wrote can be used for three different use cases.</p>\n\n<ol>\n<li>Our <code>Create</code> class validates and processes input and persists a new <code>Thing</code> model populated with sanitized input, given the validation was successful.</li>\n<li>It can also be reused to render a form, or more precisely, to help the form builder to render a form. This is helpful for the <code>new</code> action where you allow users to create a new thing by filling out a form.</li>\n<li>As if this wasn't enough, the operation can also be used to render an invalid form. This works like 2. only that the form builder (or HTTP API code) can access validation errors from the contract, too.</li>\n</ol>\n\n<p><u><q>Wait - this is not SRP, this is too many responsibilities in one class!</q></u> you will think now. Your point about the operation's inflated responsibility scope is valid. But also wrong.</p>\n\n<p>Keep in mind that an operation is composed of more than one object. An operation maintains a form object which is completely decoupled from the operation itself - the form doesn't even know it's being used in a Trailblazer environment. A Reform object comes with the ability to validate input, save models and present errors, and the operation acts as an orchestrating dispatcher, only.</p>\n\n<p>Don't confuse reusability with responsibility. Where Rails usually exposes one physical object to handle everything (also known as the <u>model</u>), Trailblazer has a fine-grained object design. This allows cleanly handling several steps of a typical workflow with <q>one</q> object: The API simply dispatches to internal objects which cover one responsibility, only. I am going to talk about SRP and the misunderstandings with this concept in a later chapter.</p>\n\n<p>If you're still sceptical, I invite you to have a look at <a href=\"https://github.com/apotonick/trailblazer/blob/master/lib/trailblazer/operation.rb\">Operation's code</a> - it is surprisingly simple and delegates more than it actually implements.</p>\n\n<p>Next, I want to discuss how we can reuse the operation for rendering forms to allow users working with our upcoming website.</p>\n\n\\n\n\n<p>You will have noticed that I started this chapter with a workflow that might seem counter-intuitive. Instead of programming the form to create a thing I actually gave precedence to the processing logic, first.</p>\n\n<p>This is good in two ways: Most of the hard work is already done, and we need to write very little code to implement the form rendering now.</p>\n\n<p>The controller action to display the UI for this will go into the <code>#new</code> action of <code>ThingsController</code>, following a Rails conventions that actually has made my life easier.</p>\n\n\n;;;\n\n<p>This is not a lot of code. I told you, the hard work has been done already. Now, what happens here?</p>\n\n<p>Calling <code>#form</code> in the controller will instruct the operation to only instantiate its model without running any processing code. The operation will create or find the respective model for you as this reuses the same mechanics from the creating process we discussed earlier.</p>\n\n<p>After the model is created or retrieved, the operation instantiates its contract, using the model as the <u>form model</u>. This allows to use the Reform object outside of the operation, e.g. in combination with a form builder.</p>\n\n<p>The missing piece now is how the form is made available to the controller. And you guessed right, the <code>#form</code> helper assigns the controller instance variable <code>@form</code> which can then be used in the view.</p>\n\n<p>Why don't we check out the controller's view in <code>app/views/things/new.html.haml</code> which is rendered automatically in the aforementioned action.</p>\n\n\n;;;\n\n<p>That does not only look exactly identical to the code we had a few pages ago, that is the exact same snippet. And I am absolutely not trying to fill pages with fluff. The fact that an operation's contract is a Reform object makes this part very straight-forward. You can use the operation's form just like you did it directly with Reform. Form builders love Reform.</p>\n\n<p>Here's what we have so far.</p>\n\n<ol>\n<li>In <code>ThingsController#new</code>, the operation finds or creates the model. After creating the form object we can use the latter to render a form in a controller view.</li>\n<li>The user fills out the form and clicks submit.</li>\n<li>Submission of the form will hit <code>ThingsController#create</code> which simply delegates work to the <code>Create</code> operation.</li>\n<li>\n<p>Again, a model is created. This time, the operation runs <code>#process</code>, validates the input and updates and saves the model in case of valid input.</p>\n\n<p>The controller then redirects to the new thing's URL.</p>\n</li>\n<li><p>Given the input was not adequate the operation will mark itself as invalid. The controller won't redirect but re-render the <code>new</code> view. Since not only the <code>form</code> controller helper but also <code>run</code> assigns the <code>@form</code> instance variable this will render the operation's form - this time, it will also display validation errors!</p></li>\n</ol>\n\n<p>How is the form builder in the <code>new</code> view able to render erronous fields? How does it know about validation errors that happened somewhere in the operation, in its form?</p>\n\n<p>The answer is very simple. The form exposes a form builder compatible <code>#errors</code> method. When rendering, the builder asks the form about errors, which happens via this method.</p>\n\n<p>Awesome! We implemented an entire workflow of displaying a form, processing, and handling errors. I am a bit proud of you. But I'm also concerned since we barely test any of this.</p>\n\n<p>Let's spend the next two pages on how to test our controller actions and the operation with its form.</p>\n\n\\n\n\n<p>We extended the create operation to use a form, allowing to validate input instead of blindy persisting it. Looking into <code>thing/crud_test.rb</code> we already assert the happy path. We now need to test an invalid scenario.</p>\n\n\n;;;\n\n<p>To test invalid input I use the operation's <code>#run</code> method as it returns the validation result along with the operation instance without raising an exception in case of an error (line 2).</p>\n\n<p>In the following line I assert the result is false (line 4) and the model wasn't persisted (line 5). I wouldn't test the latter normally, but since this is a book I want to look like a super-correct developer.</p>\n\n<p>What is important is the last line of the test. Accessing the contract's <code>errors</code> object, converting it to a string and asserting the error messages is a fundamental test that assures my validations actually work (line 6).</p>\n\n<p>As we have complex validations in this operation, we also must test the <code>length</code> validator from our <code>description</code> property.</p>\n\n<p>All kind of validation tests are tested via the operation that contains the respective form object. Neither does it make sense to test form objects directly (you could do that, though) nor are we keen to write slow, opinionated controller tests for all edge cases. Since the operation keeps our business logic this is the perfect place to assert validity.</p>\n\n\n;;;\n\n<p>Again, all I do is provoking a validation error, this time with a too short description. This test is very verbose and later we will learn how to use matchers for all kinds of generic validation tests. They greatly improve readability and save brain-power invested into writing those validations tests. For now, however, I decided it's good to show you the mechanics on a lower level.</p>\n\n<hr>\n\n<p>Tests like that make me sleep at night. What I love about operation tests is that they are incredibly simple and fast, both to write and execute. The style is always very simple because of the unified <code>Operation</code> API. Testing various invalid scenarious is a walk in the park. This is different to Rails' model tests which only test parts of your business code.</p>\n\n<p>Operation tests will automatically test all your domain logic - an operation <u>is</u> your domain layer.</p>\n\n<p>Also, I always hated writing controller tests. They are slow and clumsy. And when you look at the implementation of <code>ActionController::TestCase</code> you will find out why. An insane amount of code is used to setup a leaky test environment that is the opposite scenario of production code.</p>\n\n<p>The result will be tests that might pass but the very same code still fails in production.</p>\n\n<p>Always remember: the more code you need to setup your test environment the more likely it is to break on real servers with real users and real, mercyless requests.</p>\n\n\\n\n\n<p>The controller is incredibly slim in a Traiblazer setup, look at the actions in <code>ThingsController</code> implementing new and create. This is not because we code hide the way <code>inherited_resources</code> does it. This is because the code now sits in an operation which is completely decoupled from the controller - and thoroughly tested.</p>\n\n<p>When it comes to controllers, I always simply test the wiring. I call this a <u>smoke test</u> as it doesn't assert any edge cases and only runs on a very superficial but yet efficient level.</p>\n\n<p>I would like to quickly run through <code>test/integration/thing_test.rb</code> now. As you can see, I structure integration test by concept and semantic, since some of the tests will grow during this book, just as some stomachs will.</p>\n\n\n;;;\n\n<p>The new test class I derive from <code>Trailblazer::Test::Integration</code>, which is provided by the <code>trailblazer-rails</code> gem (line 1). It automatically allows us to use the Capybara gem for realistic integration tests with selector matchers like <code>must_have_css</code>.</p>\n\n<p>I first let render the form by browsing to the <u>new</u> page using the <code>visit</code> helper that accepts real paths (line 3). This implicitly tests rendering of the page and will fail if we did something wrong here.</p>\n\n<p>By submitting an empty form and checking for CSS classes in the resulting page, I make sure both routing to the <code>update</code> action, processing thereof, and rendering an erroring form works (line 6-7). The default Simple-form behavior is to render at least one <code>div</code> class named <code>.error</code> and this is all I test.</p>\n\n\n;;;\n\n<p>As a follow up test, I submit the form again, this time, by filling in correct values (line 4-5). Capybara gives me a really nice DSL to achieve just that using <code>fill_in</code> and <code>click_button</code>. Again, this is also an implicit render test as those calls would fail if form elements can't be found.</p>\n\n<p>Instead of making wild assumptions about what the business logic might have done I simply test whether the endpoint redirects me to the newly created object (line 6). I find the latest model using <code>Thing.last</code>. Note that there's better ways to retrieve the operation's result, we're gonna learn that later.</p>\n\n<p>The focus of <u>smoke tests</u> is to make sure a minimal set of constraints is met. Smoke tests assert that the controller runs for the happy path and for invalid data - nothing more. Since the business logic is already tested in operation tests there's no need to repeat it in an integration test.</p>\n\n<p>A few days ago I explained integration tests to my friend Jonny as a click test. Before programmers used automatic testing, they would click through common pathes of their app after having changed code, without focusing on details, just to make sure the flow isn't broken.</p>\n\n<p>Of course, this is unacceptable for high-quality software, but a controller in Trailblazer is nothing more than a stupid HTTP endpoint. The integration smoke test is sufficient to maintain product quality. Our point is: we tested all edge-cases in detail in our operation tests.</p>\n\n\\n\n\n<p>In the last three pages of this chapter I'd love to go through the <code>Update</code> operation for editing and updating an existing thing. Several readers requested this operation to be a bit more complex. Just a lil' bit.</p>\n\n<p>Why not make the <code>Thing</code>'s name field read-only when editing? Let's assume we're gonna use the thing's name to generate its unique URL in Gemgem - changing the name would also change that URL, which is no good. The <q>business</q> decides to make the name static, once it has been chosen when creating the thing.</p>\n\n<p>This is extremely simple in Trailblazer. Thanks to its explicit, declarative style, all we need to do is re-configure the existing <code>Create</code> operation. Of course, this happens in a subclass. This does not only give us the freedom to fine-tune behavior later, it also assures we do not break any create code: a subclass inherits structure and behavior, but the <code>Create</code> operation is completely decoupled from the <code>Update</code> class - it doesn't even know it got derived.</p>\n\n<p>Here's the updating operation in <code>app/concepts/thing/operation.rb</code></p>\n\n\n;;;\n\n<p>And that's literally it.</p>\n\n<p>The <code>Update</code> class is derived from the creating operation using pure Ruby. This will <u>copy</u> all the operation's code and the contract to the new class (line 1).</p>\n\n<p>To give a new semantic to the operation, I override the old action with <code>:update</code> (line 2). This will tell the operation to find the model, not to create a new one. In order to do so, the operation will look for an <code>:id</code> in the incoming parameters.</p>\n\n<p>As the <q>business</q> wants us to make the name immutable when editing we need to do so in the contract. Luckily, Reform comes with that out-of-the-box and allows us to override the original <code>name</code> property to be not writeable anymore (line 5). This will simply ignore the name field when processing the form.</p>\n\n<h3>Testing: Update Operation</h3>\n\n<p>Maybe looking at the respective test makes it easier to understand what we just did.</p>\n\n\n;;;\n\n<p>First, note how I reuse the <code>Create</code> operation as a test factory (line 3-4). This is really one of my favorite features in the Trailblazer architecture! This will always give you a valid application state in your test cases that is as close to production as possible.</p>\n\n\n;;;\n\n<p>I then invoke the <code>Update</code> operation with a new name and description (line 4-10). In addition to that, I also have to pass in the id of the object to be updated (line 5). The operation will use that id to find the actual model.</p>\n\n\n;;;\n\n<p>As you can see, even though I sent in malicious data trying to change the name, it remains the original title (line 3). Reform simply ignores it.</p>\n\n<p>Currently, this test is enough to cover all eventualities for the update operation. Since everything else is inherited, we don't need to test it as we didn't change anything else.</p>\n\n<h3>Controller</h3>\n\n<p>The controller's <code>edit</code> action for rendering the edit form is almost identical to the <code>new</code> action we wrote a few minutes ago.</p>\n\n\n;;;\n\n<p>Note how I use <code>Thing::Update</code> in this action, as we want to display a form for an existing model. What happens here is <code>form</code> will automatically pass the entire <code>params</code> hash to the operation. This hash contains an <code>:id</code> field per Rails convention and allows the update operation to find its model (line 5).</p>\n\n<p>Given you were viewing the URL <code>http://localhost:3000/things/1/edit</code> this would translate to the following invocation inside of <code>form</code>.</p>\n\n\n;;;\n\n<p>And this is exactly the information the update operation needs to retrieve the edited or updated model.</p>\n\n<p>The corresponding <code>update</code> action in the controller called when submitting the edit form works likewise and doesn't need further discussion here.</p>\n\n<h3>The Edit Form</h3>\n\n<p>We want to reflect the read-only <code>name</code> field in the edit form visually. Form fields can be disabled and, even better, <code>simple_form</code> comes with the <code>:readonly</code> option for just that. To maximize your excitement, Reform knows whether or not a field is writeable. Now, let's put this all together in the <code>new.html.haml</code> view that we render in the new and edit action.</p>\n\n\n;;;\n\n<p>That's the same form we had earlier, with a minor improvement. I query the Reform object for the read-only state of the <code>name</code> field (line 2). This will render a normal input field when used in new context, as it used to be. However, since the update operation sets this field to read-only, this will display a disabled input field in edit mode - just as the <q>business</q> requested it!</p>\n\n<h3>Testing Form Rendering</h3>\n\n<p>We did some small changes to the form. In edit context, the name field is read-only. When creating a new thing, however, this field must be editable. I insist on adding that to our controller tests where we test the rendering for now.</p>\n\n<p>I add those tests to <code>test/integration/thing_test.rb</code>.</p>\n\n\n;;;\n\n<p>This tests the <code>edit</code> action in the things controller. I assure that the form field for <code>name</code> is really rendered as read-only using <code>must_have_css</code> (line 7). Since the <code>simple_form</code> gem adds a <code>readonly</code> class to the input field, we can easily test that.</p>\n\n<p>Testing the edit form is one thing. However, we also have to assure that we didn't mess up the form we built earlier, that's rendered with the same view. The form for new things definitely needs a writeable <code>name</code> field.</p>\n\n<p>I add some quick lines to the very same test case.</p>\n\n\n;;;\n\n<p>The test makes sure the name field is present but not read-only in a create context (line 6).</p>\n\n\\n\n\n<p>Protecting mass assignments from unwanted input was long handled with hand-made exclusion logic or using <code>attr_accessible</code>. This was a source of problems because models were used in different contexts but the attributes could only be defined once, on the class level.</p>\n\n<p>Rails (or, DHH himself) then introduced <code>strong_parameters</code> which takes the definition of unsolicited parameters to the controller. While this definitely is an improvement, I still find it unsatisfying. There's no way to add additional semantic and behavior to deserialisation when processing a form. Also, this logic is now coupled to the controller <u>and</u> to the model, as there's usually extra code in the model to rename or move parameters coming from the controller.</p>\n\n<p>To me, this looks like a half-baked fix on top of a leaky implementation for input deserialisation and processing. In fact, there is no abstraction for deserialisation in Rails. Once you pass the params hash into <code>create</code> or <code>update_attributes</code> it's out of your scope what will happen. Especially in a nested model setup this is extremely frustrating.</p>\n\n<p><code>strong_parameters</code> makes you think you can control the way parameters are deserialized - which turns out as an illusion once things get a bit more complicated.</p>\n\n<p>Again, this a result of Rails' monolithic architecture and its low degree of encapsulation. Instead of simply extracting form logic into a form object, the deserialisation is distributed between controller and model.</p>\n\n<p>Reform doesn't need <code>strong_parameters</code> at all. When defining the form class, with all its properties and quirks, the form knows what parameters to process and what to ignore. A form embraces the entire workflow of, well, a form and all the work associated with it.</p>\n\n<p>Remember how we set the <code>name</code> field to read-only and that made everything work for updates? That's the benefit of abstraction and explicit code as found in Trailblazer.</p>\n\n<hr>\n\n<p>Hey, I'm really proud that we made it that far. We implemented the entire Trailblazer workflow for adding and updating things with operations, models, tests, UI and lot of chat. Cool! In the next chapter, I want to spend a bit of time in the view layer. We're gonna learn how to use Cells to encapsulate parts of the views to objects, making them reusable, simpler to test and better to work with.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>This nifty name comes from my ex-workmate and friend <a href=\"https://twitter.com/gogogarrett\">Garrett Heinlen</a>. Our love for Ruby, beers, dance, and maroon-colored shirts has banded us together for life. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>After having implemented an operation with a form to create and update <u>things</u> I'd love to talk about views for a brief chapter. I know, we're all keen to learn more about deleting things, adding comments, and all that domain logic, but hang on. The view layer is where you win the business.</p>\n\n<p>Even though my frontend knowledge is close to zero, I love to put a nice UI into place as early as possible. This does not only help discussing and evaluating features and usability, it also makes it look as if you're actually working really hard on stuff.</p>\n\n<p>A working version of this chapter is - as always - available <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-04\">in the repository</a>.</p>\n\n\\n\n\n<p>Do you remember what I said in the introduction chapter a while ago? Basically, I am writing this book and all that because I wasn't satisfied with how Rails makes you do view components.</p>\n\n\n;;;\n\n<p>Suppose we wanted to display the last nine recently created things on our homepage. And, assuming we had less than nine things to show, they would still wrap up properly in our grid.</p>\n\n<p>Given we're using the Foundation grid and Rails this is pretty simple to accomplish. You grab the last nine things, write a quick partial for one box displaying one thing. And then you do something as follows.</p>\n\n\n;;;\n\n<p>Of course, this looks great. Rails has a tendency to beautify complex things and make them look less complicated.</p>\n\n<p>However, this only works if the global partial's name is <code>things/_thing.html.haml</code>. And, going further, this doesn't handle the case that the last thing box needs a CSS class <code>.end</code> to make Foundation render the grid properly even when there's less than nine boxes. But, hey, this is really simple to solve since you can write a helper method to <q>encapsulate</q> the rendering of nine or less boxes on our homepage, and the helper will also handle the <code>.end</code> class properly... somehow.</p>\n\n<p>The view code probably ends up in one helper <q>method</q> <code>render_boxes_on_homepage</code> - which is actually a global function - to represent a certain part of the UI. In our case, this is the entire <u>things</u> grid.</p>\n\n<p>Each grid item is then modelled with a partial. It needs a bit more than just markup, so the code to detect the last grid item goes directly into the partial. Don't tell me you'd write another helper method - it is simply too awkward to push a <q>private</q> code concept for our things grid onto the global helper stack.</p>\n\n<p>I am not saying that a bit of logic in views is wrong. What I am saying is that every project I've seen had a terrible view layer, where the data modelling and the implementation just didn't feel right - given that Rails claims itself an <q>object-oriented framework</q>.</p>\n\n<p>And I get the same feeling now, assuming I had to write partials and helpers to implement that grid. The whole global helper/partial approach never really made sense to me.</p>\n\n<p>Why are we forced to think about views as functions rendering arbitrary templates, templates without any interfaces and access to global state? Didn't we stop doing PHP because of that? Why can't we think about views as <u>widgets</u> where a widget, whatever that is, represents a certain part of the page? I'll tell you why. The Rails view layer hasn't been touched in almost ten years. No one saw the need to introduce change into this PHP-inspired stack layer.</p>\n\n\\n\n\n<p>The Cells gem tackles views from the opposite direction. A cell completely embraces a fragment of the UI. That fragment does explicitly <u>not</u> have access to global state - it is implemented as a separate object.</p>\n\n<p>A cell is like a <u>widget</u>. Logic and templates needed to present that part are encapsulated in this widget. Any dependency required from the environment, say, the current page in a paginated list, has to be passed in from the caller. This creates an interface for a view.</p>\n\n<p>Which gives us a few advantages over Rails.</p>\n\n<ul>\n<li>The controller or the view rendering a cell doesn't know anything about the cell, and the cell doesn't know who's rendering it. The effect is called <u>reusability</u> as we could now render this cell just anywhere in our app - as long as the input is the same, the output will be identical. Don't even think about that with global helpers and partials.</li>\n<li>The interface drastically improves testability. Again, since we can render this cell isolated in a test and assert the rendered markup, the cell will work in any environment that provides proper input.</li>\n<li>Interfaces make us think. The cell is expecting input and you have to provide it. This makes you question how and especially <u>where</u> data is collected. Suddenly, there are more places than a clumsy controller and confusing helper functions. It feels more natural, as a cell can be a mini-controller in the real sense of <u>MVC</u>.</li>\n<li>Interfaces also help you understand. Even though I've seen <q>clean</q> nested helper/partial constructions that pass locals, they still access global instance variables somewhere, making it incredibly hard to understand dependencies. Cells require explicit arguments, there simply <u>is</u> no global state.</li>\n<li>The view architecture Cells encourages also makes it easier to spot bottlenecks in rendering. Now that you model your UI in nested widgets instead of nested helper calls and partials, you can easily turn caching on and off or disable certain parts of the UI.</li>\n</ul>\n\n\\n\n\n<p>When I begin encaspulating parts of my UI into cells, I always do the bottom-top approach: I start with the smallest component possible and see how far I get. Then, I might add a container cell to wrap the smaller components. Here, we'll start writing a simple cell that represents one of those grid items displaying one particular thing.</p>\n\n\n;;;\n\n<p>Currently, one box shows the thing title, links to the actual thing page and displays the date when it was first created.</p>\n\n<p>When adding cells, first thing I do is render the cell in the view. Once it looks good, I write a test. This is more motivating, test-first is good for unit tests, with an UI component it is legit to test it visually first, then add automatic testing step-wise.</p>\n\n<p>The root path of our app currently links to the <code>HomeController</code> and in the <code>index.html.haml</code> view, I render our first cell. Are you excited?</p>\n\n\n;;;\n\n<p>Cells packaged in a Trailblazer concept are rendered using the <code>concept</code> helper. I already made fun about the irony of a helper rendering a cell in chapter two. You could invoke the cell manually here but the <code>concept</code> helper is handy. All it does is find the cell class by constantizing the first argument. This will result in a class lookup for <code>Thing::Cell</code>. It then instantiates this cell and passes in the remaining arguments and invokes the cell's <code>show</code> method.</p>\n\n<p>So, the <code>concept</code> call basically gets translated to something along this.</p>\n\n\n;;;\n\n<p>This is not 100% what happens, but it helps understanding the workflow when rendering a cell. We'll learn more about different call styles in later chapters.</p>\n\n\\n\n\n<p>Ok, invoking a cell means a class is instantiated and a method on the instance is called. So let's have a look at that cell class which you can find in <code>app/concepts/thing/cell.rb</code>. When writing a cell for a concept, I start with a file <code>cell.rb</code> in the concept's directory and implement the code there. However, you're free to apply your own naming style or directory structure. You can have as many cells per concept as you feel like and we're going to use a bunch of cells in this book.</p>\n\n\n;;;\n\n<p>Again, I put the cell in the <code>Thing</code> namespace, and, again, this does absolutely not bind the cell to ActiveRecord, even though <code>Thing</code> is an ActiveRecord subclass. This is purely structuring.</p>\n\n<h3>Explicit Rendering</h3>\n\n<p>As you can see, the <code>show</code> method does nothing else but calling <code>render</code> (line 3).</p>\n\n<p>In Cells, rendering is explicit, you <u>have</u> to call it, there's no magic rendering as found in Rails controllers. Another difference is that <code>render</code> really returns the HTML string. While this is additional code you have to write, this allows you cool stuff like directly returning strings from a cell method, or concatenating views.</p>\n\n\n;;;\n\n<p>In the many years of working with Cells, ten-thousands of users have agreed that the effort of having to add <code>render</code>, which is incredible six more characters, does absolutely justify the flexibility you gain. For instance, many users call render, filter or add wrappings and then return the string.</p>\n\n<p>Anyway, what exactly happens when call <code>render</code>? You guessed right, this will look for a view in <code>app/concepts/thing/views/show.haml</code>, parse it and return the view string.</p>\n\n<p>Note that we don't have view names like <code>show.html.haml</code> anymore. Per design, a cell doesn't know about the request format and whether or not we're supposed to render JavaScript templates or HTML. In Cells, different UI formats are handled with different cells. Again, I want to discuss that in later chapters.</p>\n\n<h3>Logicless Views</h3>\n\n<p>Cell templates can be any format supported by Rails, or, to be precise, <a href=\"https://github.com/rtomayko/tilt\">Tilt</a>. In Cells 4, we replaced ActionView with our own implementation that uses the great Tilt gem to render templates. This not only speeds up rendering but also reduced rendering code to a few lines.<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup></p>\n\n<p>I chose Haml because I like <a href=\"https://twitter.com/hcatlin\">Hampton</a> but you can use ERB or Slim or whatever you feel like.</p>\n\n<p>Now, looking at the view you'll see that there's no big difference to the views known from vanilla Rails.</p>\n\n\n;;;\n\n<p>Ignoring all the markup noise we need to make it look good with Foundation, what matters here is that we can access the <code>Thing</code> instance this cell wraps using the <code>model</code> method in the view (line 3 and 5). This is why cells are also called <u>view models</u> since they wrap a model (or any kind of object) in order to present it in a user interface.</p>\n\n<p>We also still have access to the wide range of Rails view helpers like <code>link_to</code>, as it seems (line 3).</p>\n\n<p>An interesting thing to note here is that neither <code>model</code> nor <code>link_to</code> are helpers anymore that got copied from the controller into the view. They are both instance methods defined in the cell class itself.</p>\n\n<p>In fact, every method call in the view will be called on the cell <u>instance</u>.</p>\n\n<p>This is a fundamental change to the way Rails handles views. In Cells, the concept of <q>helpers</q> does not exist anymore. The handy Rails helpers are still available, but these are all instance methods of the cell class.</p>\n\n<p>What does that mean for us now? We could simplify the view to the following beautiful asset.</p>\n\n\n;;;\n\n<p>This is the kind of view we're gonna create throughout this book: no logic, no complexity and a well-defined interface. Instead of adding complexity to the view, we call two new methods <code>name_link</code> and <code>created_at</code> (line 3 and 5).</p>\n\n<h3>Helpers</h3>\n\n<p>We cleaned up the view and move logic back to the cell class. The two newly introduced methods that we call in the view need to be implemented as instance methods.</p>\n\n\n;;;\n\n<p>As a good object-oriented citizen, I try to expose as few public methods as possible for each class - following my understanding of the <u>Single Responsibility Principle</u>. This also applies to cells! And for that reason <code>show</code> is the only public method for now.</p>\n\n<p>The methods we invoke in the view don't need to be public, the view is executed in the cell's instance context. Even though I know that they are only <q>helpers</q>, I make the new methods <code>name_link</code> and <code>created_at</code> private. This is both me being a stringent interface supporter and to stress the fact that <code>show</code> is really the only public method being called by the cell user on the outside.</p>\n\n<p>It indicates a good object design when marking as many methods as possible as private - ideally, you have one public method per class.</p>\n\n<p>In both new methods I simply moved the old invocations from the view into a method body. The cell class itself provides Rails view helpers like <code>link_to</code> so we can use them in instance methods. Note that not all helpers are available in cells per default. You need to include the missing modules into the class when you need more helpers.</p>\n\n<p>Exposing helper code as instance method brings another benefit. You don't have to make them private if you want to reuse them. You can have as many public methods in a cell as you want. This gives you an object-oriented helper class that is incredibly simple to use and test.</p>\n\n<h3>Properties</h3>\n\n<p>Cells, or view models, are designed to wrap arbitrary objects. Exposing properties from the decorated object is a fundamental concept of a view model. In our example, we don't need to write a delegator for <code>created_at</code>. A declarative delegation mechanism is is built into Cells.</p>\n\n\n;;;\n\n<p>Using <code>property</code> will create the delegation for us and saves typing. Internally, <code>property</code> simply defines the method <code>created_at</code> in the cell class almost exactly as we did it manually a few minutes ago.</p>\n\n<p>This technique is also helpful for renaming properties and to work with compositions of objects, hash attributes, and more. The property method is a concept found in all my gems and we'll learn how they support you with all kinds of data structures in later chapters and when discussing the Disposable gem.</p>\n\n<h3>Using the Timeago Helper</h3>\n\n<p>So far, we display the raw <code>created_at</code> timestamp in the view. That doesn't look good. The Timeago gem provides a cool helper that makes every timestamp readable for humans. I'm sure every one of you has seen that before, instead of saying <q>25/12/2014</q> it will render something like <q>two days ago</q>. Let's use that in our cell!</p>\n\n<p>You can check this chapter's branch and how the Timeago gem is bundled into your application. In order to use it in the cell, the helper module needs to be included. This usually happens automatically in ActionView and that is why we have to do it manually in a cell. Remember, a cell explicitly does <u>not</u> want to be polluted with all kinds of helpers.</p>\n\n\n;;;\n\n<p>The <code>Timeago</code> helper relies on Rails' <code>DateHelper</code> so we need to include that in the correct order. This is not Cells being clumsy, this is Rails' lack of view architecture and third-party gems assuming that they automatically have access to hundreds of global functions.</p>\n\n<p>Including this helper adds a new method <code>timeago_tag</code> to the cell class and we're ready to use it.</p>\n\n\n;;;\n\n<p>So what am I doing? I override the <code>created_at</code> method that has already been defined when calling <code>property :created_at</code>. In that new method, I use the <code>timeago_tag</code> helper to render the human-readable string (line 5). By invoking <code>super</code> I call the <q>original</q> method <code>created_at</code> that is delegating to <code>model.created_at</code> and provides us with the timestamp.</p>\n\n<p>I do this for two reasons. I could have just introduced a new method <code>created_at_formatted</code> that internally calls <code>created_at</code> and passes it to the Timeago helper. However, I didn't want to change my view and the method name. The second reason is, my plan is to demonstrate Ruby's OOP features as much as possible in this book. We will meet <code>super</code> again very soon.</p>\n\n<hr>\n\n<p>Again, please note how Cells makes it as simple as possible to move logic out of the view into a real, physical class. Helpers are now instance methods of a scoped object and not a global ActionView object where helper methods need to be copied from the controller into the latter instance.</p>\n\n<p>By changing the view context to the cell itself, no weird copying or including of methods happens in Cells between the <q>controller</q> and the view. This is a learning from playing around with ActionView for years and the frustration that came with it.</p>\n\n<p>Let's quickly sum up what we did so far.</p>\n\n<p>In the main view we invoke our cell. This instantiates a cell object and calls its <code>show</code> method which in turn renders a private view. The view grabs data by calling methods back on the cell. Rendering additional markup and calling helpers again happens via the view model. Any logic required in the view lives in the cell.</p>\n\n\\n\n\n<p>Originally, we wanted to render a maximum of nine things on our home page. We have three ways to do this. The home view could simply iterate the list of things and call <code>concept</code> for each item. We could also write another cell that renders all items internally. This is helpful for advanced caching and logic.</p>\n\n<p>The last and simplest is to use Cells' ability to render collections directly, and worry about everything else later. Let's do that for now and explore nested cells in a bit.</p>\n\n<p>Rendering a collection of cells works by using the <code>concept</code> helper, similar to what you're used from rendering collections of partials.</p>\n\n<p>The <code>app/views/home/index.html.haml</code> view just needs a tiny change to render more than one cell.</p>\n\n\n;;;\n\n<p>That was simple, wasn't it? Calling it with the <code>:collection</code> option is enough to make the <code>concept</code> helper render a cell for each thing in the array (line 5).</p>\n\n<p>As always, Trailblazer's API is explicit and doesn't guess. If you want to render a collection you need to speak out. This helps preventing <q>misunderstandings</q> as we all know them from Rails, where helpers use <code>is_a?</code> and other inflection methods to guess what you want to do. Explicit will always win over magic. There's no point in saving a few characters of code while sacrificing our code stability.</p>\n\n<p>Since <code>Thing.latest</code> returns the last nine things from the database we're good to go.</p>\n\n<p>There was one more requirement we need to implement, though. If there's less than nine items, the grid needs to know what cell is the last item to make it look neat and properly aligned.</p>\n\n<h3>Layout Helpers</h3>\n\n<p>What's happening now is that each cell has to check whether or not it's the last one. If yes, the class <code>.end</code> has to be added to the cell's <code>.columns</code> div. This is a foundation-specific thing I learned by reading the manual!</p>\n\n<p>First, we need to tell the cells what's the last item. This goes into the index view of our <code>HomeController</code> for now. Yeah, this is code in the view but we're gonna clean it up later.</p>\n\n\n;;;\n\n<p>As you've already seen, I add another option <code>:last</code> to the cell rendering call where I pass in the last item of the things collection. Note that <code>:last</code> is a generic option and Cells doesn't know about it until we make it aware of this.</p>\n\n<p>That means we have to program this <q>layout helper</q> on our own. However, Cells makes that fun! Since we have to set CSS classes in the cell view, I change the view code slightly. This is back in the <code>Thing::Cell</code> and its  view <code>app/concept/thing/views/show.haml</code>.</p>\n\n\n;;;\n\n<p>What I do now is I no longer pass all the classes statically to the top div but I use a HAML options hash. In that hash, I call the <code>classes</code> method that provides the required CSS classes (line 1).</p>\n\n<h3>Additional Cell Options</h3>\n\n<p>Remember, any method called in the view is delegated back to the cell, so let's implement this.</p>\n\n\n;;;\n\n<p>While I always add the <code>large-3</code> and <code>columns</code> class, the <code>end</code> class is only pushed onto the class stack when the current cell instance wraps the last model. By comparing the cell's <code>model</code> with the <code>:last</code> option we pass into the collection rendering I'm able to find out whether or not the cell is the last (line 5).</p>\n\n<p>I should note that additional options passed to the <code>concept</code> call are passed to <u>all</u> rendered cells and made available via the <code>options</code> method (line 5). This is extremely helpful to pipe generic configuration to one or multiple cells as this works with collections and when rendering a single cell.</p>\n\n<p>Assuming we'd invoke a cell as follows.</p>\n\n\n;;;\n\n<p>We can now access the additional options in the cell via the <code>options</code> method.</p>\n\n\n;;;\n\n<hr>\n\n<p>Allowing to pass arbitrary configuration into cells, modeling cells around domain and data objects and moving view code into a separate layer, the cell class, introduces a new thinking of how to write views.</p>\n\n<p>When using Cells, developers have continously reported that view models feel more natural and the encapsulation does absolutely not block them from a rapid development of features. The opposite is the case. It not only gets easier to reuse components in other pages of your application, it also simplifies rock-solid tests for widgets.</p>\n\n<p>Speaking of tests - why not write some assertions to make sure our cell really does what we want?</p>\n\n\\n\n\n<p>In a vanilla Rails setup it is impossible to test view components in isolation. That is because view components do not exist. Writing tests for dashboards or overview pages like the one we just did happens via integration tests that render the entire page.</p>\n\n<p>This is good on one hand. A full-stack test makes sure everything really works and allows simple HTML assertions in order to do so. However, on the other hand, if we decide to move the view component, we need to move the test. Also, integration tests are slow and clumsy as they require a lot of setup that is not really related to our widgets.</p>\n\n<p>I want to show you both ways now. Let's write an integration test and then test the cells in isolation. I usually write full-on tests that cover edge-cases with encapsulated cells tests. Asserting the entire page works happens with a very simple integrational smoke test - similar to how we did it for operations and controllers.</p>\n\n<p>By demonstrating both ways you can decide yourself how to handle this task.</p>\n\n<p>Check out the integration test in <code>tests/controllers/home_controller_test.rb</code>.</p>\n\n\n;;;\n\n<p>In the first two lines I create our things fixtures. Note how we do that with operations. A major goal of Trailblazer is to not use leaky ActiveRecord-based factories anymore. But I said that twice already.</p>\n\n<p>I then grab the home page (line 6) and assert that both thing cells were rendered properly. I am not good with CSS selectors, so I make sure that there's only one <code>.end</code> class, and this has to be on the oldest thing which is called <q>Trailblazer</q> (line 10). Remember, the thing cells are rendered in reverse order.</p>\n\n<p>By asserting that there's only one <code>.end</code> class we excplicitely say that the most recent thing <q>Rails</q> doesn't have this class. That is correct since only the last cell in the grid should render this class.</p>\n\n<p>Full-stack tests like this are extremely slow and that doesn't have to be! We can test the cell in isolation and just write a smoke test for the controller instead of a full-blown integration test.</p>\n\n\\n\n\n<p>The cell test goes to <code>test/concepts/thing/cell_test.rb</code> as I often group several cell tests into one file. A cell test gives us the same API that we use when rendering a cell.</p>\n\n<p>Another cool feature is that Cells automatically provides Capybara tests if this beautiful gem is installed. Let's have a look.</p>\n\n\n;;;\n\n<p>Markup content in a cell test can be rendered just as we know it from views or controllers, using the <code>concept</code> helper (line 7). The returned string is ready to be used with Capybara matchers, which makes it very simple to test selectors and content.</p>\n\n<p>The rest of the test is basically identical to the integration test and makes sure classes are assigned properly (line 10-12).</p>\n\n<p>One thing to mention is that I use <code>controller ThingsController</code> to configure a controller that needs to get passed into the cell (line 2). This is unfortunate, and while the cell is completely decoupled from Rails, the URL helpers from Rails need a controller dependency to operate properly. By configuring what is gonna be the <q>parent</q> controller, the helpers will work.</p>\n\n<p>Given that we assert rendering details in the cell test now, I'd convert the integration test into a smoke test. I want to talk about that a bit later, though.</p>\n\n<p>One thing I absolutely hate about this test we just wrote is that it replicates a lot of logic from the controller view.</p>\n\n\n;;;\n\n<p>This is a classic source of bugs: even though it's <q>only</q> a collection we pass into that <code>concept</code> call, and we <q>only</q> specify the <code>:last</code> parameter, this will break at some point. Currently, we're assuming the caller knows the entire API of our cell which consists of a very special <code>:collection</code> and the <code>:last</code> option that has to be set properly.</p>\n\n\\n\n\n<p>There's two ways to cope with this. We could either wrap the entire <code>concept</code> call into a helper, but then we'd have to write an ugly helper test. Or, and that is the way to go, we encapsulate all knowledge about how the things grid works in another cell. Another cell that composes the grid.</p>\n\n<p>This might sound like a bit of overhead now, but as soon as we hit problems like displaying search results, caching and performance techniques in later chapters, we will learn why this was a good choice.</p>\n\n<p>In order to replace the quite complex cell invocation code with something simpler, we need to go to the controller view <code>app/views/home/index.html.haml</code>. I change this file as follows.</p>\n\n\n;;;\n\n<p>Instead of collecting the latest things in the view and invoking the collection rendering, all I do now is calling the new cell <code>Thing::Cell::Grid</code>. No data is passed into that cell - and this in turn means the cell itself needs to accumulate necessary objects.</p>\n\n<p>To understand what's going on here we need to look into <code>app/concepts/thing/cell.rb</code> and inspect the new cell class.</p>\n\n\n;;;\n\n<p>The new <code>Grid</code> cell is nested into the original cell's namespace, resulting in a fully-qualified class name <code>Thing::Cell::Grid</code>. This might seem counter-intuitive as the grid cell renders the container cell, but is physically nested in the inner cell class.</p>\n\n<p>Don't get confused! Similar to the way we nest operations in models, this doesn't create any dependencies between the classes. To me, the grid cell is a feature added on top of the existing code, that's why I stuff it into the existing cell's namespace.</p>\n\n<p>The grid cell is simply a stand-alone class derived from <code>Cell::Concept</code> (line 4). All we did was implementing the <code>show</code> method and copy the code from the controller view into that very method (line 6-7). Note that you can easily render cells in other cells by using the <code>concept</code> helper (line 7).</p>\n\n\\n\n\n<p>The logic to aggregate the most recently added things is now located in the new grid cell.</p>\n\n<p>And this is another shift in the classy Rails architecture. You might wonder whether or not it's ok to let a view component collect data. Shouldn't that be done in the controller? And you're right! The view shouldn't know about how data is collected.</p>\n\n<p>However, a cell <u>is</u> a controller itself. Unlike Rails helpers, a view model is a real MVC component featuring a self-contained controller that renders a view. It is our decision as software designers whether we push data-collecting logic into a cell or let the HTTP controller or an operation take care of this.</p>\n\n<p>In our case, this is a purely view-related issue. The grid is a UI feature that is most probably not included in a document-based HTTP API. For that reason, we can safely move all logic into the cell.</p>\n\n<p>Always ask yourself: is the logic needed in two places, namely the UI and the HTTP API? Then, code needs to be made reusable in either a twin, a PORO or an operation. However, if it's solely used in the web user interface, this code can be placed directly in a cell.</p>\n\n\\n\n\n<p>Now that we have a container widget in place to hide implementation details from the caller, we can adjust our cell tests. For now, I consider the <code>Thing::Cell</code> class a private view model. In our application, the only public entry point for rendering things is <code>Thing::Cell::Grid</code>, so let's adjust our cell test.</p>\n\n\n;;;\n\n<p>This is the same test as before, the only thing that changed is that we invoke the <code>Grid</code> cell now (line 9).</p>\n\n<p>After asserting all eventualities for the grid cell, we no longer need to do that in the <code>HomeController</code> test. As promised earlier, this get degraded to a simple smoke test.</p>\n\n\n;;;\n\n<p>The smoke test makes sure the cell is included and rendered, nothing else matters.</p>\n\n\\n\n\n<p>The Cells gem comes with two helpers to invoke cells, both implement their own style and have a slightly differing naming convention.</p>\n\n<p>Throughout this chapter, we used the <code>concept</code> helper which is made to render cells derived from - surprise! - <code>Cell::Concept</code>. Concept cells have a self-contained file structure and follow Trailblazer conventions.</p>\n\n<ol>\n<li>You need to specify the full path to the cell class in the helper call, e.g. <code>concept(\"thing/cell\")</code>, as the helper does not infer constants and does not know about any naming conventions.</li>\n<li>Also, views in concept cells are structured the Trailblazer style. They sit in the concept's view directory. For instance, <code>app/concepts/thing/views/</code> will contain all views for a concept - unless you introduce sub-directories for a finer structure.</li>\n</ol>\n\n<p>In contrast to this style is the <code>cell</code> helper. Here, the class has to be a <code>Cell::ViewModel</code> subclass. Usually, the class name is suffixed with <code>Cell</code> resulting in something as follows.</p>\n\n\n;;;\n\n<ol>\n<li>The helper will automatically add the <code>Cell</code> suffix and allows to be invoked like <code>cell(:thing)</code>.</li>\n<li>Views and the actual view model class are put in the application's cells directory. For instance, <code>app/cells/thing_cell.rb</code> would contain the class and views would sit in <code>app/cells/thing/</code>.</li>\n</ol>\n\n<p>Personally, I am not using the <code>cell</code> style anymore as I find the Trailblazer concept-style better encapsulated. Also, the naming with concept cell is more appealing: <code>Thing::Cell</code> to me makes more sense than <code>ThingCell</code>. This book exclusively uses the Trailblazer style.</p>\n\n\\n\n\n<p>Encapsulating view code into view models is a good thing. Although I usually recommend people not to put everything into cells, I have never seen a cell that was <q>overkill</q>. View code quickly grows and gets more complex. A cell class cleanly abstracts that and forces you to define interfaces.</p>\n\n<p>In this chapter we implemented a neat view component to display a thing summary with link and other necessary data. By introducing a container cell, we hid data aggregation from the caller. This gives us an easily testable, rock-solid application component that brings reusability for free.</p>\n\n<p>In later chapters we will revise the cells we just wrote and learn about caching, view inheritance, and polymorphic views.</p>\n\n<p>The following chapter will go back to the domain layer. We're gonna build more operations, and forms with nested models.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>Again, I offer to spend a chapter to discuss the Trailblazer gems and their source code, if there's enough interest in the community. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>In this fifth chapter, I want to talk about Reform and the way it handles nested models. Forms can represent deeply nested object graphs. I want to create several, partly unrelated models via one grouping operation and via one form, and this is what we're going to learn in the next half hour.</p>\n\n<p>Forms are an integral part of every user interface, user interfaces used by human beings. Visual forms are quite different to the way machine-operated APIs work. Rails tries to merge those two concerns in controllers, and we're going to see how Rails' <q>RESTfulness</q> breaks down as soon as you add supplementary usability to a page.</p>\n\n<p>To demonstrate the misconception, this chapter will go the Rails Way and use nested resources following the limited CRUD mentality. Of course, this is not what I want, as this reduces the user experience to one form per page, with forms that solely represent database tables. This has nothing to do with <u>usability</u>. Nevertheless, this is what happens when you follow Rails' CRUD conventions.</p>\n\n<p>In chapter 6, we restructure our UI and put the comment form where it should be in the first place: embedded in the thing page! Luckily, this is gonna be really simple as Trailblazer's design encapsulates workflows in operations and forms.</p>\n\n<p>The code for this chapter is <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-05\">available here</a>.</p>\n\n\\n\n\n<p>Our next milestone in Gemgem is to add <u>comments</u>. Users want to talk about things, so we'll focus on building the <code>Comment</code> concept in this chapter.</p>\n\n\n;;;\n\n<p>Following the Rails Way, given that we already had a <code>Comment</code> model, we start knocking together a <code>CommentsController</code> that allows creating or updating comments. This is a great convention. However, it is the opposite of user-friendliness.</p>\n\n<p>The form to create comments will be on a separate page. That feels weird. I'd love to have the comment form right in the thing page, so when I visit, say <code>things/1</code>, I can instantly comment. Instead, creating comments goes onto a stand-alone page and the form is accessible via <code>things/1/comments/new</code>.</p>\n\n<p>Rails requires you to nest <q>resources</q><sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup> to define that the inner resource is dependent on the outer one. This is the case, as every comment needs a thing that it belongs to. Here's how <code>config/routes.rb</code> will get extended.</p>\n\n\n;;;\n\n<p>At this point, I clearly have to state that I usually hate nested resources. They overcomplicate URLs, expose your database layout to your endpoints and create dependencies where they don't need to be. Wait for chapter 6, though, until we fix this.</p>\n\n<p>When accessing the new comment form via <code>things/1/comments/new</code> this will be routed to the new action <code>CommentsController#create</code>. This is what's called <q>RESTful</q> in Rails. Let's see how the controller looks like.</p>\n\n<h3>The Controller</h3>\n\n<p>In order to render the form for comments, we will use our old friend <code>form</code> and a standard controller view for now.</p>\n\n\n;;;\n\n<p>By calling <code>form</code> I instruct Trailblazer to setup the <code>Comment::Create</code> operation and its form, both assets we're gonna implement in a minute (line 5). Recall that <code>form</code> will assign <code>@operation</code>, <code>@form</code> and the two identical <code>@model</code> and <code>@comment</code> variables. Yes, the model is aliased with a named instance variable. We'll make use of that in chapter 6.</p>\n\n<p>Now, why am I putting logic into the controller and assign this <code>@thing</code> object (line 3)?</p>\n\n<p>To compute the URL for our form, we need a reference to the outer <q>resource</q>, too. One of the many problems nested resources create is <u>dependencies</u>. Even though this is purely UI-related logic, and we only need this instance variable in the view for URL generation, this feels wrong. Anyway, bear with it for this chapter, we will fix it very soon.</p>\n\n\\n\n\n<p>The next step we have to do is adding the comment concept in <code>app/concepts/comment</code>. As we know already, this is where all the code for this part of the application goes.</p>\n\n<p>In the first draft of this new feature, a comment with text and a weight can be created. The weight qualifies the comment as either positive or negative feedback. This is a business requirement in Gemgem, as every input must be automatically interpretable.</p>\n\n<p>Along with the comment we save an email address. At this early stage of the product, we don't have signed in users, but we already grab their email address.</p>\n\n<p>Technically, I already know that we will have <u>users</u> at some point, so creating a comment implies the creation of an associated user.</p>\n\n<h3>Comment and User model</h3>\n\n<p>On the persistence layer, I add two new tables, <code>comments</code> and <code>users</code> along with matching models.</p>\n\n\n;;;\n\n<p>Empty ActiveRecord classes make me happy. This model only contains associations, which is valid according to the Trailblazer specification.</p>\n\n<p>It might help to see the generated schema for the <code>comments</code> table.</p>\n\n\n;;;\n\n<p>Comments have a <code>body</code> which is the text, or the actual comment. They maintain a <code>weight</code> field and also have a <code>Thing</code> they belong to and are authored by one particular <code>User</code>.</p>\n\n\n;;;\n\n<p>The only relevant column in the <code>User</code> table is a text field named <code>email</code>.</p>\n\n<p>This persistence configuration is sufficient code to get comments running in this chapter.</p>\n\n<p>I am really happy that the ActiveRecord developers do such a good job and allow decoupling persistence and domain logic without major problems. And as we can see, it is really not that hard to maintain logicless models, once you make use of Trailblazer's additional abstraction layers.</p>\n\n<h3>Comment Operations</h3>\n\n<p>In order to create comments, nothing makes more sense than to start with the <code>Comment::Create</code> operation. The operation code will go into <code>app/concepts/comment/operation.rb</code>.</p>\n\n\n;;;\n\n<p>As always, the concept operations get nested into the model's namespace. By using the <code>Model</code> module and configuring it, the operation knows that it is supposed to create a brand-new <code>Comment</code> instance when its run (line 3-4).</p>\n\n<p>The <code>process</code> method is almost identical to the one from the <code>Thing</code> operation. Nothing special is happening here, yet, unless you still find the validation of input followed by a model save fascinating. I do (line 6-10).</p>\n\n\\n\n\n<p>What might raise your awareness is the <code>setup_model!</code> method. We haven't met this helpful guy before. You might recall that a comment is always associated to a thing. That in turn means somewhere in the operation this relation must be specified.</p>\n\n<p>The <code>setup_model!</code> method is the perfect place to prepare your model before it gets validated. This hook is run directly before <code>process</code> is invoked, but after the generic model was created, making it the ideal location to add or change attributes of the CRUD model. In case you're interested, check out <code>Operation#setup!</code> where all the prepping happens.</p>\n\n<p>Since <code>model</code> is already available, I simply assign the comment's <u>thing</u> (line 14). The ID of the nesting thing is to be found in the parameters <code>:thing_id</code> field. This is an interface requirement to the operation user. It means the user has to provide that ID in any case, otherwise the operation will raise an exception that it couldn't find the <code>Thing</code> instance.</p>\n\n<p>This is why I use the <code>thing=</code> setter. I could also use <code>thing_id=</code>, but this will make sure a valid thing ID comes in the <code>params</code> hash.</p>\n\n<p>Be careful, though, with the <code>setup_model!</code> method when you write operations that handle both forms and documents like JSON. In the latter, the only available <code>params</code> key might be <code>:id</code>. If you rely on other data, make sure the controller provides necessary data for all formats in the <code>params</code> hash. Data from the incoming document is only available from the <code>validate</code> call onwards. But we'll talk about that in the API chapters.</p>\n\n<p>As a side note, I started using bang-ed method names (e.g. <code>setup_model!</code>) for public hooks to signalize that their return value is irrelevant. This means you have access to a range of documented object properties, like <code>model</code>, but don't have to return anything.</p>\n\n\\n\n\n<p>Let's talk about the last bit of our new operation now: the contract.</p>\n\n\n;;;\n\n<p>Every comment has a text <code>body</code>, a <code>weight</code>, and a related <code>thing</code> (line 2-4). I add some boring constraints, for example, the comment body can only be 160 characters maximum (line 6-8). This is not a restriction, but a motivational factor as people don't feel urged to write a complete review.</p>\n\n<p>An interesting validation is the <code>presence</code> requirement for <code>thing</code> and <code>user</code> (line 8). This validation doesn't know about associations, all it checks is if both fields are present - whether that is a boolean or a <code>Thing</code> instance the validation doesn't care. We will learn about high-level model validations later.</p>\n\n<p>Nesting additional declarations into a <code>property</code> block creates a nested form. Reform now expects and handles nested input for the <code>user</code> sub form (line 10-13). In Reform, this is called <u>nested form</u> or inline form, as it is defined within an existing form class. Please note that you can define properties, validations and methods in that block. The block will simply be executed in a separate form class, making methods only available in the nested scope.</p>\n\n<p>Nested forms are a great way to map multiple models to one visible form and run their validations together as a group. Even though the <code>Comment--&gt;User</code> relationship here is a 1-to-1 mapping on the persistence layer, we will learn that a nested form is absolutely not limited to <code>belongs_to</code> and <code>has_many</code> relationships between models.</p>\n\n<p>Instead, it doesn't even know about those implementation details. All a nested form cares about is composed objects. Those objects can be models, compositions, or separate objects as we'll see at the end of the next chapter.</p>\n\n<h3>Rendering the Comment Form</h3>\n\n<p>We have a controller action and an operation along with a form object in place. Now, let's see how the controller view rendering the form looks like.</p>\n\n<p>To display the comment form I simply hack this form into the comments controller's view at <code>app/views/comments/new.html.haml</code>.</p>\n\n\n;;;\n\n<p>In order to compute a URL for the nested comment, Rails requires two objects: the outer thing and the nested comment, which is represented by our form object (line 1). This is a clear drawback of nested URLs. The more you nest, the more objects you need for URL generation.</p>\n\n<p>I then instruct simple_form to render a text area for the <code>body</code> property and render the two radio buttons for the weight in the clumsiest way possible (line 2-4).</p>\n\n<p>The nested <code>user</code> form is best rendered using <code>fields_for</code> (line 6-7). All this helper does internally is calling <code>@form.user</code>, which returns the nested form object. It then does its convoluted magic to render the nested fields. I believe the <code>fields_for</code> helper implementation could be improved, but for now it helps, and that's why I use it here.</p>\n\n<hr>\n\n<p>Browsing to a nested URL of an existing thing will show the form to add a comment. For example, if I browse to <code>things/1/comments/new</code>, an extremely inconvenient URL in my opinion, I can see the form to add a comment!</p>\n\n<p>After the first boost of excitement has settled, we'll face a severe disappointment, though. While the comment form is visible, the nested user form is <u>not rendered</u>!</p>\n\n\\n\n\n<p>We have just encountered a feature in Reform that has caused a bunch of confusion in the community. Understanding why the nested user form is not rendered is crucial to understand what Reform really is: a form object, and nothing more. Now, why is the nested form not rendered?</p>\n\n<p>The answer is very simple. The <code>Comment::Create</code> operation instantiates an empty <code>Comment</code> instance for us. We add the associated <code>Thing</code>, but we do not add or relate a user to it. This boils down to the following behavior.</p>\n\n\n;;;\n\n<p>That is no magic at all. Not adding a user when creating the comment will result in an empty <code>user</code> property. I need to talk about how Reform populates itself in the initializer, now. After having discussed that, you will understand why there is no way for Reform to <q>guess</q> that it's supposed to display an empty, nested form for a non-existent object.</p>\n\n<h3>Reform's Population in Setup</h3>\n\n<p>Populating the form is run directly after the form got instantiated. As always, the initializer requires you to pass in a model that will be wrapped by the form. Creation of the form is hidden from you by the <code>Comment::Create</code> operation, however, it roughly works like the following code.</p>\n\n\n;;;\n\n<p>The main task of the form's initializer is populating the form with values from the wrapped model. This is called <u>setup population</u>, for the interested readers, this happens in <code>Reform::Form::Setup</code>.</p>\n\n\n;;;\n\n<p>Reform copies initial values from the model to the form. This is to create an indirection between the model and the form user, which can either be a reading form builder when rendering, a read-only validator, or a writing controller/operation when assigning incoming input to the form.</p>\n\n<p>The whole purpose of the form object is to <u>not</u> let form builders, validators and writers access the model.</p>\n\n<p>Copying attributes from the model happens by calling readers on the model. As you can see in the beautiful diagram, Reform simply invokes <code>comment.body</code>, <code>comment.weight</code>, and <code>comment.user</code> to do that (1). In a new form, this will normally return emtpy values, but it starts to makes sense in an editing form.</p>\n\n<p>Usually, calling <code>comment.user</code> will return an object. In that case, Reform will automatically instantiate a sub form to represent that nested model. This composed form will then run its own setup workflow, again (2).</p>\n\n<p>In our current environment, <code>comment.user</code> is empty. This is why Reform ignores this property: no nested form is built!</p>\n\n<p>The missing detail now is the form builder. When calling <code>fields_for :user</code> it queries the form object for its <code>user</code> form. This does not exist, so the form builder will skip rendering that. And here we are again.</p>\n\n<h3>Setup Population via Reform</h3>\n\n<p>In order to make this nested form getting rendered we somehow need to create an associated <code>User</code> object. There are two ways to pre-populate the form. Let's explore the hard way first, as this is an occasion to discuss some interesting features of Reform. I will then show you how to solve this particular situation with a simple one-liner.</p>\n\n<p>Reform comes with an option <code>:prepopulator</code> that is designed to solve the above dilemma: pre-populate the form before it's rendered.</p>\n\n\n;;;\n\n<p>This creates a new <code>User</code> model and assigns it to the form. Using the form's <code>user=</code> writer makes sure a nested form is created, attached, and wraps the model accordingly. In a prepopulator, always make sure to use the form's public API to add models.</p>\n\n<p>Note that the user is not associated to the comment object, per default. This is unnecessary for rendering.</p>\n\n<p>When designing the pre-population hook in Reform I had to be careful. You can't simply run this automatically in the constructor of the form. This would work for form rendering, but blow up when <u>validating</u> incoming input. We will speak about this in a minute.</p>\n\n<p>That being said, the pre-population logic has to be run manually before the form gets rendered. Here's a snippet to illustrate how that could look like.</p>\n\n\n;;;\n\n<p>By invoking <code>prepopulate!</code> the defined callbacks are run and pre-populate the form. Luckily, you don't have to call <code>prepopulate!</code> manually in Trailblazer. This is implicitely run in the <code>Controller#form</code> helper, as this is the place where the form get rendered.</p>\n\n<hr>\n\n<p>When browsing back to the new comment page, the nested user form gets rendered, and we're able to fill in an email address of the commentor! Hooray, we're ready to speak about the processing, now.</p>\n\n\\n\n\n<p>Per convention, when submitting the form this will POST parameters to <code>/things/1/comments</code> and this, in turn, gets routed to the <code>CommentsController#create</code> action.</p>\n\n\n;;;\n\n<p>This action is far from finished, but it will create and run the <code>Comment::Create</code> operation, instantiate the form object and run the form's <code>validate</code> method passing in the input from the submission.</p>\n\n<p>We'll refine the controller action pretty soon. However, this is all we need to run into the next problem nested forms yield. Well, let's not call it <u>problem</u>, it's more of a thing we have to understand in order to fully exploit the power of nested forms.</p>\n\n<p>What did we get done so far? We have the comment form on its own page. When clicking <q>Submit</q>, it gets send to a processing action <code>create</code>. That is pretty exciting.</p>\n\n<p>Now, what happens when we click submit for real? Oh no! Another exception! This time, Reform complains that it doesn't know how to deserialize incoming data in <code>validate</code>. What is going on this time?</p>\n\n\\n\n\n<p>When we <code>run</code> the <code>Comment::Create</code> operation in the <code>create</code> controller action, the internal form is instantiated, again. And again, we pass in an empty <code>Comment.new</code> instance which was created by <code>Model</code>. So far, so good.</p>\n\n<p>We already talked about the <code>run</code> helper, so you're aware that this will internally invoke the <code>validate</code> method on the operation's form while passing in the respective <code>params</code> hash. In the operation, this results in a call as follows<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n\n;;;\n\n<p>First, it creates the form object with an empty, new comment (line 1). The parameter hash in this snippet is not exactly what comes in, but represents it fairly enough. Nevertheless, these parameters are passed to the form's <code>validate</code> method, which will now try to assign the incoming data to the form graph (line 3).</p>\n\n<h3>Deserialization in Reform</h3>\n\n<p>The following diagram tries to illustrate that form graph and what happens during deserialization in the <code>validate</code> method. On the left-hand side is the input that gets assigned to the forms in the middle. As you can see, models to the right are not involved in this process.</p>\n\n<p>Every incoming fragment must have a corresponding form. These forms have to be set up, and this is what we call <u>validate population</u> in Reform.</p>\n\n\n;;;\n\n<p>It is important to understand that Reform writes incoming data to the forms, and not to the model. Have a look again at the illustration. When using <code>Form#validate</code>, data is assigned to the form objects. The wrapped models don't even know there's data incoming, they are treated as immutable at this point. Writing to models only happens in <code>sync</code> and <code>save</code>.</p>\n\n<p>When the form assigns data, this works fine for <code>body</code> and <code>weight</code>, as this is simply written to the main form (1). Reform now sees input for the nested <code>user</code> form and tries to dispatch this, too, onto the nested form (2).</p>\n\n<p>While this form does exist in the illustration, it does not in our case. There is no user form set up because the empty comment does not have a corresponding user, yet.</p>\n\n<p>Now, don't confuse this with the <code>:prepopulator</code> option we learned earlier. When validating a form, we don't call <code>prepopulate!</code> for reasons we will learn soon, and hence there simply is no nested user form to write data to.</p>\n\n<p>Again, there is no way for Reform to know that you want exactly one particular <code>User</code> instance to be wrapped by a sub form. Reform tries to assign the incoming sub form content to a non-existent nested form, and fails!</p>\n\n<p>The solution is to tell Reform that it should create a nested form for you when there's input for it. This happens via the <code>:populate_if_empty</code> option.</p>\n\n\n;;;\n\n<p>With this addition, the <code>validate</code> call works.</p>\n\n<p>When Reform hits the <code>user: {..}</code> hash and finds there's no matching nested form, it creates a new <code>User</code> instance, builds a nested form that wraps the user, and then assigns, or deserializes the incoming data in the nested user form.</p>\n\n<p>In <code>:populate_if_empty</code>, you simply return a model instance from the block. Reform will automatically wrap the model with a nested form for you and attach it to the parent form. This is because the <code>:populate_if_emtpy</code> option is run <u>per missing form</u>, Reform knows that is has to wrap the return value with a nested form.</p>\n\n<p>After the population has happened, the actual validation is run to figure out whether all that incoming data is sane.</p>\n\n<h3>Prepopulation vs. Validation Population</h3>\n\n<p>I need to stress how important it is to have two different options for prepopulation and for population during validation. Although in our case it looks identical, this can be completely different code. We'll have several occasions where we need both options.</p>\n\n<ul>\n<li>\n<p>Prepopulation using the <code>:prepopulator</code> option will blindly run the lambda and create nested forms around whatever you instantiated in the block. This assumes a blank slate, like an empty <code>Comment</code> object.</p>\n\n<p>You're free to add additional logic into the <code>:prepopulator</code> block, e.g. to add another empty form to a collection that already contains three items. More on that in the next chapter.</p>\n</li>\n<li>\n<p>Validation population mostly happens via <code>:populate_if_empty</code>. There are more ways to populate but we'll learn about them later. This option is run inside the <code>Form#validate</code> method, before deserialisation and the actual validation happens.</p>\n\n<p>The <code>:populate_if_empty</code> option has a different behavior: It knows about the incoming hash <u>and</u> about the existing model(s) in the nested form(s). The block is only run when there is an incoming hash, but no corresponding nested form.</p>\n</li>\n</ul>\n\n<p>As a sidenote, I'd love to say some words about Reform's architecture. Reform might look like a monster, with all those options and populator hooks and so on. Please don't mistake that as a monolithic setup.</p>\n\n<p>Most of the hard data modelling and transformation work is done by the Disposable gem. The form is orchestrating between so called <u>twins</u> and Reform's API. Disposable handles renaming, compositions, population, and even things like hash columns. It is completely decoupled from Reform. I am a bit excited to talk about all that cool stuff in later chapters.</p>\n\n<hr>\n\n<p>Rendering the form works. Submitting the form works. Processing and validating works. We can create comments. Yay!</p>\n\n<p>While the operation and its form is fully functional, we need to add a bit of controller code to make the UI work. But let's get to that in a second because I want to complete the life-cycle of a form by discussing saving, first.</p>\n\n\\n\n\n<p>Forms can also instruct the persistence layer to save models. As you might have noticed already, the nested user model gets properly assigned to the comment after the <code>Create</code> operation has been run successfully.</p>\n\n<p>This happens when calling <code>f.save</code> in the <code>Create#process</code> method.</p>\n\n\n;;;\n\n<p>I can't stress how important it is to understand how deserialization/population in Reform works.</p>\n\n<p>Again, please recall that models are not touched until we save. That means, the instantiated <code>User</code> during the population is not associated to the <code>Comment</code> model, yet.</p>\n\n<p>This is per design. Reform sets up a parallel object graph of nested forms to validate application state. Persistence is only involved as a last step - the result of a learning from mixing dynamic and persistent state as found in the Rails Way of working with models.</p>\n\n<p>When calling <code>form.save</code>, what happens is that each form will push its properties onto its model. This is called <u>syncing</u>. The form will assign values using public writers, e.g. it will invoke <code>model.body=</code>, <code>model.weight=</code> and of course <code>model.user=</code>.</p>\n\n<p>And this is how the user eventually gets assigned to the comment model. After syncing, every form invokes <code>model.save</code> on its wrapped model. This is when application state is persisted.</p>\n\n<p>Note how Reform is database-agnostic. In fact, it only calls writer methods on the models and invokes a generic <code>save</code> method on it. Basically, this is what makes Reform work with any ORM you favor, or even with plain POROs.</p>\n\n<p>Another thing to know is: calling <code>save</code> is completely optional. If your models don't need saving and only expect attributes to be set, you can use <code>Form#sync</code> as it is documented in Reform.<sup id=\"fnref3\"><a href=\"#fn3\" rel=\"footnote\">3</a></sup></p>\n\n\\n\n\n<p>Before we head over to test the commenting let's write some more features. Cause I feel like it. I'd like to get redirected to the thing page after a creating a comment, and a flash message saying <u><q>Comment created.</q></u> or something would be cool.</p>\n\n<p>Both redirecting and flash is controller affairs as both tasks involve knowledge about HTTP and sessions. And this is exactly the controller's job in Trailblazer.</p>\n\n\n;;;\n\n<p>One cool thing about <code>run</code> is that it allows passing a block which is only executed when the operation's validation was valid and the <code>process</code> method run successful. In our case, that means, a comment was successfully added.</p>\n\n<p>If this is what happened, I set a flash message to notify the world about this fabulous and successful creation (line 3). Note that I access the operation's <code>thing</code> method to grab the outer model - a method we yet have to implement.</p>\n\n<p>After that, I instruct the controller to redirect to the <u>thing</u> page. This doesn't make sense right now, because we don't have that page, yet, but it will make sense very soon (line 5). The <code>return</code> statement is crucial, otherwise the rest of the action is executed, too, which must not be.</p>\n\n<p>In case the validation failed, we re-render the <code>:show</code> view (line 9) to display the form with errors. This is why I copied the line to assign <code>@thing</code> to that action (line 8). This is not beautiful and a result of Rails and its static CRUD convention.</p>\n\n<p>This controller only contains presentation logic. And that is a design concept of Trailblazer. All business logic is happening in the operation, the controller solely knows about which operation to use and that it may be successful or invalid.</p>\n\n\\n\n\n<p>To reduce knowledge about the operation, we expose a new reader method <code>Create#thing</code> to the controller. This could also be achieved via <code>op.model.thing</code> but this would reveal internals about the comment model - a detail I don't want to share with the controller.</p>\n\n<p>We simply add a delegating reader to the operation. Tests will follow shortly.</p>\n\n\n;;;\n\n<p>It is a common practice to expose basic readers for an operation. However, don't confuse that with a decorator. When it comes to presentation logic, it is better to use a view model as we learned in chapter 3.</p>\n\n\\n\n\n<p>I promised you to simplify the process of populating the comment form with the user. Using <code>:prepopulate</code> and <code>:populate_if_empty</code> is extremely helpful when having a dynamic setup, for example, when it is optional to nest a user into a comment. Chapter 7 will demonstrate dynamic forms.</p>\n\n<p>In our setup, we <u>always</u> want a user nested in the form. This means we can statically add the user when presenting the empty form and when validating the input. You might have guessed it already: this is a job for <code>setup_model!</code> in the operation.</p>\n\n\n;;;\n\n<p>This looks way simpler.</p>\n\n<p>Instead of advising Reform to prepopulate at creation and populate in <code>validate</code>, we do it ourselves in <code>setup_model!</code> (line 11). I invoke the comment's builder method which is provided by ActiveRecord and it totally does the trick.</p>\n\n<p>Note that this already associates comment and user on the persistence layer, however, this is totally fine in this case.</p>\n\n<p>Since we use static population, we don't need any population-related options anymore (line 4).</p>\n\n<p>Static population is advisable only when nestings don't change. Later, we will have forms with a collection of nested forms where the amount of items changes dynamically. Obviously, static population won't work there.</p>\n\n\\n\n\n<p>As a last improvement for this chapter let's touch up the form's view, just a lil' bit. Form and view don't have to be messy. Right now, I have a few things I don't like in the view.</p>\n\n\n;;;\n\n<p>This is a very long line to render the two radio buttons for the weight. And, and that's why we're here, it creates redundant code. Have a look at the corresponding validation.</p>\n\n\n;;;\n\n<p>Even though this literally is just ones and zeros, this is overlapping code. I have to change both view and form code if I decide to represent <u>Rubbish!</u> with a <code>-1</code> value instead of <code>0</code>. We can simply move all code into the form class itself to keep knowledge in one enclosed place.</p>\n\n\n;;;\n\n<p>The class methods <code>::weights</code> contains the canonical value/label mapping (line 2-4). This can be used instantly in the corresponding validation where I call the method and extract the keys, from the hash, making it the original <code>[\"0\", \"1\"]</code> array (line 11).</p>\n\n<p>Since validations are defined on the class level, this all has to happen in the same context, the class.</p>\n\n<p>For the view, I define a second method <code>weights</code>, this time, an instance method. This method accesses the original <code>weights</code> hash and adds view-specific parameters (line 6-8).</p>\n\n<p>Many people use Reform as a pseudo view model and this is totally fine. When replacing form views with Cells we will see what other neat tricks are there.</p>\n\n<p>Anyway, check out the view now.</p>\n\n\n;;;\n\n<p>Extremely readable and no redundant logic anymore. And the <q>helper</q> can simply be called on the <code>@form</code> instance - it's just an instance method! By expanding the return value I can pass multiple values to the radio button generator.</p>\n\n\\n\n\n<p>As a last touch-up and to express my positive attitude towards life, I want to pre-select the <u><q>Nice!</q></u> button in the form. This avoids a validation error in case someone forgets to click one of the buttons.</p>\n\n<p>If you're thinking about using prepopulation to pre-select a value, you're amazing. This is exactly how it's done in Reform.</p>\n\n\n;;;\n\n<p>Again, I assign the desired value via the form's <code>weight=</code> writer method. Whenever we call <code>prepopulate!</code> on the form this will set the <code>weight</code> property to a zero string which will result in the form renderer checking the <u><q>Nice!</q></u> button for us.</p>\n\n<p>Be careful, though. In an edit form, you probably don't want to statically select a value for a button but rather reflect the actual object's state. We don't have a comment edit form, yet, so this is cool. However, there a more flexible trick to default values of forms. We'll discuss that in chapter 7.</p>\n\n<hr>\n\n<p>Party on, Wayne! Everything is working! We can create comments! Hooray! Ah ah. Don't start celebrating just yet. It's time to write tests for the <code>Create</code> operation and its form code.</p>\n\n\\n\n\n<p>As per usual, I start with testing the operation code. Since I hate the current way of modelling our UI and maintaining a separate page to create comments, we're gonna write smoke tests for controllers in the next chapter.</p>\n\n<p>And now let's be honest for a second. In retrospective, writing tests for application code has always made me feel awkward. <u><q>Oh no, I have to write tests now. Where do I start? What do I test? Where will that test go? Will I test the model, or integration, or what?</q></u> I still have this weird feeling when it comes to application tests.</p>\n\n<p>Then I remember that I am not supposed to think when writing tests in Trailblazer.</p>\n\n<p>By structuring the entire domain into operations with the same low-level API, it becomes pretty straight-forward to write first tests. I don't need to think about how to test this or that <u>functionality</u> - functionality is always represented as an operation with an extremely simple interface.</p>\n\n<p>So I jump into <code>test/concepts/comment/operation_test.rb</code> and start writing a valid operation call. Life can be so simple.</p>\n\n\n;;;\n\n<p>Comments are always associated to existing things, so I use the <code>Thing::Create</code> operation as a test factory (line 2).</p>\n\n<p>Look at how I nest the <code>user:</code> parameters into the comment hash. This is because of the nested structure of the form (line 10). If you check out the parameter structure in a real HTTP request after submitting the form, you will see they got the same nesting.</p>\n\n<p>One thing worth mentioning here is how I grab the user (line 20). I use <code>comment.user</code> which assures that the user object was really associated to the comment.</p>\n\n<p>And notice that I also test the <code>thing</code> method, as this is public API of our operation and used in the controller (line 23).</p>\n\n<p>Of course, I add several tests for checking the integrity of our validations. You can have a look yourself in the repo. Here's one example, though, to discuss how I often assert validations.</p>\n\n\n;;;\n\n<p>First, I run the operation with invalid parameters (line 2-6), then I access the operation's <code>errors</code> object and test specific error messages. I use an equality test here as it's the simplest test possible.</p>\n\n<hr>\n\n<p>You are now a master of nested forms. Mapping an arbitrary graph of models, or objects, to a form, encapsulating a group of validations in that class and consolidating further processing and saving of the models is an integral part of the Trailblazer architecture.</p>\n\n<p>In Rails, this is usually done with a mix of preparing controller code, contextual validations, hackish validation code in models and, if it comes to the worst, <code>accepts_nested_attributes_for</code> to map validations and deserialisation semantics to nested model graphs. A shiver just ran down my spine.</p>\n\n<p>Also, we've learned some more details about operations and how they are the ideal place for environmental setups and post-processing logic.</p>\n\n<p>In the next chapter, we will rearrange our user interface and have composed views. Then, I'm gonna walk you through non-CRUD forms and operations.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>What they really mean is <u>models</u>. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>When interested, check out the code in <code>Operation#validate</code>. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn3\">\n<p>The two methods <code>sync</code> and <code>save</code> are implemented in the respective modules <code>Form::Sync</code> and <code>Form::Save</code> in Reform. <a href=\"#fnref3\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>In the last chapter we were being good, conservative people and obeyed the Rails Way. By embracing its CRUD, or <q>RESTful</q>, convention we quickly implemented the form to create comments. This ended up in a nested controller on a separate page.</p>\n\n\n;;;\n\n<p>I told you, I don't like this.</p>\n\n<p>I find it incredibly clumsy having to navigate to another page when I want to talk about a thing.</p>\n\n<p>Let's assume we want to create comments directly on the thing page. The comment form is embedded, and when viewing details about a certain thing, we can instantly punch in our comment.</p>\n\n<p>Again, this is called <u>usability</u>. It makes sense to embed comments and the form to create them directly in the thing page, as you can see on the left. What I'm not telling you now is that we're breaking Rails and its <q>RESTfulness</q> now.</p>\n\n<p>Luckily, Trailblazer virtually breaks all the rules Rails has established, so this is only a minor crime.</p>\n\n<p>We don't have a page, yet, to display a <u>thing</u>. To implement that thing overview page, we have to implement <code>ThingsController#show</code>. As we all know, the <code>show</code> action of a controller represents one entity - which is the <u>thing</u> we want to display.</p>\n\n\n;;;\n\n<p>This code is sufficient to prepare the controller to display a thing. We still need to write the view, but let's talk about what happens in <code>present</code>, first.</p>\n\n\\n\n\n<p>It must look a bit confusing to use the <code>Update</code> operation in a render-only action (line 3). Isn't an updating operation supposed to <u>change</u> application state? The answer is: Yes, it is. However, an operation in Trailblazer has two faces. And this is not because they are suffering from bipolar disorder, but because of a reasonable object-design.</p>\n\n<p>We already learned about a CRUD operation's main behavior where it is run and creates or updates one or multiple models. This was triggered using the <code>run</code> controller helper, remember that from chapter 3?</p>\n\n<p>The <code>present</code> method represents the second semantic of an operation where only the setup code is run, without invoking the operation's <code>process</code> method. The <code>present</code> code is almost identical to <code>form</code>, which we used in chapter 3 to retrieve the form object of the operation.</p>\n\n<p>Both <code>form</code> and <code>present</code> help you retrieving a particular model in the operation and then assign instance variables in the controller to access the operation, the form and the actual model in the view.</p>\n\n<p>Let's recall the relevant <code>Thing::Update</code> operation parts, and then I'll walk you step-by-step through the flow.</p>\n\n\n;;;\n\n<p>Here's what is going on when invoking <code>present Thing::Update</code> in the controller.</p>\n\n<ol>\n<li>Since the operation includes the <code>CRUD</code> module and is configured to <u>find</u> (and update) an existing model, it knows how to retrieve the <code>Thing</code> model for the respective parameters. All that <code>present</code> does is telling <code>Update</code> to run its setup code using the <code>params</code> for the current request.</li>\n<li>The <code>params</code> contain an ID for a particular thing, so the operation will find this model using your logic or the generic CRUD behavior.</li>\n<li>Anyway, the operation does <u>not</u> run its <code>process</code> method, making it a read-only workflow<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>.</li>\n<li>After having run the operation's setup code, <code>present</code> assigns the aforementioned instance variables in the controller, like <code>@model</code>, and we're good to render the view.</li>\n</ol>\n\n<p>Again, showing you the pseudo code that is run in Trailblazer itself might help understanding.</p>\n\n\n;;;\n\n<p>As you can see, the controller <code>present</code> helper really just forwards the <code>params</code> hash to the operation's same-named method, which will solely find the model and then return itself (line 2).</p>\n\n<p>Reusing the <code>Update</code> operation is another great example how Trailblazer reduces redundancy in controllers. Usually, the <code>show</code> action would do that manually using <code>Thing.find</code> and assign instance variables.</p>\n\n<p>This creates overlapping code that can become a problem. Say you change the way you retrieve things, you have to change that in every involved controller action. The fact that filters can help avoiding this is defeated as soon as it comes to access control and authorization.</p>\n\n<p>Operations can also contain ACLs and more. It is impossible in a global controller filter to implement this level of granularity that we have by structuring our domain logic into operation classes.</p>\n\n<h3>Rendering a Thing</h3>\n\n<p>Fine. <code>present</code> retrieves the model using existing code and then assigns instance variables for the view. I guess it's time to have a look at <code>app/views/things/show.html.haml</code> now. I don't use Cells, yet. I want to use as much Rails Way as possible to make you feel the pain it will create, then we refactor the view to clean, fast view components in a later chapter<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n\n;;;\n\n<p>We simply render the thing's name, show a link to its edit form (line 3) and display the description so users get an idea what this is all about (line 5).</p>\n\n<p>If you create a new thing discussion now, or browse to an existing one using a URL like <code>things/1</code>, you will see a minimalistic info page about the thing with title and description.</p>\n\n<h3>Testing the rendering operation</h3>\n\n<p>One cool thing about reusing the <code>Update</code> operation for a render-only page is that we don't have to test it! Wheew, believe it or not - the invoked code is identical to the setup code when updating, and that is already covered in our operation test.</p>\n\n<p>What we do have to test is the wiring in the controller action, plus its view. This goes into our smoke test in <code>test/integration/things_test.rb</code>, again. I simply add this after we created a new thing.</p>\n\n\n;;;\n\n<p>I can't mention it often enough how I love those smoke tests. Trailblazers test structuring has evolved over many years and makes it really easy to add a few lines of test that will increase sleep quality without pain.</p>\n\n<p>And I know you already understood what we're doing in the test. After having submitted a valid form, we're getting redirected to the thing's <code>show</code> page (line 4 and 7). All I want to know is whether or not it renders the thing's title (line 8). A minimal test does what we need right now.</p>\n\n<p>Now that we got the enpoint and view to check out things, why don't code the functionality to add comments to it?</p>\n\n\\n\n\n<p>We want to render the comment form <u>in</u> the thing page. Plugging the form into <code>ThingsController#show</code> is relatively simple. We have to extend the old <code>show</code> action with a few lines of code.</p>\n\n\n;;;\n\n<p>Additionally to <code>present</code>, we now call <code>form</code> with our new operation, also (line 3 and 6). It is absolutely fine to run multiple operations in one action - as long as it is UI-specific!</p>\n\n<p>I use the fact that <code>present</code> returns the operation instance (actually, all controller methods do that), and save it in <code>@thing_op</code> (line 4). To have access to the <code>Thing</code> model, that needs to be assigned to <code>@thing</code> manually (line 5). This step is necessary as the subsequent invocation of <code>form Comment::Create</code> will override the <code>@model</code> variable which we need in the view (line 6).</p>\n\n<p>To get this straight: this is absolutely not the way I would build a user interface. Rails views, the lack of a rendering API and its instance variables are just not designed for composed views. Partials only hide the fact that we're relying on a lot of shared state.</p>\n\n<p>Currently, the controller action is the place for composing the UI, so you might call more than one operation. However, never compose business logic in the controller. Again, this is purely for the user interface, and since we don't have a layer for composed UIs, yet, the controller is the right location for now.</p>\n\n<p>After having collected data we can extend the view in <code>app/views/things/show.html.haml</code>. I am skipping the top part of the template file.</p>\n\n\n;;;\n\n<p>It's important to understand that the <code>@form</code> instance variable comes from the <code>@form</code> operation invocation in the controller, so this is the <code>Comment::Create</code> form (line 4).</p>\n\n<p>You will recognize the old <code>show</code> view appended with an additional form. Into the form-generating helper call I pass the <code>@form</code> object and a manual URL (line 5). That looks odd to an untrained, Rails-Way-spoiled eye.</p>\n\n\\n\n\n<p>Following the Rails Way, submitting the comment form goes to the <code>CommentsController#create</code> action. Per se, I find this a good and valid convention to structure controllers into CRUD actions, and resolve the selected action by considering the request type and the URL.</p>\n\n<p>For example, in our case, a POST request to <code>comments/</code> would be dispatched to the controller's <code>create</code> action. In Rails, this is called <q>RESTful</q>. I am still puzzled why this is named after the hypermedia-oriented architectural style, but let's call it quits for now.</p>\n\n<p>However, this won't work for us. Remember, the comment form sits in the thing page. We could make that work for a successful submission, create the comment in the <code>CommentsController</code> and redirect back to the thing page.</p>\n\n<p>What are we gonna do when things go wrong, though? I don't want the errors to show up on another page, I want the invalid form to be rendered exactly where it has been before the submission: embedded in the things page.</p>\n\n<p>We've reached the limits of Rails' <q>RESTful</q> controller design.</p>\n\n<p>It starts to break down as soon as you introduce a composed user interface. I simply don't favor a CRUD page to create a thing, and a separate page to create a comment, and so on.</p>\n\n<p>I want to embed the comment form into the thing page. The comment form is more of a <u>widget</u>, a stand-alone view component that lives in the thing page without knowing about things at all.</p>\n\n<p>So, how do we make this work? We need to validate the submitted form, create a comment on success or show errors on failure.</p>\n\n<p>The answer from a Rails expert might be: <u><q>Well, you are not RESTful, this is why you need an ugly work-around.</q></u> and this is an extremely frustrating response, given that all I am trying is to improve usability. There is three things we can do now, according to the imaginary Rails expert.</p>\n\n<ol>\n<li>I might get advised to use JavaScript validations. That way, we can use the <q>RESTful</q> approach, let the <code>CommentsController</code> create the <u>always valid</u> comment and redirect to <code>ThingsController</code> afterwards. This will always cause trouble since JavaScript can not do business-specific validations.</li>\n<li>We can still POST to the comments controller, and in case of error, it redirects back to the original controller, passing a list of validation errors to display. This is extremely ugly and hard-wires error handling into the <code>ThingsController</code> that is absolutely not supposed to know anything about creating comments. I have seen that a lot of times in real projects. It made me cry. A bit.</li>\n<li>AJAX! Rails' answer to fix the misleading <q>RESTful</q> architecture is AJAX. Send an asynchronous request to whatever controller and re-render the widget. I find this an OK solution when using real AJAX widgets as found in Apotomo and Cells. This is not the case in a vanilla Rails app and the amount of code I've encountered to implement this approach was depressing.</li>\n</ol>\n\n<p>Luckily, there's another way to solve this.</p>\n\n<h3>Introducing a UI Action.</h3>\n\n<p>As you might have already guessed, we simply break the <q>RESTfulness</q> and introduce a new UI-specific action into <code>ThingsController</code>. I can hear Judas Priest playing <u>Breaking the Law</u> in the background.</p>\n\n<p>This only sounds dirty. Since Trailblazer encapsulates all business logic into operations, the controller doesn't know anything about the form processing's internals. Let's look at the rendered form, again.</p>\n\n\n;;;\n\n<p>To compute the URL for the form, I call a cryptic helper that is available because I changed the <code>config.routes.rb</code> file slightly.</p>\n\n\n;;;\n\n<p>Instead of trying to stay <q>RESTful</q> I simply add a new action (and a new route) to the things controller (line 3). This sends the submission back to <code>ThingsController#create_comment</code> where we process and re-render the page in case of an error.</p>\n\n<p>This must feel dirty and wrong, but it does exactly what I want. Given that we will replace this kind of UI component with AJAX-backed widgets in later chapters, I can swallow the bitter taste and take it like a developer.</p>\n\n<p>The new action, as already mentioned, goes into the <code>ThingsController</code>.</p>\n\n\n;;;\n\n<p>Let me start from the bottom, this time. The trick here is to render the old <code>show</code> view, as we're actually coming from the <code>show</code> action (line 8). In order to prepare all necessary instance variables and dependencies, we present the <code>Thing::Update</code> operation and assign variable exactly as we did it in the original action (line 3-4).</p>\n\n<p>Instead of using the <code>form</code> helper, we now <code>run</code> the <code>Comment::Create</code> operation, which processes and validates the input, and then provides the form with potential errors in the <code>@form</code> object (line 6). Everything else is done in the view and the form builder.</p>\n\n<p>The API of <code>Comment::Create</code> requires a <code>:thing_id</code> parameter. Since this invocation sits in <code>ThingsController</code>, that thing ID has to be remapped from <code>:id</code> to <code>:thing_id</code>, and that's what I do using the <code>:params</code> option for <code>run</code> (line 7).</p>\n\n<p>And that's basically everything you need to build and process a composed page. I've seen this pattern a lot in vanilla Rails apps. However, those apps didn't have any encapsulation for business and processing logic. The result was chunky controller actions with tons of identical behavioral code.</p>\n\n<p>We still have redundant code in our setup at the moment. I'm fine with that, though. The abstraction level of operations really boils down controllers to dispatchers that only know <u>what</u> to instantiate. They have zero knowledge about the internals and act as configured orchestrators, only.</p>\n\n\\n\n\n<p>Now that we have the comment form in place and working by embedding it into the thing page, we're ready to add more UI functionality to that page. I am contemplating to render a list of recent comments under the comment form.</p>\n\n<p>Once this works and we show the last ten comments, I want to allow the user to load more comments by clicking a <q>More</q> button. This button will load ten more comments in an AJAX call and append them to the existing list.</p>\n\n<p>We will learn that this is incredibly simple with Cells and you will soon understand why I push you towards Cells' encapsulation when we implement the AJAX loader.</p>\n\n<p>Why not start with the list of the last ten comments, embedded in that page? Using a cell to represent a comment, that could be rendered as follows.</p>\n\n\n;;;\n\n<p>Naturally, I start with a comment cell in <code>app/concepts/comment/cell.rb</code> and the following code skeleton.</p>\n\n\n;;;\n\n<p>This is my usual workflow when writing a cell. I declare properties from the decorated model I am definitely gonna use in the cell, and add the <code>show</code> method.</p>\n\n<p>Our next step is to write the view in <code>app/concepts/comments/views/show.haml</code>. This will represent the view fragment for one comment. However, as we want to display several comments, and at the same time make use of Foundation's grid, we need to add the respective CSS classes to each comment cell.</p>\n\n<p>Remember from chapter 4 where we had the <code>Thing::Cell</code> that basically wrapped every thing into a markup container as follows?</p>\n\n\n;;;\n\n<p>In the comment cell, we need the exact same behavior: wrap the actual cell content in a container div and assign respective CSS classes to it. Let's extract that logic into a module that we can then use in <code>Thing::Cell</code> and <code>Comment::Cell</code>.</p>\n\n<p>Here's the <code>show.haml</code> view of the comments cell.</p>\n\n\n;;;\n\n<p>As you can see, the content is nested into a <code>container do ..</code> block (line 1). I will explain the rest of this view a bit later and want to focus on the container helper now.</p>\n\n\\n\n\n<p>Since we need this helper across different cells, I will write it in its own module.</p>\n\n<p>In Trailblazer, application-wide features that can't be associated with one exclusive concept are put into <code>app/lib/:app_name</code>. For example, the new <code>GridCell</code> module goes to <code>app/lib/gemgem/cell/grid_cell.rb</code>.</p>\n\n<p>The reason for <code>app/lib</code> is that this will allow reloading during development. Also, I've never understood the <code>app</code> directory located on the same level as the <code>lib</code> directory. To me, library code is to be shared within the application and hence should be in <code>app/</code>, also. If you want real libraries that are decoupled from any application, write a private gem.</p>\n\n\n;;;\n\n<p>By putting the <code>GridCell</code> feature - and this module is a feature as it adds functionality - into the <code>Cell</code> namespace I visually categorize this module as a cells extension for my <code>Gemgem</code> application constant that is defined by Rails.</p>\n\n<p>This module does three things.</p>\n\n<p>First, I override the <code>included</code> class method (line 3-5). This is a common Ruby idiom to run additional code when this very module is included into a class (or another module). In our case, when <code>GridCell</code> is included into, say, the <code>Comment::Cell</code>, it will add an inheritable class attribute named <code>classes</code> to the latter. We can then use this to assign class attributes to our cell which we're actually gonna use for specifying  CSS classes.</p>\n\n<p>Maybe it's easier to understand when seeing how <code>GridCell</code> can be used to configure an actual cell. Here's the <code>Comment::Cell</code>, this time including the new feature.</p>\n\n\n;;;\n\n<p>The internal mechanics how that works are irrelevant right now. Fact is, we now can assign arbitrary data to the <code>classes</code> attribute.</p>\n\n<p>When included, the <code>GridCell</code> feature also imports the <code>container</code> helper method (line 13-15) that we use in our view. This method is simple: it creates a <code>div</code> tag using Rails' <code>content_tag</code> helper, assigns CSS classes and then passes the block on to the helper (line 14). This will result in a properly configured <code>div</code> tag wrapping our actual view.</p>\n\n\n;;;\n\n<p>By <u><q>properly configured</q></u> I mean that the wrapping div for one comment contains all the classes that we assigned - and more. Now, how do those classes get in there?</p>\n\n<p>The <code>container</code> calls the instance method <code>classes</code> (line 14) which is defined in <code>GridCell</code>, too. This method does nothing more but accessing the class-wide configured <code>classes</code> (line 8) and then adding an <code>end</code> class to it in case the decorated model is the <q>last</q> one.</p>\n\n<p>These are the same mechanics that we already discussed in chapter 4. By moving that into a module, we can reuse the <u><q>let me define CSS classes per cell, render a container `div` and add an `end` class in case this very cell represents the last object!</q></u> semantics for both things and comments.</p>\n\n<p>I won't discuss reusing the application-wide feature in <code>Thing::Cell</code> because you can <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-06/app/concepts/thing/cell.rb\">read the repository code</a> and have a look at this class yourself.</p>\n\n\\n\n\n<p>Beautiful, comments get rendered, wrapped accordingly in a container div, now let's see what else is going on in a <code>Comment::Cell</code> view.</p>\n\n\n;;;\n\n<p>One feature I implemented here is that positive comments are marked with a heart, cause, love is all around. This happens by putting a decider into the view that renders a Foundation heart icon (line 2-3).</p>\n\n<p>Please note that I have absolutely no problem with simple deciders in views.</p>\n\n<p>The <code>nice?</code> decider is implemented in the cell class. As usual, this goes into an instance method.</p>\n\n\n;;;\n\n<p>Now, be careful. This <u>is</u> business logic. Knowing that a zero represents a friendly comment is definitely not a thing that should be replicated in a view component. However, at the moment, the comment cell is the only place where we apply this wisdom.</p>\n\n<p>We will extract that logic into a twin once we use it in other places, too.</p>\n\n<h3>Extracting The Timeago Helper</h3>\n\n<p>In the comment cell view, we also call <code>created_at</code> to display when that statement was exactly given. Again, I want Timeago to do its magic here and render a readable string instead of a raw timestamp.</p>\n\n<p>We did that already in chapter 4. And, yeah, you guessed it: we're going to extract that into another cell feature in <code>app/lib/gemgem/cell/created_at.rb</code>.</p>\n\n\n;;;\n\n<p>By overriding the <code>included</code> hook we can import necessary helpers into the cell that includes this feature (line 3-6). This means the cell does not have to do it anymore.</p>\n\n<p>It simply includes this new feature and imports the <code>created_at</code> method that will use Timeago to render a readable timestamp (line 9-11).</p>\n\n\\n\n\n<p>Look at the comment cell now, how brief the code is and how readable a view component can be.</p>\n\n\n;;;\n\n<p>At this point, I want you to think back of how that would work with partials, controller assigns and helpers. How would you dynamically configure a partial's CSS classes without passing around locals and using code in views?</p>\n\n<p>It is impossible with Rails' standard view stack since it is missing the concept of <u>objects</u> that represent fragments, or widgets, in your user interface. The fact that partials internally use objects to render fragments is not what I'm talking about here. In Rails, the problem is that those objects are not part of the high-level architecture accessable for the application developer.</p>\n\n<p>The view layer in Rails provides you with templates and functions. However, there's no direct relation between those two - it is incredibly hard to structure your view as you never know whether or not to do things in the controller, in the view itself, or in a dozen global helper functions.</p>\n\n\n;;;\n\n<p>Cells, on the other side, simply represents a fragment of your UI with an object. This is applied OOP, nothing more.</p>\n\n<p>A position shared by many people when they first hit Cells years ago was that Cells introduces <q>over-abstraction</q> to solve a <q>simple problem</q>. Instead of playing around with this new concept it was discarded because it <q>doesn't outweigh the increased technical complexity it brings</q>.</p>\n\n<p>Look at the cell code we've written so far, and its view. Think about what it does. Think about the reusability like the wrapper container logic, the simple view and the few lines of code in a cleanly separated class. I don't think this is over-abstraction at all, and I do not see where Cells brings <q>technical complexity</q>. The opposite is the case: By applying encapsulation via a view component, I have one thing less to worry about.</p>\n\n\\n\n\n<p>Originally, we were rendering the list of comments manually in the thing's <code>show</code> view at <code>app/views/things/show.html.haml</code>.</p>\n\n\n;;;\n\n<p>This works neatly in order to display comments. Nevertheless, we've got more things planned. We also want to allow users to load more comments by clicking a <u><q>More!</q></u> button, which involves incorporating a button into the view, and additional logic.</p>\n\n<p><u><q>Wait, did you just say</q>additional logic<q>for the view? Let's put that in a cell!</q></u> is what you were just thinking, weren't you? You're awesome! That's exactly what to do right now. Encapsulate the rendering of the comment list, or grid, dependent on our screen size, into a composing cell and let that embracing widget handle pagination. And AJAX. Of course.</p>\n\n<p>To implement that grid cell, I push the code into <code>app/concepts/comment/cell.rb</code>. I am not gonna talk about the nesting-cells stuff, again, as this is already covered in chapter 4. Instead, let's focus on the <q>More!</q> button and the pagination logic.</p>\n\n<p>But first, we need to define the new cell's interface. Here's how the grid cell is invoked.</p>\n\n\n;;;\n\n<p>Note that I pass in a <code>Thing</code> instance, and not a list of comments. This is a dependency I create on purpose.</p>\n\n<p>As the next step, we should have a look at the first implementation of the new cell.</p>\n\n\n;;;\n\n<p>The <code>Comment::Cell::Grid</code> cell is gonna sort out rendering a list and paginating it. I structure that into the existing cell, mainly to separate it from the global namespace.</p>\n\n<p>In the <code>show</code> method I simply copied the original <code>concept</code> call for rendering the comments collection (line 7). I then append a generic pagination view. Of course, this is only prototyping, but I find it kinda cool how we can simply treat method results as strings and concatenate them to implement a quick UI draft.</p>\n\n<h3>Pagination with Kaminari</h3>\n\n<p>The <code>paginate</code> helper comes from the fantastic <a href=\"https://github.com/amatsuda/kaminari\">Kaminari</a> gem which is well-established in the Rails community. Cells view models provide support for it using the <code>kaminari-cells</code> gem, a tiny compatibility layer that gets activated by including the respective module into the paging cell (line 4).</p>\n\n<p>Kaminari gives us more helpers, but just to demonstrate how simple it is to use it, I use <code>paginate</code> now. This won't render a button, though, but a full-blown pagination row which we don't actually need. I'll fix this in a minute.</p>\n\n<p>Let's see how Kaminari gets the data it has to paginate. The list of comments comes - surprisingly - from the <code>comments</code> invocation (line 7).</p>\n\n\n;;;\n\n<p>This will call <code>Grid#comments</code> to collect comment records to paginate.</p>\n\n<h3>Aggregating Data in Cells</h3>\n\n<p>Of course, the <code>comments</code> method needs to be implemented in the <code>Grid</code> cell itself. Here's how that is done.</p>\n\n\n;;;\n\n<p>In the <code>comments</code> method we do the actual pagination. Since the <code>Grid</code>'s model is a thing, not a comment list, we can call <code>model.comments.page ...</code> and run the pagination logic right in the cell, not in a controller (line 4).</p>\n\n<p>Again, this is my decision as a software designer. Pagination is a visual usability concern and perfectly located in a cell. Once we need pagination elsewhere, we have to move it into an operation or a twin.</p>\n\n<p>One important thing is that I memoize the comments list using the <code>@comments</code> instance variable (line 4). This is because this methods gets called multiple times in one rendering run. While I usually avoid memoization of values, this makes sense here as <code>comments</code> is a pure read-only query method.</p>\n\n<p>Another detail is the <code>page</code> invocation which is another method in the grid cell  (line 4). We simply provide a default page (which is the first page) in case the <code>:page</code> option wasn't passed into the cell invocation (line 7-9). This is the case when the comments get rendered initially. Remember how we invoke the entire comments grid?</p>\n\n\n;;;\n\n<p>There's no <code>:page</code> option. We could pass this here by adding <code>page: params[:page]</code>, or whatever, but I found it interesting to talk about default values.</p>\n\n<hr>\n\n<p>This code is enough to render the list of comments along with a pagination row. Clicking on a distinct page number will reload the page, but keeps rendering the first page. This is because we don't pass in the page number from the request as I briefly mentioned in the last paragraph.</p>\n\n<p>Instead of the complete pagination element, I want to have one button saying <u><q>More!</q></u> that loads the next page via AJAX and appends it to the existing comments list.</p>\n\n\\n\n\n<p>To add that <u><q>More!</q></u> button I've been talking about for 20 minutes now I introduce a new view for the grid cell. This goes into <code>app/concepts/comment/views/grid.haml</code>. Note that this is the same view directory that we use for the comment cell.</p>\n\n<p>It is very common to put the same cell views into one directory, even though they are different classes. You can maintain separate directories for every cell class, and that is what happens per default. I want to show you how cells can share view directories, though.</p>\n\n<p>Here's the <code>app/concepts/thing/views/grid.haml</code> view that will represent the entire list and pagination widget.</p>\n\n\n;;;\n\n<p>First, I render the comments collection using the <code>Comment::Cell</code>. I also pass in the <code>:last</code> option so the last cell knows it has to add the <code>.end</code> class to its container div (line 1).</p>\n\n<p>Unless it's the last page, I then render the notorious <u><q>More!</q></u> button.</p>\n\n<p>Note that <code>last_page?</code> is a Kaminari method on the comments collection. This will suppress rendering of the button on the last page of comments (line 3).</p>\n\n<p>The button gets nested in a <code>#next</code> div (line 4). A clumsy URL helper then provides the path where to send the AJAX request (line 5). In this URL needs to be embedded the thing id and the page number of the next set of comments. Again, I use a Kaminari method called <code>next_page</code> here.</p>\n\n<p>By specifying <code>remote: true</code> I advise the link helper to create an AJAX link. When clicking, an AJAX request gets sent to a path like <code>/things/3/next_comments?page=2</code>.</p>\n\n<p>Rendering this <code>grid.haml</code> view has to be done explicitly. Here's the <code>show</code> state of the grid cell.</p>\n\n\n;;;\n\n<p>As you can see, you can pass the view name to <code>render</code> (line 5). When skipping the view name, Cells will try to render <code>show.haml</code>, which is the wrong view.</p>\n\n<p>Also, you have to configure the cell to share the view directory with the comment cell. This is done by using <code>inherit_views</code> which will basically instruct Cells to look into <code>Comment::Cell</code>'s view directory when rendering a view (line 2).</p>\n\n<p>Instead of searching for <code>comment/grid/views/grid.haml</code>, the cell will now also check for <code>comment/views/grid.haml</code> which is exactly where we put the view.</p>\n\n<p>Sharing view directories is not necessarily enforced by Trailblazer. I just find it convenient to have one view directory per concept, unless I want to write really reusable cells.</p>\n\n<h3>AJAX Processing Cells</h3>\n\n<p>Of course, this special URL needs to be intercepted by a controller action. In Rails, we have to add a route for this. The following addition to <code>config/routes.rb</code> implements this additional UI-specific route.</p>\n\n\n;;;\n\n<p>Instead of trying to stay <q>RESTful</q> I add another route to the things resource routes, namely the <code>next_comments</code> action (line 4).</p>\n\n<p>This will be routed straight to <code>ThingsController#next_comments</code>. Why not go and check out this new action.</p>\n\n\n;;;\n\n<p>And this is the point where you will realize what <u>reusability</u> really means. Reusability does not only allow sharing behavior between projects, it also, and that's the point about it, helps taking advantage of a component within one and the same application!</p>\n\n<p>That is exactly what we do here. To render the next page of comments, we make use of the comment's grid cell.</p>\n\n<p>Remember, the only dependency for the grid cell is a <code>Thing</code> instance. As we learned earlier, the <code>present</code> invocation will prepare the controller by grabbing the thing instance that is requested as per URL (line 4).</p>\n\n<p>After setup the action, I call the grid cell, pass in the thing and the page number from the request (line 7). The page number's the optional second dependency for the our cell and will result in the cell rendering the correct page.</p>\n\n<p>One thing to notice is that I instruct the Rails controller to return the rendered fragment as <code>JS</code> (line 6) which makes it work seamless with Rails UJS layer.</p>\n\n<h3>Call Styles in Cells</h3>\n\n<p>Please, listen up now. This time when invoking the cell, I do <u>not</u> call the <code>show</code> method. Instead of letting the <code>concept</code> helper trigger the default <code>show</code> cell method, I do it manually.</p>\n\n<p>Here, I invoke the <code>append</code> state using the <u>call style</u>, as we say in Cells (line 7). The syntax used here is the preferred way to call an alternative state when invoking a cell: <code>cell.(:state)</code> is an alias to <code>cell.call(:state)</code> but looks more nerdy and underlines the limited public API that I'm trying to enforce with all my gems.</p>\n\n<p>You might wonder now how many different ways there are to invoke methods on cells, and the answer is: Two. Only two.</p>\n\n<ol>\n<li>\n<p>You can always call a method directly. A cell is an object and objects respond to methods.</p>\n\n<pre><code class=\"ruby\">concept(\"comment/cell/grid\").append #=&gt; &lt;div ...&gt;\n</code></pre>\n\n<p>This will really just call the <code>append</code> method (or, <code>show</code>, or whatever you want) and provide the method's return value. However, this neither does involve caching, nor does it mark the string as <code>html_safe</code>, a horrible construct found in Rails to avoid automatic HTML escaping of strings.</p>\n</li>\n<li>\n<p>The preferred way, nevertheless, is the <u>call style</u>. And this is what the <code>concept</code> helper does for you in case you didn't call a method explicitely. The invoked method defaults to <code>show</code>, but since we want to call <code>append</code> I use the call style to achieve that.</p>\n\n<pre><code class=\"ruby\">concept(\"comment/cell/grid\").(:append) #=&gt; &lt;div ...&gt;\n</code></pre>\n\n<p>The call style will mark the returned string as <q>safe</q> and, more important, involve Cells' caching<sup id=\"fnref3\"><a href=\"#fn3\" rel=\"footnote\">3</a></sup>. We'll talk about caching soon.</p>\n</li>\n</ol>\n\n<p>My advise is to use call style when you need to trigger an alternative method.</p>\n\n\\n\n\n<p>The newly added <code>next_comments</code> method is another aggravating break with Rails and its <q>RESTful</q> controller paradigm.</p>\n\n<p>It becomes obvious that structuring actions in controllers gets degraded, controllers become stupid endpoints that dispatch to operations or cells.</p>\n\n<p>Your software architecture is no longer focused on which controller is <q>RESTful</q> and which is UI. When you need a new UI function, you chuck an action into the closest controller to back that function's request. The point here is that all our logic is encapsulated in appropriate objects. Those operations or forms do not care whether they're run from <code>CommentsController</code> or <code>ThingsController</code>.</p>\n\n<p>Controllers become lean HTTP endpoint dispatchers, and that is a good thing.</p>\n\n<h3>Appending per Javascript</h3>\n\n<p>We click the <u><q>More!</q></u> button. An AJAX request triggers <code>next_comments</code> in the things controller. This in turn invokes the grid cell and calls the <code>append</code> method. The result is then sent back to the browser which runs whatever was the result of <code>append</code>.</p>\n\n<p>So, the last missing piece is <code>Grid#append</code> and here we go.</p>\n\n\n;;;\n\n<p>The <code>append</code> method does nothing more but calling the original <code>show</code> method which will render a HTML fragment with the next page of comments. I escape the content using the <code>j</code> helper from Rails' <code>JavaScriptHelper</code> (line 6). This helper has to be included into the cell in order to be available (line 2).</p>\n\n<p>This string is then simply wrapped by the appropriate JavaScript code to append the new page of comments to the list found on the page. I do this by replacing the old <code>#next</code> div with the new content. Its advantage is that this removes the old <u><q>More!</q></u> button while adding the new comments.</p>\n\n<p>I'm sure there's better ways on the JavaScript end to achieve that, but it basically does the trick.</p>\n\n\\n\n\n<p>Postponing tests in this chapter has been part of my agenda. Until we have a working view component in place it doesn't make sense to frantically follow the TDD approach just to say you're frantically following the TDD approach.</p>\n\n<p>We could have started with a cell test for the <code>Comment::Cell</code> but I prefer to test the entire grid component as one. Since we do not use the single comment cell anywhere it doesn't make sense to test this in isolation. Testing the latter would mean we test a private concept, which isn't helpful when refactoring.</p>\n\n<p>Now that everything is working, it definitely is time for tests. And, hey! Tests with Trailblazer are fun! Keep telling that to yourself, it works.</p>\n\n<p>Let's quickly run through some of the tests for the comment cells. As aforementioned, I only test the <code>Comment::Cell::Grid</code> cell. Since I'm not gonna discuss every single line you should have a look at the <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-06/test/concepts/comment/cell_test.rb\">test file</a> for a complete picture.</p>\n\n<p>I start with a test setup. Being a crazy Trailblazer, operations are used for this.</p>\n\n\n;;;\n\n<p>Of course, we need a thing to present, and this is what I do first (line 4). After that, I create four comments. Since one page contains three comments, we will have to paginate once, which is exactly why I chose this number.</p>\n\n<p>Note how I use the earlier created <code>thing</code> to associate the comments to the thing (line 7 and 8).</p>\n\n\n;;;\n\n<p>Following the setup code we can start testing - yay! I grab the markup string by invoking the grid cell and its <code>show</code>. Since this requires a model I pass in the fixture <code>thing</code> (line 2).</p>\n\n<p>The returned string is ready to be tested with Capybara matchers and this makes it incredibly simple to assert markup constraints. First, I test if we really display three comments by checking whether we have three <code>.comment</code> divs (line 4-5).</p>\n\n\n;;;\n\n<p>I then grab the first rendered comment which represents the most recently created (line 3) and test whether the right author and comment body are in place (line 4-5). Since this comment is a negative one, an important test is to check that the heart icon is not rendered (line 6). As the first comment in the list, it shouldn't have the <code>.end</code> class, this is for the last comment (line 7).</p>\n\n<p>The same thing happens for the second comment. This one is a positive comment. Generally, I make sure to test both positive and negative comments and always make sure the <code>.end</code> class is not assigned.</p>\n\n<p>Here's an excerpt from the third and last comment in that current list.</p>\n\n\n;;;\n\n<p>Here, the wrapping div must contain the <code>.end</code> class (line 4).</p>\n\n<p>Note how simple Capybara makes it to assert CSS selectors on fragments in your view. You can use finders and then apply selectors to parts of the view by using well-known Ruby operations like <code>#[]</code>.</p>\n\n<p>As a last test, I check that the <q>More!</q> button gets rendered.</p>\n\n\n;;;\n\n<p>This checks two things. First, I make sure we got a <code>#next</code> div as this is needed for the AJAX update. Second, I check that the URL of the wrapped link is correctly pointing to our AJAX action with the right parameters (line 3-4).</p>\n\n<p>I don't use URL helpers to generate the target address in the test. For some strange reasons, I feel safer to assert a <q>real</q>, hardcoded URL instead of letting the test generate it. This test will break, of course, when I change my routing. As routing changes rarely happen, I am happy with this test.</p>\n\n<h3>Testing Pagination</h3>\n\n<p>The pagination action <code>append</code> in the grid cell wraps the identical code into a JavaScript statement. I am not gonna test everything again here but write a super minimal test for now.</p>\n\n\n;;;\n\n<p>This time, I invoke the <code>append</code> method and pass in the next page (line 2).</p>\n\n<p>All I assert is that the JavaScript is rendered (line 4) and if the fourth comment is in that page (line 5). In my lousy test I simply check if the fourth commment's author email is in the rendered markup.</p>\n\n<p>When I said lously I meant lousy. Here, I expose knowledge about the implementation in my test. Since I know that the <code>append</code> method calls <code>show</code>, I skip testing details and only test the added code on top of that.</p>\n\n<p>However, this is way better than having no test at all. In fact, I test everything required to assure the component works the way we expect it to operate. Both JavaScript generation and the actual pagination process are tested in a, well, not too obvious way.</p>\n\n<p>Let us come back to more mature tests at a later point.</p>\n\n\\n\n\n<p>As a last step we need to write some more smoke tests for the new actions in <code>ThingsController</code>. First, we test the rendering of the new comment elements in the thing's show view. This goes into the <code>test/integration/thing_test.rb</code> test.</p>\n\n<p>I copied the <code>thing</code> fixture creation from the cell test. I did this on purpose - we will soon replace redundant test setups with factories. Factories that use operations, of course.</p>\n\n<p>We have tested the <code>show</code> action already, but now we need to add tests for the embedded comment form plus pagination. Here's the extended test case for it.</p>\n\n\n;;;\n\n<p>I insert this test code into the <code>#show</code> section of our integration test, and check whether the comment form is displayed (line 6). Just to make sure the input fields are rendered, I check for the nested email field (line 7).</p>\n\n<p>Since we also show the comment grid I try to find the comments, or the grid. This assures that the <code>Comment::Cell::Grid</code> component is rendered (line 8).</p>\n\n<h3>Create Comment Tests</h3>\n\n<p>Tests for creating comment and pagination are integration tests as well, and will get their own test file <code>test/integration/comment_test.rb</code>.</p>\n\n<p>When integration testing, I tend to structure by concept, too. While we put all thing-relevant scenarios into <code>thing_test.rb</code>, this is now very specific to comments, the fact that the code is implemented in the <code>ThingController</code> to me is irrelevant here.</p>\n\n<p>Again, I copied factory code for now and will skip it here.</p>\n\n\n;;;\n\n<p>To create a comment, I visit the thing show page, fill out the form and submit (line 4-8).</p>\n\n<p>After successful creation, the controller must redirect to the new thing URL (line 10). I also test whether the flash message is correct (line 11). The flash message is a UI-specific feature and both implementation and test go into the controller layer.</p>\n\n<p>In the repository test file, you will find an additional test for an invalid submission. Again, this purely tests the mechanics for now and no details or error messages are tested.</p>\n\n<h3>Pagination Tests</h3>\n\n<p>Last but not least, and it has been a long way, I test the pagination of comments, implemented in <code>next_comments</code>. Being extremely exhausted from all those tests and all that smoke, this goes into a real simple one.</p>\n\n\n;;;\n\n<p>I visit the show page and click the pagination link <u><q>More!</q></u> (line 5).</p>\n\n<p>After the request I simply check that the last comment is somewhere in the response's body (line 6. This is similar to the cell pagination test we wrote earlier. Even though this test looks as if it doesn't really test anything, it will find and report if we ever break the pagination wiring in the controller.</p>\n\n\\n\n\n<p>Some cool stuff has been going on in this chapter. We've introduced new UI components to enhance our user experience. Comments are now directly embedded in a thing page via a presenting cell. And, even better, a form now allows to create comments right in that very same page.</p>\n\n<p>Even though we broke with Rails conventions a lot here, the code remains clean and readable. Specific logic is hidden in operations and cells, making it unnecessary to worry about controller structuring any longer.</p>\n\n<p>This is why both comment creation and pagination are happening in the <code>ThingsController</code>. And does that hurt? No, it doesn't!</p>\n\n<p>The next chapter will discuss forms a bit more, as they are the pivotal element in every application. Luckily, Trailblazer makes it relatively simple and you will be mastering your forms soon enough.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>Internally, the operation only gets instantiated, nothing more. For a more functional design, though, I try to make the user not instantiate operations manually and therefore provide <code>present</code>. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>There is <u>Appendix A: Cells-Only Views</u> which completely replaces ActionView with cells. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn3\">\n<p>Reading the <code>call</code> code definitely helps. You'll see that the implementation is simple and straight-forward. Go check out the <code>Cell::ViewModel#call</code> method to see how it's done! <a href=\"#fnref3\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>Forms. For some people, that is just a collection of input fields, buttons and checkboxes. After a few cumbersome seconds of filling out, you punch the submit button and wait. However, forms are more. Forms are the interface between users who are mostly human beings, and the machine. A form is the only way to communicate with the computer.</p>\n\n<p>I know, this sounds dramatically, and there should be the theme of <u>Terminator II</u> playing in the background now.</p>\n\n<p>But think about it. Operating a machine as an end user and telling it what to do needs an interface. And it doesn't matter whether this interface is a command line, a document-based JSON API or a beautiful web form with colorful sliders and a grid-backed layout - once the input got submitted, it's needs to be validated, processed and further actions have to be taken.</p>\n\n<p>This is the reason why I decicate this chapter to complex forms, again. Forms will always be the pivotal element of web applications. We will learn how to dynamically populate an object graph, validate it and persist the graph to the database.</p>\n\n<p>In the next chapter, I will discuss callbacks and how they can be attached to hooks in the form to post-process the application state change.</p>\n\n<p>The code for this chapter is <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-07\">on Github.</a>.</p>\n\n\\n\n\n<p>Do you remember when we started working on creating <u>things</u> in chapter 3? We implemented a form with title and description for a thing.</p>\n\n\n;;;\n\n<p>A few dozens pages later we wrote the functionality to add comments to things. In the comment form you did have to specify an <u>author</u>, or better, their email address.</p>\n\n<p>I would like to extend the thing form now.</p>\n\n<p>Say you add your own gem as a thing to Gemgem, or a book you know the author of. It'd be cool if you could add authors just as we create or update a thing.</p>\n\n<p>Authors of things can either be existing or will be created on the fly. In the following chapter, we will then use callbacks to notify users of their new authorship, to join Gemgem, and so on.</p>\n\n\\n\n\n<p>Regardless of how we visually turn over that feature, the data modelling is quite obvious. Things need to be associated with users. Luckily, we already added the <code>users</code> table and model in chapter 5.</p>\n\n<p>Being good Trailblazers, we're allowed to add associations to the ActiveRecord model class. That's where ActiveRecord is really good at. Its relational table abstraction is amazing, too bad it got stuffed with unnecessary, confusing features like callbacks and observers.</p>\n\n<p>Anyway, while I wrote some migration code to extend our database schema, the only important addition here is that after this change the <code>Thing</code> model knows about the relationship to authors, or users.</p>\n\n\n;;;\n\n<p>In the final version of the new thing form there will be three author fields where emails can be filled in. I simply decided that three is a nice threshold to begin with. Allow people to add a maximum of three authors. We can always increment this limit later.</p>\n\n<p>I'm a very visual person. Actually I'm not. But let's pretend I am. Why not start with making the actual web form display three user email fields under the existing elements, just as you can see it on the screenshot above.</p>\n\n<p>This starts with adding a new property to the <code>Thing::Create</code> contract.</p>\n\n\n;;;\n\n<p>I use <code>collection</code> to declare that this form is now supposed to take care of a bunch of authors. Note that I call the property <code>users</code>, even though we speak of authors (line 6). We could rename the association in <code>Thing</code> and all that, but at the moment, there's no need to do that.</p>\n\n<p>Since we want to display an email field, I add just that, along with a few validations. The email always has to be filled out, and it has to be a valid email (line 8).</p>\n\n\\n\n\n<p>This form is rendered in <code>ThingsController#new</code>. When browsing to <code>/things/new</code>, we get disappointed, again. The form builder didn't render any user or author fields!</p>\n\n<p>And I am pretty sure you know the answer, yet. There are no users attached to the brand-new <code>Thing</code> instance that was created when presenting the <code>Thing::Create</code> operation. We could override the <code>Operation#setup_model!</code> method as we did it in chapter 5 and add users there.</p>\n\n<p>Nevertheless, I'm more and more becoming a fan of Reform's prepopulation semantic. It's an easy and clean way to add models to the form so they get rendered when presenting the form. In order to do so, all we have to do is adding a <code>:prepopulator</code> option.</p>\n\n\n;;;\n\n<p>Now this looks a bit different to the prepopulator we wrote in chapter 5. I did this on purpose to show you two alternatives of implementing dynamic parts of the form. We were using a lambda block right in the property definition in the earlier chapter. This is cool for short assignments.</p>\n\n<p>In this form, I use an instance method to implement a prepopulator. Reform allows that: when you provide a <code>:symbol</code> it will call just that method when the option is invoked (line 2 and 8-10).</p>\n\n<p>What I do in the new prepopulator are two things.</p>\n\n<p>First, I find out how many empty, or new, users to add to the form. This works by querying for the actual user count in the form (<code>users.size</code>) and substracting that from 3 (line 9). In our <code>Create</code> use case, the initial size will always be zero, as no user is added, yet, but it starts to make sense in the <code>Update</code> version of this form.</p>\n\n<p>After finding out how many, I add the new user objects to the form. By using the form's <code>#users&lt;&lt;</code> writer (line 9) nested forms can be added. Please <u>always</u> use the form's public API when adding, removing or changing nested forms. I keep stressing this because <code>#users&lt;&lt;</code> doesn't simply add the user instances, it wraps them properly in nested user forms and attaches them to the main form.</p>\n\n<p>Keep in mind that your form object graph is a mirrored version of your actual model graph. Assuming that the thing model keeps three users (or authors) attached to itself, the thing form will contain three author forms, that in turn wrap one user model each.</p>\n\n<p>This allows you to add, change and remove nested forms from the parent form without propagating that to the persistence layer. In our example, we add users to the thing. However, and now listen, this does not happen on the model layer, but on the form, only. The underlying models do not know about changes of the form graph, yet.</p>\n\n<p>The separation of domain and persistence is a crucial point in Reform. You can play with your domain object graph as much as you want, add forms, change values, and so on - it won't touch the database before you hit <code>#sync</code>. We'll explore population a bit more in a few minutes. In a later chapter, when we talk about the <u>Twin</u> pattern, we'll go into detail how this is possible.</p>\n\n<p>When we browse to the <code>/things/new</code> page now, the form is displayed and offers us to fill out three author email fields. Yay!</p>\n\n\\n\n\n<p>As soon as you fill in at least one email address and submit the form, we get a familiar exception.</p>\n\n\n;;;\n\n<p>The form couldn't be validated because we didn't populate it properly. This is something we already know from chapter 5. While we managed to get the rendering of the form running, we missed to write a populator for validation.</p>\n\n\n;;;\n\n<p>Here's the steps explained once again.</p>\n\n<p>The incoming form input contains an array, each item fragment represents the input for one nested user form (1). Reform tries to assign each user hash to a nested form, but there is no nested form, yet (2). Please keep in mind that we did not call <code>prepopulate!</code> as this is only meant for presentation, not for validation of the form.</p>\n\n<p>In order to dynamically create nested user forms, we need to take care of validation population. How tiresome, this whole form processing thing!</p>\n\n\n;;;\n\n<p>This is where <code>:populate_if_empty</code> enters the stage, our old friend from chapter 5. This option is only invoked when the incoming hash fragment doesn't have a corresponding nested form to be assigned to.</p>\n\n<p>Again, I use an instance method to implement the option as this feels less clumsy (line 3). The referenced method has to be placed in the contract that defines the option.</p>\n\n\n;;;\n\n<p>In the populator method, we have access to the corresponding runtime options. Most commonly, you will only need to access the <code>:fragment</code> part, which is the incoming fragment in <code>params</code> that is mapped to this nested form (line 3)<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>.</p>\n\n<p>This method is called for every hash fragment that does not have a nested form, yet. As per documentation, the return value of an <code>:populate_if_empty</code> option will be automatically wrapped in a nested form and added to the main form.</p>\n\n<p>Pretty convenient, this option, so all I have to do is try and find an existing user with the provided email address or create a new user object (line 4). If I were an ActiveRecord expert I'd use <code>find_or_instantiate</code>, but I'm not, so I do it manually.</p>\n\n<p>When filling in an email address from an existing user, our populator code finds that user, and Reform wraps it in a nested form. If the email is not existing, yet, a new user object is created and gets wrapped by Reform, too.</p>\n\n<p>At the same time, when filling in some bogus email addresses in the provided fields and submitting the form, we get an erroring form complaining about invalid email addresses. So, validation seems to be working now. Strike!</p>\n\n\\n\n\n<p>One thing that could be improved is unnecessary validation errors: Currently, we get errors for invalid emails even when the email fields are blank.</p>\n\n<p>The reason is that Reform doesn't know that a blank string is not an email, so when populating the form in <code>validate</code>, it creates a nested user form for blank emails, too. While this is the correct behavior in our case this is not desired.</p>\n\n<p>Luckily, Reform comes with an option to do just that: <code>:skip_if</code>.</p>\n\n\n;;;\n\n<p>The <code>:skip_if</code> option allows to dynamically decide whether or not an incoming fragment should be deserialized to populate the form. The shortcut <code>:all_blank</code> is a macro that will skip population when all fields of the form are empty. Adding this option will prevent Reform from adding empty users (line 4).</p>\n\n<p>In a later section we're going to discuss how to use the <code>:skip_if</code> option with a hand-written piece of code. This option is extremely helpful for various reasons - you'll see.</p>\n\n<hr>\n\n<p>We can create things, add existing and new users and skip empty forms automatically. Pretty cool. I don't know about you but I'm ready for the next business requirement!</p>\n\n\\n\n\n<p>Form population is something you might not be used to from Rails, which does population <q>somehow</q>.</p>\n\n<p>I want to briefly talk about what has happened right now. To me, it's extremely important that future Trailblazers understand the concepts and thoughts behind the form object graph representing your domain, and the decoupling of the persistence and models.</p>\n\n<p>An easy way to find out what the form really did in <code>validate</code> is to introspect it in the operation. In the next few sections we're gonna play in <code>Thing::Create#process</code> to learn more about form internals.</p>\n\n<p>Usually, I use <code>raise</code> and <code>inspect</code> to find out what is going on at a particular point in my application. Surely, a debugger tool would help here, but let's do it the simple way for now.</p>\n\n\n;;;\n\n<p>A simple <code>raise contract.inspect</code> will print you the - horrible looking - form instance right into your browser. As I put the raise statement after the validate block, I get insight into the form after validation has happened (line 8).</p>\n\n<p>For example, say you enter an invalid email address. You could then change the raise statement as follows to inspect the actual errors.</p>\n\n\n;;;\n\n<p>A quite convenient way to see what the validations really assert. Instead of trusting the form builder and its rendering of error, this is a quick way to get to the bottom of the internal workflows.</p>\n\n<p>Now, to understand the population that has happend, I want you to change the debugging code a bit.</p>\n\n\n;;;\n\n<p>The last statement outputs the nested user forms that were created to handle the form submission. Admittedly, the inspect string is not beautiful but it quickly shows us some interesting facts.</p>\n\n\n;;;\n\n<p>This is an array of nested user forms. To keep it simle I only filled in one email address in the web form. As you can see, the email property is set and keeps the string I entered (line 1). Apparently, the form also tracks what fields were changed, but more about those implementation details at a later point (line 3).</p>\n\n<p>What's more important is that the model we created in the <code>:prepopulate_if_empty</code> option is effectively wrapped by this nested form (line 2). The form keeps the model in the <code>@model</code> instance variable. And, as I promised you, no attributes have been set on the model, yet.</p>\n\n<p>The form object indirects the input from the actual persisting model.</p>\n\n<p>Another crucial thing to see is that the <code>User</code> model has been instantiated and wrapped inside the user form, as we just found out, however, the model has not been <q>physically</q> associated to the <code>Thing</code> model, yet.</p>\n\n\n;;;\n\n<p>Here, I access the contract's model (the actual thing) and print the associated users, which turns out to be an empty array. That in turns means no users have been linked to the thing <u>model</u>, yet.</p>\n\n<p>Now, what if I submit a form with an existing email address? Then the populator is gonna find the user and wrap it in a nested form. Check out what the validated form looks like.</p>\n\n\n;;;\n\n<p>Indeed, the populator didn't create a user but wrapped the existing model in the nested form (line 4).</p>\n\n<p>This is exactly what Reform is designed to do. Create an object graph from arbitrary input, validate and process it and then, when you're happy with it, persist it to the database by syncing the properties to models.</p>\n\n\\n\n\n<p>Speaking of syncing: we already have the remaining code in place to process the form and save it. This is the original code from chapter 5.</p>\n\n<p>Let's be crazy and do some more debugging. I want to see what the form does after I call <code>save</code>.</p>\n\n\n;;;\n\n<p>I moved the <q>debugger</q> into the <code>validate</code> block and after the form's <code>save</code> invocation (line 5). Doing so will raise the exception after all work has been done, and I'm expecting the same form, but this time the models should be persisted.</p>\n\n<p>Note that I'm directly accessing the <code>Thing</code> model's users and inspect those.</p>\n\n\n;;;\n\n<p>As expected, an array with one persisted user model. After calling <code>Form#save</code>, the form takes care of associating nested models to the parents, syncing and saving<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>. I find this quite convenient, and also clean.</p>\n\n<p>I hope the debugging didn't scare you. It's meant to help you understand how Reform and Trailblazer works, and that there's no magic at all. At every step you can grab the respective object you don't understand and introspect it.</p>\n\n<p>This is fundamentally different to The Rails Way, where, once you invoke a public method, you completely lose track of what does what, as Rails doesn't use objects with limited scopes but usually processes everything in one big class - the model.</p>\n\n<hr>\n\n<p>Rendering a new form, validating and saving the nested object structure is now properly implemented. We have to use two options <code>:prepopulator</code> and <code>:populate_if_empty</code> but it makes sense to have two separate implementations here.</p>\n\n\\n\n\n<p>While we sit there and celebrate our success story of implementing a quite complex form, it knocks at the door. It's one of our fancy business people. Oh no. Work.</p>\n\n<p>And this time, it's <u><q>really urgent</q></u> requirement, a decision from the very top level, which is actually a <u><q>fix</q></u>, because you, the developers, <u><q>forgot to implement that</q></u>, maybe because it has never been specified. Whatever.</p>\n\n<p>We need to add the concept of authorships. When adding a user to a thing, this should be marked as an unconfirmed authorship. Users have to manually confirm that they are authors of particular projects. And to make it extra hot: Users can only be added to maximum five things without confirming their authorship.</p>\n\n<p>Luckily, we don't have a user section in our app, yet, which means we don't have a place where users can confirm their authorian existence. We need to implement the new association, though, and add some more validations. Five minutes, ok?</p>\n\n<p>The authorship is supposed to associate a user and a thing, along with meta information like the confirmation date, status, and so on. This cries for a new model.</p>\n\n\n;;;\n\n<p>For a better understanding, here's an excerpt from the migration for this new table.</p>\n\n\n;;;\n\n<p>As you can see, I added a <code>confirmed</code> field which represents the status of the authorship per user and thing.</p>\n\n<p>I just learned about the <code>:through</code> relationship in ActiveRecord - and add it to <code>Thing</code>.</p>\n\n\n;;;\n\n<p>The old (and apparently uncouth) <code>has_and_belongs_to_many</code> relationship is replaced with <code>has_many :through</code> association, both in the thing and user model classes. This allows to have a many-to-many relationship with the <code>Authorship</code> model in the middle.</p>\n\n<p>I daresay that I like the way ActiveRecord does this and I was positively surprised that the old code kept working after I changed to this new association scheme.</p>\n\n\\n\n\n<p>So far, we don't need to change any code. When calling <code>save</code>, the form will still use the public writer <code>Thing#users=</code> when assigning the users collection to the thing. ActiveRecord will implicitely create authorships for us, or skip creating them, in case they do exist already.</p>\n\n<p>We still need to set the created authorships to <u>unconfirmed</u>. While we could use a database default - and this is what you were thinking of, right? - let's do it by hand, just for the fun of it.</p>\n\n<p>This manual step doesn't really fall into the typical CRUD category. Non-CRUD logic usually goes into the operation's <code>process</code> method.</p>\n\n\n;;;\n\n<p>Instead of using weird ActiveRecord callbacks or observers or whatever <q>best practice</q> the Rails Way's  got in stock, I add a method invocation <code>reset_authorships!</code> into my create's <code>process</code> method (line 6). Note that this additional logic is called <u>after</u> we let the form sync and save submitted data.</p>\n\n<p>The implementation of this step goes into the same operation. At any point in an operation, you can retreive the model using the <code>model</code> reader. I iterate all authorships of the thing we just created and use <code>update_attribute</code> to set the confirmed status to zero (line 12).</p>\n\n<p>I don't get tired of repeating this, over and over again: Trailblazer does not have a problem with ActiveRecord or any other ORM per se. I just used its API to change persistent application state, and that is what I love ActiveRecord for. It is completely legit to use <code>update_attributes</code>, muck around with table fields and so on. As long as this code does not sit in the model itself, this is perfectly fine.</p>\n\n\\n\n\n<p>We now have to make sure a user can only have a maximum of five unconfirmed authorships. Let's do this in a validation, cause that's what they were made for. As this validation is <u>per user</u> this goes directly into the nested user form.</p>\n\n\n;;;\n\n<p>The <code>validate</code> class method allows us to add arbitrary validation methods to forms (line 3). Those mehods will be invoked when the form gets validated, along with all the other formal validations you might have specified.</p>\n\n<p>In the nested form, I add the <code>authorship_limit_reached?</code> method to implement the validation (line 5-8). Please note that all this code sits <u>in</u> the nested form's block. A nested form created with <code>collection :users do .. end</code> will simply create a new class for that form. We can add validations and methods without polluting the surrounding form or further nested ones.</p>\n\n<p>I count if the authorships count is less than five and return if that's the case (line 6). No further action has to be taken if the count is less. Otherwise, I add an error message and mark the form as invalid (line 7). This will keep the operation from further processing.</p>\n\n<p>Since this is all in a nested form class, <code>model</code> here refers to a user, not a thing! Remember, every form wraps around a model. We were just working in the nested user form, so the model is obviously a reference to the user.</p>\n\n<p>Another validation that is still missing is limiting the maximum users per thing. This is not really business critical but I'll add it anyway, so the managers can (or can't?) blame me later.</p>\n\n\n;;;\n\n<p>To assert we're not exceeding the number of added authors and kill our poor database, I use another formal validation that caps the maximum user count to three (line 5). This validation sits in the main form as it counts the total amount of users, and is not applicable per user.</p>\n\n<p>The used validator <code>length</code> is usually for strings but works great for collections, too. All it does is calling <code>users.size</code> and as <code>users</code> happens to be an array subclass it responds to size. A deep and profound way to validate collection size.</p>\n\n<p>Isn't it a  satisfying feeling, to have all validations in place? Will make us sleep well. But, hey, how do we know all those validations really work?</p>\n\n<p>Right! Before we go on to the updating form, we need to test what we just implemented.</p>\n\n\\n\n\n<p>Tests still go into the <code>test/concepts/thing/operation_test.rb</code> file. We might think about splitting up once the file reaches the critical limit of about 200 lines of test code.</p>\n\n<p>As done before, I won't discuss every test case in detail and skip a few. All tests are <a href=\"https://github.com/apotonick/gemgem-trbrb/blob/chapter-07/test/concepts/thing/operation_test.rb\">in the repository</a> and well commented.</p>\n\n\n;;;\n\n<p>The first test asserts the email validations. I run <code>Thing::Create</code> with two invalid email addresses (line 4-8) and then make sure validations complain about the wrong emails (line 11). To make sure nothing has been written to the database, I also inspect the operation's model (line 12).</p>\n\n<p>In the next test case the <code>:skip_if</code> option is tested. You might be wondering whether this is a redundant test, and the answer is actually <u><q>yes</q></u>. This option is well tested in Reform itself, nevertheless, let's write a quick test for educational purposes.</p>\n\n\n;;;\n\n<p>Running the operation will work and create a new thing instance (line 2). By testing that <code>model.users</code> returns an empty list I assure no stale ghost users have been created.</p>\n\n<p>The following test creates a valid thing along with one new and one existing user.</p>\n\n\n;;;\n\n<p>For setup, I create an existing user (line 2). Note the <code>TODO</code> at the end of the line. I use ActiveRecord directly, as we do not have an operation, yet, to create a user.</p>\n\n<p>I then run the operation, as already mentioned, with the existing user's email and a new one (line 4-7). The newly created model must have two users now (line 9). It's not that important to test that the first user, the existing one, has the same attributes as it had before. This is more me being paranoid that things might have gone wrong (line 10-11).</p>\n\n<p>The second user should have the email address we provided (line 12). And as a last constraint, both created authorships must have a zeroized <code>confirmed</code> field (line 14). You haven't forgotten that both user and thing point to the authorships, so I can safely use <code>thing.authorships</code> here to retrieve the information I need.</p>\n\n<p>Another test will check that we can only create three authors as a maximum.</p>\n\n\n;;;\n\n<p>The <code>times</code> method strikes again and helps to setup four emails (line 2) which I pass into the operation call (line 3). When checking the error message you can see that it says <q>characters</q> instead of <q>users</q> (line 6-7). This is due to the <code>length</code> validators nature of testing strings, normally. As this validation breach will never happen under normal conditions, I don't care. The likeliness that someone hacks my HTML form to add another user shall be rewarded with this funky error message.</p>\n\n<p>In the last test we examine one of the last validations we added: A user can only have a maximum of five unconfirmed authorships.</p>\n\n\n;;;\n\n<p>Can you tell that I get into using <code>times</code> to generate test setups? I run the create operation five times, with a different name and the same user each time (line 3). This will create five things with the same user. After running, the user will have five unconfirmed authorships. The sixth time, still with the same user, should fail as this doesn't comply with the management's desires (line 4-8).</p>\n\n<p>I love how factories completely become redundant. Since I use Trailblazer, I don't even think of test factories anymore, the environment setup strictly use the application's public API. And those are operations.</p>\n\n\\n\n\n<p>To complete this section, we need to add two more tests to the thing integration test at <code>test/integration/thing_test.rb</code>. Proper rendering of the extended form has to be verified.</p>\n\n<p>First, the form when rendered in <code>/things/new</code> context is examined.</p>\n\n\n;;;\n\n<p>When visiting the form to create new things, we should see three input fields in order to add users (line 5). The same should happen when viewing a submitted, invalid form. I added a test but save the paper here, since it is identical.</p>\n\n\\n\n\n<p>We should also allow users to change their author selection after creation. Quite productive, as we are, we already implemented the <u><q>edit thing</q></u> operation in chapter 3, and you surely remember that the only change from the create form was to disable users from changing the thing title. We implemented that by making the property readonly.</p>\n\n<p>While I do want to provide additional email fields to add authors in hindsight, existing authors should be readonly. Instead of allowing to change their email address, which doesn't really make sense, I'd rather add a button to remove the user from the thing.</p>\n\n<p>This won't delete the user from Gemgem, but only remove the particular authorship.</p>\n\n<p>When adding new authors through the form we're working on, they will be persisted as users in the database. In the next chapter, we will send out an email to them, asking them to join Gemgem. They might or might not see a list of authorships to confirm, then. As I just said, clicking the <u><q>Remove</q></u> checkbox in our edit form won't touch the user, it will delete the authorship, only.</p>\n\n\\n\n\n<p>In order to provide a <u><q>Remove</q></u> button in the edit form, we need to change the form's view in <code>app/views/things/new.html.haml</code>.</p>\n\n<p>Remember, the form view is used for both creating and editing. The sad news here is, we will use several helper methods in the view from the update form. Those methods are only available in the update form so far. This is why I have to introduce this incredible ugly switch.</p>\n\n\n;;;\n\n<p>As you may have noticed, I'm using methods like <code>removeable?</code> directly on the form object. Since I will add this <code>removeable?</code> method only to the <u>update</u> form, this view - without the switch - would break when presenting the <u>create</u> form.</p>\n\n<p>And, yes, this is horrible code. I mean, I don't have problems with deciders in views, but this just makes my eyes bleed. This is to make you feel the pain of Rails' lack of a proper view layer with polymorphic concepts. Later, not in this chapter, though, this form will become a true view component using view inheritance to tackle with different contexts.</p>\n\n<p>For now, bear with me, and accept that I just used <code>if/else</code> and <code>instance_of?</code> in a view. Let's walk through it step by step.</p>\n\n<p>First, I use the <code>@operation</code> instance variable to decide the context of this view. By using <code>instance_of</code>, and I hate it, I find out whether to render the create or the update fields (line 3).</p>\n\n<p>Normally, in create mode, we will simply render an email field (line 4).</p>\n\n<p>When updating, things get a bit more tricky. I still add the email field, but make it visually readonly when <code>a.object.removeable?</code> returns true (line 6). This mysterious invocation happens again, and when true, adds another field to the form named <code>remove</code>. The remove field is a checkbox, and unchecked per default (line 8-9).</p>\n\n<p>What is going on here, and especially what is this <code>removeable?</code> call about?</p>\n\n\\n\n\n<p>I am using <code>fields_for</code> to render the three email fields. This form builder method will iterate over the thing form's <code>users</code> and yield the <code>a</code> object to the nested block. This <code>a</code> is another form builder object that wraps a user form. By invoking <code>a.object</code> I get access to the nested  user Reform object.</p>\n\n<p>Again, this is really clumsy and not ideal, in my opinion, but for now it has to do the job. Just keep in mind that <code>a.object</code> returns a nested user form object, and every method we invoke will be called on the user form.</p>\n\n<p>In this example we use the <code>removeable?</code> method. This method doesn't exist in the form and we need to implement it. We need to jump back into the <code>Thing::Update</code> operation's contract.</p>\n\n\n;;;\n\n<p>The <code>removeable?</code> method is implemented in the <code>users</code> property (line 9-11). This will allow calling this method for every nested user. So, when calling <code>a.object.removeable?</code> this very method will be invoked!</p>\n\n<p>In this method I simply check whether the wrapped user model is persisted (line 10). I can access the form's model at any point using <code>model</code>, and I use ActiveRecord's <code>persisted?</code> on it to find out whether this nested form is representing an empty user or showing the actual email of an existing one.</p>\n\n<p>Only existing users, or authorships, should be removeable, and in this case, <code>persisted?</code> does the trick.</p>\n\n<p>Let's recap. The update form shows a bunch of filled out email fields, each representing an existing user that was added as an author earlier. The update form might also render a few empty email fields, depending on how many authors are already added.</p>\n\n<p>The <u><q>Remove</q></u> checkbox shall only appear for <q>real</q> authors, that are already added to the thing. A decider <code>removeable?</code> is introduced to find out whether or not this form is wrapping a <q>real</q> user.</p>\n\n<p>This decider is then used in the view to render, or not render, the checkbox to remove. It's too easy.</p>\n\n\\n\n\n<p>I am pretty sure you've been wondering the last few minutes about the <code>:inherit</code> option, and where all the properties from the nested <code>users</code> form have gone to.</p>\n\n\n;;;\n\n<p>We're now getting straight down to the nitty gritty of forms and inheritance.</p>\n\n<p>The <code>Update</code>'s operation form is inherited from the <code>Create</code> operation form. Trailblazer does that internally when you subclass an operation. Inheriting a contract means all the properties and nested forms, the helper methods you added, the validations, and so on will be inherited, or copied, to the new class.</p>\n\n<p>In an object-oriented environment it is desired to override specific parts of the inherited class. And that's what I do when defining the new <code>collection :users</code> form. I override this part of the original form.</p>\n\n<p>However, when I omit the <code>inherit: true</code>, the entire nested form class will be overridden with the new class I just specified. This means that we will not only lose all the properties defined in the original class, but also validations.</p>\n\n<p>You can play around with this option to understand it better now. Remove the <code>:inherit</code> option and see what happens.</p>\n\n\n;;;\n\n<p>The rendering of the update form will crash now, as the <code>email</code> property couldn't be found. Now, add the property manually.</p>\n\n\n;;;\n\n<p>Now the form will render, but you'll see that you lost all the validations, and so on.</p>\n\n<p>When confused, always try to picture the <code>:inherit</code> option like the <code>super</code> call in Ruby, because that insired me when I designed it.</p>\n\n<p>When you override a method, it's gone. Your new method implements this method now. This is when you call <code>property</code> without the inherit option in a derived contract.</p>\n\n<p>However, once you use <code>inherit: true</code> it's a bit like the <code>super</code> method, in a declarative meaning. It says <u><q>Let me override this directive, but inherit all options, nested properties, and so on, from the original property!</q></u>.</p>\n\n<p>The <code>:inherit</code> option is a powerful concept to allow real object-orientation on a declarative level. A lot of work has gone into designing, implementing and testing this feature and many projects benefit from it with clean, DRY forms for different contexts.</p>\n\n\\n\n\n<p>Having the inheritance part in place, we should try and render the update form. It will raise an exception, as the form builder requires the <code>remove</code> property. This error comes from the view.</p>\n\n\n;;;\n\n<p>When rendering the form, the form builder queries for every field it is assigned to render. This means we can either add an empty <code>remove</code> method in the nested user form, or use a virtual property, which does exactly the same.</p>\n\n\n;;;\n\n<p>Now the user form got two properties. The <code>email</code> is inherited, the <code>remove</code> property is added and casted into a virtual field. Virtual fields are not readable and not writeable, meaning Reform neither will ask the model for the value of this field, nor will it try to write the new value back to the model when syncing.</p>\n\n<p>Often, virtual fields are used for password confirmation fields and the like.</p>\n\n<p>The form now renders, and, hey, cool, for existing authors it shows a remove checkbox. And now the sensational feature: clicking a checkbox and submitting the form should unlink the user from the thing and delete the authorship, while letting the user alive!</p>\n\n\\n\n\n<p><u><q>I clicked the remove checkbox for an author when editing a thing, punched submit and it didn't get removed, it's still there.</q></u> This, or a similar message, will be the first bug report in your inbox should you have shipped Gemgem right now.</p>\n\n<p>Of course, the remove checkbox is something we invented just now - this is not a feature of Reform. We have to write that functionality ourselves. Nevertheless, Reform makes it pretty simple to implement it, so let's make the remove button actually do what it says.</p>\n\n<p>Removing users only works from an editing form, which is processed by <code>Thing::Update</code>. Implementation happens in its contract in <code>app/concepts/thing/contract.rb</code>.</p>\n\n\n;;;\n\n<p>You're about to learn about the <code>:populator</code> option. This is the most powerful and flexible directive to fine-tune your deserialization. In fact, <code>:populate_if_empty</code> is a macro implemented using this option, and hence provides a subset of its features, only.</p>\n\n\n;;;\n\n<p>By providing <code>populator: :user!</code> I configure a populator method that will be called for each users fragment in the incoming hash (line 4). While I could also write my populator as a proc, I prefer methods.</p>\n\n<p>Now, don't confuse that with the <code>:populate_if_empty</code> option. The latter one is only called when Reform can't match the incoming fragment to a nested form. The <code>:populator</code> is <u>always</u> called and you have to make sure the correct nested form is returned. While this is more work, you have control over the entire deserialization process.</p>\n\n<p>The method implementing the populator needs to be an instance method of the form defining the property.</p>\n\n\n;;;\n\n<p>As all dynamic options in Reform, it receives an options hash as the only argument. I use keyword arguments to extract the <code>:fragment</code> and the <code>:index</code> key (line 3).</p>\n\n<h3>Populator: The <code>fragment</code>\n</h3>\n\n<p>The <code>fragment</code> hash is of peculiar interest here. For a newly submitted author, this will look as follows.</p>\n\n\n;;;\n\n<p>This is the extracted fragment from <code>params</code> that matches to this form.</p>\n\n<p>For an existing author with an authorship, this hash might look a little bit different.</p>\n\n\n;;;\n\n<p>The fragment now contains the user's id and the remove flag, too. While the remove field comes from the actual form input field we added earlier, the id is added automatically by Rails' form builder.</p>\n\n<p>With this in mind, recall the upper part of the <code>user!</code> method. If the <code>remove</code> field is set, we trigger the delete behavior (line 4). I grab the fragment's <code>\"id\"</code> value and find the respective user (line 5). Note that I can use <code>users</code> here, which resolves to <code>form.users</code> as this is an instance method of the form. That way, I simply iterate the form's users and find the delete candidate - in my last input example, this would be the user with email <q>nick@trb.to</q>.</p>\n\n<p>I then call <code>users.delete</code> and pass in the candidate (line 6). This will <q>physically</q> remove that item from the form's users. However, and now stay calm, this doesn't change any persistent data, yet. This mysterious <q>nick@trb.to</q> user is only deleted from the runtime object graph. The form will remember that, though, and apply persistent changes when you call <code>save</code>.</p>\n\n<h3>Populator: skip!</h3>\n\n<p>After the user has been removed, I <code>return skip!</code> (line 7). This will stop execution of the populator method. At the same time, it will tell Reform to stop deserializing this fragment, and move on to the next fragment, just to start the same cycle of deserialization again.</p>\n\n<p>The <code>skip!</code> instruction, and note that you have to <code>return</code> it, is extremely helpful for customized deserialization. You can use it in <code>:populator</code> to stop further processing of a fragment. For example, say you had a validation that should happen upfront, before the object graph is being generated, and that should suppress certain fragments, <code>skip!</code> is your friend.</p>\n\n<p>Now, the remaining part of the populator.</p>\n\n\n;;;\n\n<p>When deserializing a collection fragment, Reform knows where it is. As the populator is called for every item fragment, the populator receives the index. After we've ruled out this item is not a deletion, I check if there is already a user existing for that fragment (line 3). If that is the case, I also skip the rest of its deserialization.</p>\n\n<p>I do this because we do not allow updating any of the user's attributes via this form. By skipping if user exists, the fragment is discarded and everything on the nested form will remain the same.</p>\n\n<p>If the fragment does not represent a deletion, and no user corresponds to it, I add a new <code>User</code> instance at position <code>index</code> to the form's <code>users</code> collection (line 4). The return value of this statement is important, that's why it is the last line of the method.</p>\n\n<p>You might be wondering how we handle the <code>:all_blank</code> function? The <code>:skip_if</code> option is inherited from the original contract. And, since this option is evaluated before the populator, empty fragments are exluded from deserialization automatically, we don't have to consider this case in the populator.</p>\n\n\\n<p>Before we discuss how this deletion gets propagated to the database, I invite you to some more debugging. This is how I learned programming.</p>\n\n<p>Create a thing with two authors, and then edit it. Now, tick one of the two authors for removal. In <code>Update#process</code> add a raise <u>before</u> you call validate.</p>\n\n\n;;;\n\n<p>In the exception you will identify two nested user forms. This makes sense as no deserialization has happened, yet, and we see the original edit form.</p>\n\n\n;;;\n\n<p>When moving the raise into the <code>validate</code> block, and supposed you checked the second author for removal, here's what the form graph now looks like.</p>\n\n\n;;;\n\n<p>The <code>users.delete</code> from the <code>user!</code> populator literally <u>deleted</u> the nested form from the object graph. How does this get persisted, though?</p>\n\n<p>It's simple. When calling <code>save</code> on the form, it will sync all its properties back to the original <code>Thing</code> model. This implies calls like <code>thing.title=\"Rails\"</code>, or <code>thing.description=\"\"</code>, but this also assigns nested properties.</p>\n\n<p>Given the example scenario I just used, the <code>users</code> property invocation will look as follows.</p>\n\n\n;;;\n\n<p>As can be seen from this snippet, Reform (actually, this happens in Disposable) simply pushes the nested form's models to the collection writer. And since we <u>deleted</u> the second nested form, the collection synced back to the model does only consist of the first author.</p>\n\n<p>The great thing about the syncing is: ActiveRecord will take care of the rest. It will delete the authorship for us automatically when updating the <code>users</code> property with the new, smaller collection.</p>\n\n<hr>\n\n<p>Both the create form and the update function work exactly the way we want now. Users can be created, validations make sure they don't exceed certain limits. Empty forms are ignored. Existing fields can't be changed.</p>\n\n<p>Let's write a few quick tests for the <code>Update</code> operation.</p>\n\\n\n\n<p>Following the same path that we did for the create tests, I start with a rendering test of the edit form in <code>test/integration/thing_test.rb</code>.</p>\n\n\n;;;\n\n<p>The fixture consists of a new thing with one user (line 3-4). I then request the edit form for the thing we just created (line 6). The thing name has to be readonly (line 7).</p>\n\n<p>On the page, the first email field has to contain the correct email address from the existing user, and it must have the class <code>.readonly</code> (line 8-9). Also, the remove button has to be present (line 10). I then check for another email field just to make sure pre-population worked (line 11). This should not have a remove button, yet, as this represents a blank email field (line 12).</p>\n\n<p>After the rendering is sorted we quickly focus on extending the <code>Thing::Update</code> tests in <code>test/concepts/thing/operation_test.rb</code>. I won't go into every test case here as it becomes a very tedious and space-consuming task to discuss test cases that are sitting nicely documented on Github.</p>\n\n<p>My favorite test case is the one where we make sure existing emails can't be changed.</p>\n\n\n;;;\n\n<p>First, I create an existing user (line 4-5) using our fantastic operation. I then use the <code>Update</code> operation where I inject a different email address (line 7-8). After the operation has been run, the email has to be identical to the old, original email address (line 9).</p>\n\n<p>This test demonstrates how incredible simple it is to write edge-case tests with operations and forms. A nightmare, when I think back how that had to happened in traditional Rails with a mix of fixtures, controller- and model tests that probably had to change global state variables to achieve a <u>almost-production</u> environment.</p>\n\n<p>The other test case I want to discuss is when removing existing authors.</p>\n\n\n;;;\n\n<p>All I have to make sure is that I pass in the correct input into the update operation (line 6-7), especially the <code>\"remove\"</code> key makes sense here. After the operation, the thing's <code>users</code> collection must be an empty list (line 10).</p>\n\n<p>An important check after that is to make sure the user object still exists and wasn't erased from the database. I use the <code>persisted?</code> method for that on the original author that I saved earlier (line 4 and 11).</p>\n\n\\n\n\n<p>That chapter has been great so far. We learned a lot about forms, nesting, object graphs and all the cool possibilities we have with form objects.</p>\n\n\n;;;\n\n<p>The form object is a pivotal element in every application. Deserialization, setting up an object graph and validating it is the heart of the kind of software we write. This might result in form classes becoming bigger and more complex. At some point, and embedded in the operation class, this might be hard to work with.</p>\n\n<p>Luckily, we can simply use a separate file for our forms, since the contracts in operations are just plain classes.</p>\n\n<p>I add a new file in <code>app/concepts/thing/contract.rb</code> and basically copy and paste the contracts into it.</p>\n\n\n;;;\n\n<p>As the first thing, I define the module <code>Thing::Contract</code> (line 1). I then introduce a new class <code>Create</code> which is derived from <code>Reform::Form</code> (line 2).</p>\n\n<p>Basically, the structuring for external Trailblazer objects should be <code>Concept::Technology::Environment</code>. We will later do the same structuring with representers, in chapter 11 and 12, where we have <code>Thing::Representer::Create</code>, and so on.</p>\n\n<p>In the new <code>Create</code> class I literally just cut and paste the <code>contract do .. end</code> block from the original operation, with one exception: you have to call <code>::model</code> manually to name your class for the form builder (line 3). Another convenient thing that happens automatically in an operation.</p>\n\n<p>In order to use this form, a minimal change in the operation is required.</p>\n\n\n;;;\n\n<p>Instead of defining the form here, I assign the form to the operation via the <code>contract</code> DSL method (line 3). Note that you could reference any form you want here with namespaces and what not.</p>\n\n<p>For consistency, let's do the same for the <code>Thing::Update</code> operation.</p>\n\n\n;;;\n\n<p>Normally, the operation will inherit the contract automatically for us from its parent class. Here, we have to do this manually for <code>Contract::Update</code> (line 4). As we use inheritance, we do not have to call <code>model</code> again in the contract, this is Reform's deriving behavior. We can simply move the contract code to the new class (line 5).</p>\n\n\n;;;\n\n<p>I do not have a strict rule, yet, when to apply the form extraction to operations, but as soon as the contract has more than a few lines, I usually introduce a separate file.</p>\n\n<hr>\n\n<p>Wheew! We're Masters of the Form now!!! Let this sink for a bit, and have a cold beer. In the next chapter we're going to learn about callbacks and operations, and how to deal with more than one model per operation. Also, and this is gonna be quite cool, we'll dive into view caching and how operations can expire caches.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>In case you want to learn more about the other available parameters make sure to check the <a href=\"http://trailblazer.to/gems/reform/populator.html\">API documantation</a>. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>Actually, a lot of the <q>model</q> logic like syncing and saving is implemented in the underlying twin of the form, and not in the form itself. The form acts as a thin orchestrating layer, only. From the outside, a form might appear as a monolithic monster that has <q>too many responsibilities</q>. We will discover twins in a later chapter, and learn how forms, representers, and twins work together. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>In the last chapters we have focused on object validation and creation which was mostly encapsulated by the form twin. In real applications, you need more than that, though. After the initial object graph has been created, post-processing takes place. Things like file uploads or sending out notifications, known as <u>callbacks</u>, have been established as a concept of web development.</p>\n\n<p>Callbacks in Trailblazer go further than that and might surprise you in the way they differ to the conventional Rails Way.</p>\n\n<p>Code for this chapter you can find <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-08\">in the repository branch</a>.</p>\n\n<h3>Rails Callbacks</h3>\n\n<p>The idea of callbacks in ActiveRecord and controllers is helpful. It allows to execute a number of callbacks at well-defined points in the lifecycle of an object. In addition to that, callbacks can be added in a declarative way without having to override methods. You simply add extending behavior by calling <code>after_validate</code>, and so on.</p>\n\n<p>With the ease comes trouble, of course.</p>\n\n<p>First of all, the callback hooks Rails provides are very high-level. That alone is a good thing. It allows to extend the flow for the entire object. It does not provide a way to hook into separate properties, though. You can't attach a callback that only gets executed for the <code>email</code> field of a user, for instance.</p>\n\n<p>That is because Rails doesn't buy into the idea of schemata. A callback doesn't even know a field <code>email</code> exists as everything is inferred from the database table at runtime. Every single callback has to write their own filter logic to limit its scope to a property. Countless times I've seen logic as follows.</p>\n\n\n;;;\n\n<p>This creates an immense load of redundant logic, noise, and makes it hard to find out what is really the essence of a callback. Somewhere between the filter logic sits the actual code you're interested in.</p>\n\n<p>The other big problem with callbacks is the lack of execution context. Callbacks getting in your way by being triggered when you don't want them. Callbacks always get invoked, once defined they will be run everywhere and under any circumstances unless you take action - hacks - to prevent that.</p>\n\n<p>Where different contexts in Trailblazer usually mean subclasses or declarative overriding, in Rails this is half-heartedly implemented with conditionals. All happening in the same class, people use <code>:if</code>s to prevent callbacks from being run at certain occasions. Of course this never works as it should and you end up in <u><q>Rails Callback Hell</q></u>, evidenced by literally hundreds of blog posts.</p>\n\n<h3>Controller Filters</h3>\n\n<p>A common problem I have when jumping onto refactoring an existing Rails application is figuring out what callbacks are invoked in which request. The issue is not only understanding the model callbacks, but also what filters in a controller do.</p>\n\n<p>Controller filters in Rails can be categorized into <code>before_filter</code>, which are run before the actual code in the action method, and <code>after_filter</code>. I have never seen anyone using an <code>around_filter</code> and I don't even know how they work.</p>\n\n<p>Filters were originally meant to <u>filter</u> request integrity, hence the name <u>filter</u>. <code>before_filters</code> were added to intercept unauthorized requests, <code>after_filter</code> was then provided to clean up the mess you made in your controller action.</p>\n\n<p>The name itself manifests the problem about filters: they shouldn't be used for anything but authentication and maybe authorization. Of course, this isn't stated anywhere in the Rails books, and people use filters to do just anything in their controllers: authentication, authorization, munching the <code>params</code> hash, validations, invoking callbacks, persistence... I've seen any kind of logic in <code>before_filters</code> you can think of.</p>\n\n<p>Most filters are business logic and have no place in the controller. In Trailblazer, most of the filter logic is moved into the operation scope. We use <code>before_filter</code>s only, and limit their usage to authentication. This is the reason I won't discuss filters in this chapter but the following, where we learn how Trailblazer does authentication.</p>\n\n\\n\n\n<p>We spent quite a while on creating a user interface to allow users setting up a <u>thing</u>, add authors, and comment on things. As a next requirement, we need to notify users about their new authorship. When adding a user to a thing this should be communicated in a nice email being sent out to the author telling them <u><q>Hey, BTW, you were added to that thing!</q></u>.</p>\n\n<p>This is too easy, and you as the developer shouldn't say that aloud, because now the business adds another requirement. Depending on whether the user was just created or not the email has to contain an additional welcoming section informing the unsuspecting email owner that they were not only signed up for Gemgem and are now a valid user, no, they are also a thing author.</p>\n\n<p>Remember that non-existant users are created ad-hoc when they're added to a thing? Yepp, that means the email has to contain welcome and authorship text.</p>\n\n<p>Not that I want to go into <u>The Rails Way</u> ever again, but to give you a better understanding about why I chose to replace callbacks in Trailblazer, let's quickly discuss how we'd do the above requirement in Rails.</p>\n\n<h3>Callbacks in Rails 5</h3>\n\n<p>When it comes to emailing freshly created users, every Rails developer will instantly think of an <code>after_create</code> callback in the <code>User</code> model.</p>\n\n\n;;;\n\n<p>So far, this looks perfect. It is one line of code (without the actual logic) to be run after a new user got persisted. This could generate the welcome section for the email. Also, assuming that users are only created when being added to things, this callback could be used to generate the entire email.</p>\n\n<p>Now, how do we track when an existing users gets added as an author? This needs to send out an email, too. We push that into the <code>Authorship</code> model, of course.</p>\n\n\n;;;\n\n<p>In this callback, we encounter our first problem with Rails callbacks. This code is run whenever an authorship is created. We now have to make sure this logic gets run only with an existing user, since the new user is already handled in the <code>User</code> class.</p>\n\n<p>Even though we only have two callbacks, it starts to get complicated. I don't want to say <q>messy</q>, yet.</p>\n\n<p>Immediately the next problem emerges. In the next chapter users will be able to sign up via a separate form. This will trigger the <code>User</code>'s <code>after_create</code> hook, too, and this is wrong, because manually signed up users need a completely different email.</p>\n\n<p>Yes, we could now patch the existing code in <code>User</code> to differentiate between the two contexts, and so on, but I am not going to do this. The scenario I just illustrated is still manageable but I already hate it. Logic to handle callbacks is distributed to the persistence tier, spread over several classes, contains too much knowledge about what is going on where, and is incredible hard to understand.</p>\n\n<p>Rails callbacks are probably the worst concept in the framework. They really <u>make</u> developers do it wrong. Unfortunately, this hasn't been addressed in Rails core, yet, and I am not sure why, because even core members hate callbacks.</p>\n\n<h3>Ad-hoc Callbacks</h3>\n\n<p>I decided to completely replace callbacks with a mechanism separated from persistence and encapsulated in its own class. What works with view models, forms, representers, or operations will most probably also work with business dispatching logic.</p>\n\n<p>In order to write clean callback logic, we have several alternatives in Trailblazer. I start illustrating the simple one and will then explain the high-level Trailblazer solutions, which are still simple, but use additional code to allow you a declarative setup of nested callbacks and an imperative execution mechanism.</p>\n\n<p>Let's get back to the basics: Operations embrace an action of your application in a class. The most conclusive next step when adding callbacks to that action is: add the callback logic to your operation!</p>\n\n<p>What sounds primitive and naive is actually the simple solution to the aforementioned problem. When adding callback logic to your operation, you make sure this code is run only in this context. An operation represents a context, so it must be the right place for dispatch logic. In addition to that, the callback code is defined in one single place. Let me show you what I mean.</p>\n\n\n;;;\n\n<p>My callback is a simple invocation of a new method <code>notify_authors!</code> in my operation (line 6). This method is only called when the form's valid and got saved. Note that I call it <u>after</u> the <code>f.save</code> line, making it an explicit <code>after_save</code> callback without having to clutter logic over models. This single line is the dispatch, the business logic will happen in that method.</p>\n\n\n;;;\n\n<p>To give you an idea how this <q>ad-hoc</q> callback could look like, I implemented a sample <code>notify_authors!</code> method in the create operation. Since we have access to the model and the contract I directly access the <code>model</code>'s users and iterate them (line 4-6). For each user, I send out an email using an imaginary mailer (line 5).</p>\n\n<p>This is of course not doing exactly what we need to do. I hopefully managed to show you how simple it is to add callbacks to Trailblazer operations by simple invoking methods right where you want them to be invoked. Nevertheless, my callback doesn't send out different mails dependent on the user's creation status.</p>\n\n<p>Unfortunately, there is no way in ActiveRecord to find out if a model was just created after saving it. We could simply collect this information before we save the form in the <code>process</code> method. This is unnecessary, though, since the form object provides some cool features you're gonna love in combination with Trailblazer's callbacks.</p>\n\n\\n<p>To send out the correct emails to our thing authors we need find out whether they were created in the process of the <code>Create</code> operation, or whether they were already existing.</p>\n\n<p>Every form is a <code>Twin</code> object with validation semantics. In a form, most of the work is done by the twin - a concept we didn't officially got introduced to, yet. In fact, you've been working with twins throughout the book! Every time we were playing with forms, we were using twins, I just didn't tell you.</p>\n\n<p>It is now time to learn about twins and how they help us in callbacks.</p>\n\n<p>As you may have noticed, the API of a form is extremely simple and breaks down to the following three steps.</p>\n\n<ol>\n<li> When instantiating, the form populates its properties with the values from the decorated model. This is actually behavior inherited from <code>Twin</code> and not implemented in Reform.</li>\n<li> After instantiation of a form comes validation. The <code>validate</code> invocation will update property values and possibly add more objects to a nested form property. This is the only function provided by Reform.</li>\n<li> When validation was successful, data gets written back to the models using the <code>save</code> method. Again, this is implemented in <code>Twin</code>.</li>\n</ol>\n\n<p>This super simple life-cycle of a form, or a twin, makes it elementary to track changes. For example, we can easily find out if a model got persisted during the <code>save</code>. This works by taking advantage of the <code>Persisted</code> module which is included automatically in every form.</p>\n\n\n;;;\n\n<p>The first two lines are usually done implicitly in the operation (line 1-2). Every form, yes, even nested forms, respond to <code>persisted?</code> and will report the model's persistence status by simply invoking the model's <code>persisted?</code> reader<sup id=\"fnref1\"><a href=\"#fn1\">1</a></sup>. It is obvious that the first query will return <code>false</code> and after saving, the same method will report a persisted model (line 4 and 6).</p>\n\n<p>Now, that alone won't help us as we still don't know if the user was created just now or months ago. The innovative trick is that twins track field changes. Using this, the <code>Persisted</code> module gives us another helpful query method.</p>\n\n\n;;;\n\n<p>The <code>created?</code> method is great and has helped me a lot to write callbacks of all kinds. It simply checks if <code>persisted?</code> has changed when calling <code>save</code>. If yes, this implies the decorated model has just been created. If not, this means the model was already persisted and thus the <code>save</code> was an update, not a creation.</p>\n\n<p>Another example showing the opposite behavior will make it more understandable.</p>\n\n\n;;;\n\n<p>Repeating the same workflow with an existing thing, the <code>created?</code> query will return <code>false</code>. This is because even after saving the form, the <code>persisted?</code> flag doesn't change as the model was already persisted.</p>\n\n<p>It's important to include the <code>Persisted</code> feature into the contract, should you rely on <code>on_create</code> callbacks.</p>\n\n\n;;;\n\n<p>Including <code>Persisted</code> will now assume your contract's model responds to <code>persisted?</code> (line 3).</p>\n\\n\n\n<p>Now, let's apply this new knowledge to the problem we were trying to solve. By using <code>created?</code>, we can implement our first real callback in the create operation.</p>\n\n\n;;;\n\n<p>A few things have changed to the <code>notify_authors!</code> method. Firstly, note that I no longer work on the model, but on the <code>contract</code> (line 2). Iterating the contract's users will provide me the form objects with the twin semantics I need.</p>\n\n<p>Now, I can actually use <code>created?</code> to query if the user just got created or has been in the system before (line 3). Keep in mind that this is called after we called <code>save</code> on the form. The twin simply looks at the <code>persisted?</code> field and checks if it has changed since the form was instantiated, nothing more.</p>\n\n<p>Having found out the essentials, I can dispatch to the mailers which handle the existing and new user case (line 4 and 6). We will quickly implement the mailers at a later point. Right now I want to focus on callbacks, dispatching and differentation of application state.</p>\n\n<p>The next task is to re-add our <code>reset_authorships!</code> function from the last chapter. We needed to run this method to set all created <code>Authorship</code>s to unconfirmed.</p>\n\n\n;;;\n\n<p>In <code>reset_authorships!</code>, we blindly go through all users attached to the thing, grab the authorship models associating the two, and mark them unconfirmed. Indeed, this is a bit violent, almost brutal, and this works for creating, but will get us in trouble when updating things.</p>\n\n<p>Anyway, we'll fix this in a minute. Let me now show how I add the explicit callback in the operation.</p>\n\n\n;;;\n\n<p>You guessed right, this simply is another method invocation in the operation's <code>process</code> method. By running the callback after saving the form, I make sure the environment is as expected and all the <code>Authorship</code> instances are persisted (line 5).</p>\n\n<h3>Explicit Callbacks: Inheritance</h3>\n\n<p>So far, we added two callbacks to the <code>Create</code> operation. One to send out notifications to authors while respecting their membership status. Only freshly added authors get the extended version of the notification email.</p>\n\n<p>The second callback resets all authorships to unconfirmed state.</p>\n\n<p>In order to see the problem that arises, we need to go one step further. I want you to remember that we not only have a creating operation, but also an <code>Update</code> one that inherits from <code>Create</code>. This inherits the <code>process</code> method and will run the exact same set of callbacks for updating things.</p>\n\n<p>For the notifications, this is still going to work. The callback we wrote earlier will send out notification emails to added users, just as we did in <code>Create</code>.</p>\n\n<p>However, the second callback <code>reset_authorships!</code> is wrong. When run in <code>Update</code> context, it will reset all authorships, even the ones we created earlier. Imagine we had a way to confirm authorships, yet. The callback would ruthlessly reset every associated authorship to unconfirmed, as it doesn't check any state but runs through the collection like a berserk.</p>\n\n<p>While this is not a real problem right now because we can't confirm authorships anyway, yet, we have to fix it.</p>\n\n<p>I could overwrite <code>reset_authorships!</code> in the <code>Update</code> operation and leave the original implementation in <code>Create</code> as it is. This would show another advantage of the inheritance philosophy we use in Trailblazer.</p>\n\n<p>The actual trick I'm gonna use to fix this problem will work in <code>Create</code>, too, so I will correct the behavior for both operations at once using another feature from twins.</p>\n\n\n;;;\n\n<p>Before running through this snippet, let's reflect what we need to do. Every time an authorship is created, which means a user is associated to a thing, we need to reset its <code>confirmed</code> field to zero. This should only happen once in the authorship's life! In no way should we reset it again, especially not when the confirmed flag has flipped.</p>\n\n<p>As promised, another trick from the <code>Twin</code> API is exposed here.</p>\n\n<p>In line with the first callback example, I work on <code>contract</code> in the callback method, as this gives me the twin API (line 4). I loop over the <code>users</code> for this particular thing (line 4-7). In the iteration I filter out some particular users.</p>\n\n<p>And this is the interesting part. The twin collection also tracks which users have been added since we created the form. It allows me to compare the currently iterated user and the <code>added</code> array which contains users that have been newly added, only (line 5). Using this technique, I can really limit this loop to recently added user objects. I access the nested user form's <code>model</code> which is of course a <code>User</code> instance. The associated authorship's confirmed flag gets zeroed, and everything is perfect (line 6).</p>\n\n<p>We will encounter a few more handy tracking methods the twin provides for us in this chapter. Regardless of the details, let's quickly think about what we has changed.</p>\n\n\\n\n\n<p>In Rails callbacks happen at well-defined events. The ActiveRecord life-cycle defines those events, like <code>before_validation</code> or <code>after_save</code> and once you add callbacks to the hooks, it is beyond your control when they are run. Whenever the model thinks it is <q>after save</q> time it will run all the attached callbacks for that hook, regardless of whether you want that or not.</p>\n\n<p>In Trailblazer, this changes substantially.</p>\n\n<p>We completely skip defining life-cycle events. If you need to run callbacks before or after a certain point you do this by explicitly triggering hooks or simple methods in your operation. For example, a <code>before_validation</code> hook literally happens <u>before</u> the validation.</p>\n\n\n;;;\n\n<p>Instead of the implicit callback invocation as found in ActiveRecord, in Trailblazer you instruct hooks to run their callbacks at your will. I call this <u>Imperative Callbacks</u> in Trailblazer.</p>\n\n<p>Twins help identifying and tracking events. The intermediate twin object graph collects low-level events like adding, deleting, destroying, creating and updating. Since twins are mostly trees of objects, you can run callbacks for a deeply nested structure without losing control of what to trigger when.</p>\n\n<p>We already learned how that could look like in the chapter at hand. Basically, we asked the twin for occurrences of a particular event like <u><q>item added to collection</q></u> and then ran the callback for all matching twins.</p>\n\n\n;;;\n\n<p>Explicitly invoking callbacks does not only remove magical surprising triggers from your code, they also make it more readable. Well, I am not saying the above code is particularly readable, but when looking at operational code you can instantly see which hooks and callbacks are involved.</p>\n\n<p>Speaking of readability, Trailblazer comes with a mechanism built-in to handle callback invocations. This abstracts dispatch to a very clear and concise declaration.</p>\n\n\n;;;\n\n<p>This is pretty straight-forward and I'm not sure if there even is need to explain since you already understand what this will do. Anyway, you paid for this book so let's go through it.</p>\n\n<p>Operations allow you to structure sets of callbacks into <u>groups</u>. The <code>callback</code> block opens a new <code>Disposable::Callback::Group</code> class for you and provides the DSL to configure the callbacks (line 2-9). Usually, an operation will only have one group, but later we will learn that you can have as many callback sets as you desire.</p>\n\n<p>Note that this has nothing to do with your contract, even though we're using the same API. In Trailblazer, we heavily rely on schemas and reuse API to define nested graphs.</p>\n\n<p>Before we walk step-by-step through the chain of events that happen here, let me show you how this callback group is invoked in your operation.</p>\n\n\n;;;\n\n<p>By calling <code>dispatch!</code> you instruct Trailblazer to run all callbacks from the default group (line 4). This means, the callbacks will be invoked at this very moment of the execution, right after saving the object graph. It is up to you where exactly you dispatch your callbacks. Also, keep in mind that you can exclude particular callbacks from the <code>dispatch!</code> call and maintain several different sets of callbacks. We'll speak about that later when we need it.</p>\n\n<p>Here's the callback group, again.</p>\n\n\n;;;\n\n<p>When calling <code>dispatch!</code> the following callbacks will be invoked. Note that order matters here.</p>\n\n<ol>\n<li>The callback mechanism will query the contract for items having been added to the <code>users</code> collection using the tracking logic we learned earlier. For each item the <code>notify_author!</code> method is called.</li>\n<li>Same happens again. This time, the <code>reset_authorship!</code> method gets invoked per added user.</li>\n<li>Since the top-level object, the <code>Thing</code> instance we just persisted, is considered <q>created</q>, the <code>expire_cache!</code> method is run after that.</li>\n</ol>\n\n\\n\n\n<p>Grouping callback logic makes it incredibly simple to structure complex post-processing code in operations.</p>\n\n<p>There is two ways of defining callbacks. You can either use <u>inline callbacks</u>, specify callbacks and methods in the operation class. Or, and that's my preferred way, maintain separate callback objects and their methods cleanly encapsulated in a different location.</p>\n\n<h3>Inline Callbacks</h3>\n\n<p>Using inline callbacks in an operation means you define the event callbacks in the operation class.</p>\n\n\n;;;\n\n<p>Inline callbacks require you to not only specify the callbacks in the class, but also the implementing method that represents the callback code.</p>\n\n<p>Have a look at our first callback.</p>\n\n\n;;;\n\n<p>As noted earlier, the <code>notify_author!</code> method here sits in the operation. It receives the nested form that matches the event <code>on_add</code> in the users collection (line 3). By using the twin API we discovered in the beginning of this chapter I check if the user was just created, and, if yes, dispatch further to an imaginary mailer (line 4). Note that I have access to both the nested form (or twin) that was added and the <code>Thing</code> instance that I can access via <code>Operation#model</code>.</p>\n\n<p>The options hash allows to inject arbitrary parameters into callback methods. We'll learn about that more in a minute, when discussing callback objects.</p>\n\n<p>The second callback <code>reset_authorship!</code> is almost as boring as the mailer one we just wrote.</p>\n\n\n;;;\n\n<p>This code is a bit awkward and probably a result of my lack of understanding for ActiveRecord. Since the nested user form is passed into the method, I access the actual <code>User</code> instance via <code>user.model</code> (line 2). I then find the particular authorship model that represents the binding between the user and the thing, and set this <code>confirmed</code> flag to zero (line 3).</p>\n\n<p>We also had third callback <code>expire_cache!</code> in the group. I left it there to point out the flexibility of callback groups, but please let me put you off until we discuss view caching in a minute.</p>\n\n<p>The <code>callback</code> group has made is really simple and intuitive to add post-processing logic to our operation. The familiar nesting DSL lets you add callbacks to nested members of the object graph, even to scalar properties, which I'm gonna demonstrate in a few pages.</p>\n\n<h3>Inheriting Groups</h3>\n\n<p>As you do remember, the <code>Update</code> operation inherits from the <code>Create</code> operation. This means it will also inherit the callback groups you defined. It is safe to inherit the <code>on_add</code> callbacks, as they will only get triggered when a user got added. This is the behavior we want in both create and update operations.</p>\n\n<p>In our update context, the <code>on_create</code> won't be run, though, as we don't create but update a <code>Thing</code> instance. This will result in the <code>expire_cache!</code> method never being called.</p>\n\n<p>Luckily, we can add and remove properties in subclassed callback groups, just as we do in contracts, twins, and representers.</p>\n\n\n;;;\n\n<p>The expiry method will now be called on updates, too, but only in <code>Update</code> context (line 3). However, we can simplify both operations by using the <code>on_change</code> event which handles create <u>and</u> update, Resulting in the <code>Update</code> operation not having to define its own group.</p>\n\n\n;;;\n\n<p>This will surely not work for every case. Groups allow you to fine-tune inherited definitions or to completely override them. We will come accross this several times in this book<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n<h3>Callback Object</h3>\n\n<p>While inline callbacks are a nice way to quickly define post-processing logic, they blow up the operation class pretty fast. Trailblazer also allows referencing external callback objects, so you can implement them in a separate class and file.</p>\n\n<p>Since this is my preferred approach, I introduce a new file <code>app/concepts/thing/callback.rb</code> with the following content.</p>\n\n\n;;;\n\n<p>As you can see, this is a completely isolated class with no inherited dependencies. I put the new class in the <code>Thing::Callback</code> namespace, similar to what we do with contract and representers soon (line 1). The callback object is derived from <code>Disposable::Callback::Group</code> (line 2). To define the event and handlers, I use the same API as we did in the inline callbacks earlier (line 3-8).</p>\n\n<p>What is different now is that the implementation of the methods do no longer have to sit in the operation, but in this very class (line 10-17).</p>\n\n<p>We have to change our implementation slightly, as this object doesn't have access to the operation and model directly. When using callback objects, Trailblazer will automatically pass in operation, params and contract into callback methods (line 14). I use keyword arguments to filter out the <code>:operation</code> parameter and grab the model via <code>operation.model</code> (line 15).</p>\n\n<p>To register the new object with an operation, we need to go back into <code>app/concepts/thing/operation.rb</code>.</p>\n\n\n;;;\n\n<p>Instead of defining the callbacks using a block, we simply pass the class name to <code>callback</code> (line 3). This will resolve to <code>Thing::Callback::Default</code> and reference the callback object we just implemented.</p>\n\n\\n\n\n<p>Before we move on, let's make sure real quick that we write a few tests for those callbacks. There's different ways to achieve this. In this section, I'm gonna speak about the quick way, only.</p>\n\n<p>Callback tests go into the operation test, too. in <code>test/concepts/thing/operation_test.rb</code>. While you can extract them to separate blocks I will include them into existing test cases. It's better to test <q>too much</q> in one case than to forget about things and not test them at all.</p>\n\n\n;;;\n\n<p>In the test case we coded a while ago, a valid operation is run that adds two users. The test already covers the authorship reset and makes sure both <code>confirmed</code> flags are zeroed (line 5). This is a functional test that really checks the effect on the application state and act as an example for good callback tests. With this case, the <code>:reset_authorship!</code> callback is covered.</p>\n\n<p>Since we're not finished with implementing our operation I added a basic test for the <code>:notify_author!</code> callback. The operation tracks each callback execution in the <code>invocations</code> field. By making sure the cryptical tracking object contains the right values, <code>:notify_author!</code> combined with <code>:on_add</code> and the two user twins we just added, we have written a quick and dirty test (line 7-8).</p>\n\n<p>We will soon come back to this test case and make it look and feel appropriate. This is really just to show you how you can assert callback invocations without actually testing the execution impact.</p>\n\n<p>In the next chapters I'm gonna make you write a few tests for the callbacks. We could test them manually, but callback behavior should always be assessed in combination with running the entire operation.</p>\n\n<p>Another question I often hear is <u><q>Shouldn't we be able to turn off callbacks in tests, to make them faster?</q></u>. The answer is: No. You will end up with a half-baked test environment that soon will diverge significantly from the real one.</p>\n\n<p>Most callbacks have side-effects, like setting flags (<code>mail_sent</code>) or running a small piece of logic somewhere that changes application state. Skipping callbacks in tests will create a fake world and things might pass even though they are broken in production - something I have seen in many Rails apps that insisted on a <q>fast</q> test suite by testing something that is never gonna happen that way.</p>\n\n<p>My personal preference is: Always run the complete operation, with all its callbacks. My test environment will be 100% identical to production and bugs are easier to spot.</p>\n\n<p>If you still think you have to turn callbacks off check out the docs to learn how to do that.</p>\n\n<hr>\n\n<p>So far, the <code>Thing::Create</code> operation consumes the incoming form, validates it and saves the new object graph to the database. Likewise, the <code>Update</code> handles the editing. After that is done, a number of callbacks are triggered. Let us now move to a topic that might seem completely unrelated to what we've done in this chapter. We will now learn about view caching and how we can use callbacks to expire caches.</p>\n\n\\n\n\n<p>Let's approach view caching step-wise. Before we implement the caching for the things grid, I want to introduce you to this technique by caching only the <code>show</code> state of the <code>Thing::Cell</code>. You remember, that's the cell that only renders one thing's name and creation date.</p>\n\n<p>Caching in cells exclusively works with what I call <u>state caching</u>. This means, you define on the class layer which state you want to cache. As most cells only have one public state, this will often result in a snippet similar to the following.</p>\n\n\n;;;\n\n<p>The first argument passed to <code>cache</code> is the state that needs caching (line 1). You could also provide instructions for computing a cache key here, and we'll do that in a minute, but allow me to discuss what's going to happen now<sup id=\"fnref3\"><a href=\"#fn3\" rel=\"footnote\">3</a></sup>.</p>\n\n<p>Suppose this cell gets rendered twice by invoking our old helper friend <code>concept(\"thing/cell\", thing).()</code>. This could happen in two different requests, or two subsequential calls in the same view. Here's what Cells will do.</p>\n\n<ol>\n<li>In the first cell invocation, the <code>show</code> state will be run as always. However, since Cells knows we enabled state caching for this state, the return value of <code>show</code> will be saved in the cache store. Usually, this is a HTML fragment rendered by your cell being pushed to the Rails cache layer.</li>\n<li>Next time the cell is rendered, it will look into that cache store if there's a cached version of the <code>show</code> state. And since we rendered the cell before, the cell will find a fragment in the cache store, and return the identical HTML fragment without actually running <code>show</code> again.</li>\n</ol>\n\n<p>While this will greatly speed up your cell rendering, you will lose all dynamics. Your cell state is cached forever since we do not provide a cache key. Regardless of the input to the cell, the cache result will always be identical.</p>\n\n<p>In order to maintain different cached versions, we need to provide a cache key. I call this <u>versioner</u> but that's just my lingo.</p>\n\n\\n\n\n<p>Cells comes with different options to compute cache keys. You could simply pass an expiry time to the cache store.</p>\n\n\n;;;\n\n<p>However, this will still mess up your view by providing one and the same fragment for possibly different inputs to the same cell. My favorite versioner style is passing a block.</p>\n\n\n;;;\n\n<p>Whatever you return from that block Rails will try to convert to a cache key. Arrays work well as they will be joined to one string by the underlying engine.</p>\n\n<p>The block is executed in cell instance context before the actual state is invoked. That's is why I can access <code>model</code> and use both the <code>id</code> and <code>updated_at</code> field to compute a unique cache key for this cell (line 2).</p>\n\n<p>Now, imagine this block being called whenever the cell is invoked from a view. It will always compute a different cache key for a different model that you pass into it. However, if you pass in the same model, the key will only differ when the model's <code>updated_at</code> field has changed in the meantime.</p>\n\n<p>For a better understanding, here's an example session.</p>\n\n\n;;;\n\n<p>The last line shows the cache key this cell will use to store the rendered view (line 4). It will render <code>show</code> and push the fragment to the cache store using the key it computed before running <code>show</code>.</p>\n\n<p>If you repeat this call, maybe in the next request, and the <code>thing</code> instance still has the same attributes, the cell will calculate the same cache key, find the existing fragment in the store, and return that instead of re-running <code>show</code>.</p>\n\n\\n\n\n<p>Now, assuming the thing got edited a while ago, maybe you changed the description, this will also change the <code>updated_at</code> attribute. When re-rendering the cell with the same thing this will result in a new cache key.</p>\n\n\n;;;\n\n<p>Even though the model is still the same, this is a completely different key, and this is desired! Since the thing got updated, you want the cache to expire and re-render, as crucial data like the name or the description might have changed. When invoking <code>show</code>, the cell won't find a fragment for the new key in the store, yet, and re-run the state.</p>\n\n<p>By cleverly picking a cache key algorithm, you save yourself from having to manually delete the old cache entry from the store. The cache store will automatically dispose of the old entry after detecting it hasn't been used for a certain while.</p>\n\n\\n<p>We're almost set to implement the compound grid caching now. Before we start working on cache key and expiry, here's another cool trick to debug your caching logic. Caching is a nebulous and fuzzy affair and it's always good to see what is going on behind the scenes.</p>\n\n<p>First of all, when working on caching I always turn on caching in <code>config/development.rb</code>.</p>\n\n\n;;;\n\n<p>Enabling this will activate caching logic in Cells, too. Under normal development conditions, caching is turned off and your versioners will never be run. It is a good idea to thorougly test cache logic before pushing it live.</p>\n\n<p>Cells comes with caching notifications that integrate with Rails notification mechanism. This has to be manually included into the cells you want to monitor.</p>\n\n\n;;;\n\n<p>By including the <code>Notifications</code> module cache reads and writes from the cell will be reported (line 2).</p>\n\n<p>As a third step, you need to subscribe to these specific notifications. In Gemgem, I added a new file <code>config/initializers/cells.rb</code> that includes the following subscription assignments.</p>\n\n\n;;;\n\n<p>From now on, whenever caching-related cells logic is run, you will see output similar to this snippet in your server log.</p>\n\n\n;;;\n\n<p>An extremely helpful tool to observe the caching logic. A cache write log is the opposite of a <u>cache hit</u> - it means the fragment with the mentioned cache key wasn't found<sup id=\"fnref4\"><a href=\"#fn4\">4</a></sup>.</p>\n\\n\n\n<p>We discussed how to cache single boxes of our thing grid on the home page, where every thing box keeps its own cache fragment. This is a valid option if Gemgem was a high-frequency page where hundreds of things get added every minute and the front page always has to be up-to-date.</p>\n\n<p>Gemgem is just starting to roll, though. To minimize rendering on the home page we should simply cache the entire grid and expire its cache whenever a new thing got added or an existing one was updated.</p>\n\n<p>The <code>Grid</code> cell has its own <code>show</code> state. Equipped with the right versioner, we will be able to cache the entire grid without having to implement caching for each box. This is turn means we can remove the <code>cache</code> declaration from <code>Thing::Cell</code> and instead define the cache on <code>Thing::Cell::Grid</code>.</p>\n\n\n;;;\n\n<p>This is an example of a cache versioner for the grid. Since the <code>show</code> method grabs all things to display by using <code>Thing.latest</code>, we could use the newest model's id as cache key (line 4). Our cached grid fragment would remain cached until we add a new <code>Thing</code>.</p>\n\n<p>A very simple solution, with one problem, whatsoever. The cache wouldn't expire when an older thing was updated as this won't change the latest thing's id.</p>\n\n\\n\n\n<p>When it comes to complex composed views and caching I often use a technique I named <u>CacheVersion</u>. I am pretty sure there's at least two dozens patterns from official geniuses out there with the same behavior but a cooler name, anyway, this pattern has saved millions of rendering cycles in our production apps.</p>\n\n<p>For example, I applied this to a comment forum where each comment is rendered from a cell, and the entire thread is embraced by a container cell, that can postload pages of comments when paginating.</p>\n\n<p>The concept of CacheVersion is - as always - extremely simple and I hope you will not be disappointed by such an obviously trivial solution: Use a persistent store to maintain a cache key and deliberately update that cache key when the application state changes.</p>\n\n<p>Applying CacheVersion combines the simplicity of cache keys with the reliability of expiry. What am I talking about? I have no idea, but let's walk through it and we both will understand.</p>\n\n\n;;;\n\n<p>The cell's versioner doesn't implement its own key but dispatches to a <code>CacheVersion</code> object. Note that I pass a token <code>\"thing/cell/grid\"</code> to that remote versioner. The token could be anything and will be the reference of that particular cache version (line 3). It is completely irrelevant what exactly this version represents, the important concept is that the cell knows the name. Basically, the cell asks <u><q>Hey, CacheVersion, what's the actual version of XYZ?</q></u>.</p>\n\n<p>Here is the table layout of <code>cache_versions</code>.</p>\n\n\n;;;\n\n<p>The CacheVersion implementation will then try to find the version of <u>XYZ</u> using a persistent store. I use ActiveRecord here, but this could be implemented using the much faster Redis store or anything you like. The class goes into <code>app/models/cache_version.rb</code>.</p>\n\n\n;;;\n\n<p>The <code>for</code> method will either find the version entry for <u>XYZ</u> or create and persist a new one (line 3). And now the trick: Our cell versioner returns this <code>CacheVersion</code> object to Rails' caching layer in order to compute a cache key.</p>\n\n<p>Rails will try to call <code>cache_key</code> on this object and succeed because we implemented that instance method (line 6-8). The method will return the <code>updated_at</code> string, a field automatically maintained by Rails. This field value is our cache key for the token <u>XYZ</u>.</p>\n\n<p>As long as this <code>updated_at</code> field doesn't change, the cache key for <u>XYZ</u> will always be identical resulting in our grid cell being cached.</p>\n\n<p>The <code>CacheVersion</code> class defines one more method to expire caches. Note that this is an instance method and in order to expire you need to hold the respective version object in your hands.</p>\n\n\n;;;\n\n<p>The <code>expire!</code> method allows you to change the cache key for <u>XYZ</u>. It will simply increment the <code>updated_at</code> field by one. The next time the versioner asks for the cache key it will be a different key and result in re-rendering of the grid.</p>\n\n<p>To wrap that up.</p>\n\n<ol>\n<li>The cell's versioner queries the <code>CacheVersion</code> class for <q>its</q> key. It has no knowledge other than <q>its</q> cache name.</li>\n<li>The <code>CacheVersion</code> finds or creates a key. The key is simply the <code>updated_at</code> field but could be anything. This key is persisted as a row in the <code>cache_versions</code> table.</li>\n<li>As long as the key wasn't changed, the cell will be cached.</li>\n<li>Expiring the cache key happens whenever the grid changes. So, expiry logic goes into operations.</li>\n</ol>\n\n<h3>Expiry in Operations</h3>\n\n<p>The thing grid only needs to be updated when a new thing got added and takes the first place in the grid. And, don't you forget about that, when a thing was updated. The changes made have to be reflected in the grid<sup id=\"fnref5\"><a href=\"#fn5\" rel=\"footnote\">5</a></sup>.</p>\n\n<p>Both creating and updating things only works via operations, so the <code>Thing::Create</code> and <code>Thing::Update</code> classes are where we trigger cache expiry.</p>\n\n<p>You remember that we already had a callback in place in the <code>Create</code> operation, right?</p>\n\n\n;;;\n\n<p>We now need to add the expire callback to the <code>Default</code> group in <code>app/concepts/thing/callback.rb</code>.</p>\n\n\n;;;\n\n<p>Both the registration and implementation are pushed into the group (line 3-7).</p>\n\n<p>The callback method <code>expire_cache!</code> grabs the <code>EventVersion</code> instance representing the grid state and calls the aforementioned <code>expire!</code> method, which will increment the cache key (line 5-7). As a consequence, the next time this cache key is retrieved from the cell, it won't find a cache entry and re-render the grid.</p>\n\n<h3>Discussion</h3>\n\n<p>A few things I have to criticize about this approach.</p>\n\n<p>First, didn't we say logic shouldn't be in models? Why am I putting expiry and caching logic into the <code>CacheVersion</code> class? This is surely breaking Trailblazer's idea of logic-less models. At a later point, we will move it to an operation, so we can trigger expires from the console, too.</p>\n\n<p>Does the operation really need to know about view details? Why does the <code>expire_cache!</code> method pass the cell's view token to CacheVersion? That is tightly coupling business and view. The answer: It's a quick and easy way to achieve what we need now. When caching gets more complex, the operation could dispatch to a cache expire class that knows what actions affects which cached parts of the app.</p>\n\n<p>Nevertheless, I have used this technique successfully in many applications. The point of <code>CacheVersion</code> is to minimize persistence access in order to compute a cache key. Instead of trying to generate an MD5 hash from all <code>Thing</code> instances visible in the grid, as it is often done, we only need exactly one database lookup to find, or compute, the cache key.</p>\n\n\\n\n\n<p>The application now properly notifies authors, sets up the desired environment when adding and updating things, and expires caches. To close this chapter I'd love to add a file upload. We could allow users to upload an image for things to make the things pages a bit more colorful.</p>\n\n<p>As a first step, we should add a file upload field to the thing form in <code>app/views/things/new.html.haml</code>.</p>\n\n\n;;;\n\n<p>The form object property I call <code>file</code>, and I need to provide the type to SimpleForm as the type of this virtual field can't be inferred (line 3).</p>\n\n<p>Of course, we need to add the <code>file</code> property to the form now.</p>\n\n\n;;;\n\n<p>This property needs to be virtual as the underlying model <code>Thing</code> doesn't have such a field (line 4). We will need a little bit of more code to make this work. However, when submitting the form with a selected file to upload, the form's <code>file</code> property will now contain the uploaded file.</p>\n\n\n;;;\n\n<p>Nothing else happens so far. The form won't try to set <code>file</code> on the model as the property is declared virtual. The form simply keeps a reference to the uploaded file object, nothing more.</p>\n\n\\n\n\n<p>I want to store the original and a thumbnailed version of the image. In order to process the upload we need a file uploading gem. In Gemgem, I use <a href=\"https://github.com/apotonick/paperdragon\">Paperdragon</a>, but this works fine with CarrierWave, too.</p>\n\n<p>I chose Paperdragon because it has absolutely no coupling to ActiveRecord. The entire processing is in your hands. While this is a tiny little bit more verbose, you fully control when image processing, S3 syncs, and so on happen.</p>\n\n<p>We could use Paperdragon's manual API to process and store the images, or the <code>Model</code> module which gives us a fuzzy API to upload and render images.</p>\n\n<p>I will go the explicit way, use the <code>Model::Writer</code> feature in our contract which introduces one new method to process a file.</p>\n\n\n;;;\n\n<p>After including that model, I instruct Paperdragon to provide me a single method <code>image!</code> for the processor instance. This happens by calling <code>processable_writer :image</code> (line 6).<sup id=\"fnref6\"><a href=\"#fn6\" rel=\"footnote\">6</a></sup></p>\n\n<p>The only requirement Paperdragon has to the class it is operating on is a writeable field named <code>image_meta_data</code>. After processing the different versions and storing the images, Paperdragon will push locations of images, file names, etc. to that field. As this field needs to get persisted, I added a same-named TEXT column to <code>things</code>.</p>\n\n\n;;;\n\n<p>This field will contain a serialized Ruby hash, so I instruct Rails to automatically handle the serialization and deserialization on the database level by using <code>serialize</code> (line 2).</p>\n\n<h3>Image Processing</h3>\n\n<p>After the infrastructure has been set up, let's implement the processing. In the first version, I will simply call the upload code directly in the operation's <code>process</code> method without using a callback.</p>\n\n\n;;;\n\n<p>The <code>upload_image!</code> method in the operation uses Paperdragon's API to create and store the two versions of the uploaded file.</p>\n\n\n;;;\n\n<p>Calling the <code>image!</code> method that Paperdragon provides on the contract and passing the actual file into it will instantiate a Paperdragon processor and allow operations on the file (line 2). Note that it's your job to provide the file object, Paperdragon has no idea that the processor in <code>image!</code> and the <code>file</code> field from the form are related.</p>\n\n<p>In the block, I use Paperdragon's API and instruct it to store an unprocessed version of the file and store it as the <code>:original</code> (line 3). The <code>:thumb</code> version I crop and resize to 120x120 pixel (line 4). Paperdragon uses the Dragonfly gem under the hood and supports all modifications, conversions, etc. Dragonfly allows.</p>\n\n<p>After that block is run and the images are processed, Paperdragon will store them in the configured location<sup id=\"fnref7\"><a href=\"#fn7\" rel=\"footnote\">7</a></sup>. It will also create a meta data hash with file names and push that to the contract. Paperdragon does this by simply calling <code>contract.image_meta_data= {..}</code> after the block.</p>\n\n<p>If you're curious, you can have a look at this meta data yourself.</p>\n\n\n;;;\n\n<p>So far, the image got uploaded, processed, stored and the meta data got written to the contract's <code>image_meta_data</code> field. How is that persisted?</p>\n\n<p>We already learned that the form twin will push all defined properties to the underlying model when we call <code>sync</code>. The <code>image_meta_data</code> field is a property, and therefore will be written to the model just like any other field on the form.</p>\n\n\\n\n\n<p>Two security holes need fixing before moving on. Firstly, the uploaded file can be just anything. I install the excellent <a href=\"https://github.com/musaffa/file_validators\">file_validators gem</a> in order to get generic file validations into my form. A huge benefit of this gem is that is doesn't have any code relating to ActiveRecord, which would make our form break.</p>\n\n\n;;;\n\n<p>The new <code>:file_size</code> and <code>:file_content_type</code> option for <code>validates</code> help us excluding unwanted formats and files too big (line 3-4). We will write tests for that shortly.</p>\n\n<p>Another problem is that <code>image_meta_data</code> is writeable in the form. This means someone could inject this field into the <code>params</code> and thus write arbitrary content into our thing's <code>image_meta_data</code> attribute. This is not a problem when we do upload a file: the field gets overridden in Paperdragon, anyway. However, this will allow script kiddies to change that field when we do not upload but simply update a field of the form.</p>\n\n<p>We can't set it <code>writeable: false</code>, though. This would result in this field not being synced to the model when we <code>save</code>. The property should only be write-protected when deserializing the incoming params hash and populating the form.</p>\n\n\n;;;\n\n<p>This can be achieved by using the <code>:deserializer</code> option. I won't go into detail here, but basically this option is only applied to the deserializer. Setting properties to <code>writeable: false</code> here won't write the incoming value to the form in <code>validate</code>.</p>\n\n<h3>Uploading: An Overview</h3>\n\n<p>You might be irritated about this because back in the days, with Paperclip, everything worked out of the box without having to do anything manually. Also, back in the days, when things went wrong or you wanted to change a particular processing step, you found yourself standing in front of a black box that magically hooks into arbitrary life-cycle events of your model.</p>\n\n<p>It is incredibly hard to control uploads with Paperclip. In another project, we had to fine-tune processing and storing in S3, we needed control over the creation and pushing of every file version. This eventually resulted in Paperdragon, which uploads thousands of images a day in a photo community now.</p>\n\n<p>Paperdragon in combination with Reform and Trailblazer's operation makes it really explicit what is going on when, and allows you to change flows accordingly. It makes it quite easy to add debugging or strategical <code>pry</code>s in your code to find out more. Here's a quick wrap up of the process.</p>\n\n<ol>\n<li>You submit a form with an image file.</li>\n<li>After <code>Form#validate</code>, the <code>file</code> property will now point to this file object.</li>\n<li>When validations are run, file-specific checks are run against the <code>file</code> property. No processing or storing has happened, yet.</li>\n<li>In the operation that called <code>validate</code>, Paperdragon is invoked via the <code>image!(file)</code> accessor of the form and allows us to process and store different versions of the images. This is not just a nice DSL but really executes the commands in real-time, providing us an interface to the image operations.</li>\n<li>With completion of the processing and storing, a meta data hash is compiled and pushed onto the form's <code>image_meta_data</code> field.</li>\n<li>Finally, when the form gets <code>save</code>d the <code>image_meta_data</code> field is written to the model that now persists where the images can be found in the file system.</li>\n</ol>\n\n<p>Again, the model isn't touched until we <code>save</code> the form.</p>\n\n\\n\n\n<p>When clicking through the thing forms, you will soon notice that there's an exception raised when you did not add a file to upload. This is because we always run the upload logic in <code>process</code> without checking whether there's a file present or not.</p>\n\n<p>I won't bother you with different ways to solve this. Of course you could check whether the params hash contains a file object, as I've seen it a lot in Rails hacks, but we can simply use a twin feature we learned earlier.</p>\n\n\n;;;\n\n<p>To avoid running the upload logic without an actual file to process, I use the <code>changed?</code> method of the form twin (line 3). This will run <code>upload_image!</code> only when <q>something</q> has been assigned via <code>file=</code> on the form, which is exactly what happens in <code>validate</code> but only when a file is submitted.</p>\n\n<p>Another option is to introduce a second callback group. Trailblazer allows you to have as many groups as you need. Here's how we could restructure the callback code in <code>app/concepts/thing/callback.rb</code>.</p>\n\n\n;;;\n\n<p>We now have two callback groups <code>Default</code> and <code>BeforeSave</code> (line 2).  I use the <code>on_change</code> event and limit it to <code>file</code> using the <code>:property</code> option (line 3). Yes, you can apply events to single properties, too. As always in callback groups, the <code>upload_image!</code> method resides in this class, too (line 5).</p>\n\n<p>To trigger that new callback, it needs to get registered in the operation.</p>\n\n\n;;;\n\n<p>I alias the group to <code>:before_save</code> to indicate where it's called. We could also name it <code>:upload</code>, but we will reuse this group for more than file works in the next chapter.</p>\n\n<p>The way I dispatch the two groups is conceptually identical to before and after save hooks.</p>\n\n\n;;;\n\n<p>Calling the new <code>:before_save</code> group happens where we originally had the manual invocation of <code>upload_image!</code> before saving the form. As you can see, <code>dispatch!</code> also accepts a group name to run an arbitrary callback group (line 3).</p>\n\n<p>Personally, I love separate callback groups even when they contain one single event, only. Quickly you develop your style of groups you have in every operation. What I appreciate here is the freedom to choose how many groups you need and where to trigger them.</p>\n\n\\n<p>After all this uploading work, we deserve to see a visual result. Luckily, rendering uploaded images is a walk in the park with Paperdragon. I will add a new cell named <code>Thing::Cell::Decorator</code> that will keep several public decoration methods. This is a practice I often use when I need a generic decorator cell for a concept.</p>\n\n\n;;;\n\n<p>This time, I include the <code>Paperdragon::Model::Reader</code> module that will give me a plain reader. I have to configure the reader's name via <code>processable_reader :image</code> (line 3). That reader from Paperdragon will call <code>image_meta_data</code>, so I have to provide that field, too.</p>\n\n<p>Again, <code>image_meta_data</code> is the only requirement Paperdragon has to the using class. Therefore, I need to delegate this method to the model using <code>property</code> (line 4).</p>\n\n<p>The <code>thumb</code> method is an object-oriented version of what we used to call <u>helper</u>.</p>\n\n<p>The <code>exists?</code> method allows to check if there really is an image uploaded, and by using the <code>[:thumb]</code> reader, we get the attachment object for the thumb version (line 7).</p>\n\n<p>Not too much happens here in the background. Paperdragon will open the <code>image_meta_data</code> hash of the model, grab the <code>:thumb</code> image path and return it. And voilà - here comes a beautiful, cropped, resized and slightly sharpened version of whatever photo you uploaded.</p>\n\n<p>In <code>app/views/things/show.html.haml</code> we can now render the thumb of the uploaded file by using our decorator cell.</p>\n\n\n;;;\n\n<p>Note how I call the state explicitly here. <code>cell.(:thumb)</code> will invoke the <code>thumb</code> method and return the image tag. Nicely encapsulated, the user doesn't need to know any details about Paperdragon details.</p>\n\n<p>Have another look at the rendered image in your browser, and enjoy the beauty for another blink of an eye. Then, it's testing time!</p>\n\\n\n\n<p>Luckily, we're using a well-tested gem for the processing and save testing the implications coming with it. What we need to make sure is that an upload actually works with a valid file. An upload test is just another operation test and goes into <code>test/concepts/thing/operation_test.rb</code>.</p>\n\n\n;;;\n\n<p>The test file is literally a <code>File</code> instance that I open from my fixtures (line 3). I pass that file object into the operation. This is the analogue to what happens in a real form submission with a file upload. Rails will provide a <code>File</code> instance in <code>params</code>.</p>\n\n<p>The <code>Create</code> operation will handle all the internals and all I need to do is check the end result by making sure the image version was really processed and stored. I do this by using Paperdragon's <code>Attachment</code> class, pass in the <code>image_meta_data</code> and let it check for its existence (line 5).</p>\n\n<p>We will soon learn how to replace this slightly clumsy test with a view model invocation.</p>\n\n<p>The opposite test case is event simpler.</p>\n\n\n;;;\n\n<p>Here, I pass a PDF file into the operation with the evil, terrifying name <code>\"hack.pdf\"</code> (line 2-3). Validation result should be wrong and the error message generated by file_validations should be present (line 5-6).</p>\n\n<h3>Decorator Test</h3>\n\n<p>It is also a good idea to test the decorator cell we wrote. This test goes into <code>test/concepts/thing/cell_test.rb</code> and is as simple as it could be.</p>\n\n\n;;;\n\n<p>More and more it becomes obvious that replacing factories with operations is the way to a clean, realistic test application state. The <code>Create</code> call with a valid file is how I set up the test thing (line 3-4). Note that you're free to extract this kind of code into factories. As long as they internally use operations this works just fine.</p>\n\n<p>As a last step I invoke the <code>thumb</code> method on the cell and test if the returned <code>img</code> tag is what I expect it to be (line 6). An interesting point here is that I did not use the call style, but call the method directly. This is a trick to avoid the content being wrapped in a Capybara string and allows me to test for equality here.</p>\n\n<p>While this is totally fine in tests, in real views this will also bypass caching, so please call methods via <code>call</code> in rendering environments.</p>\n\n<p>I'll spare you the details of the second, negative test which makes sure no image tag is rendered when there's no uploaded file.</p>\n\n\\n\n\n<p>Callbacks as found in Trailblazer are different to what we've learned in Rails. Callback groups might seem a bit more verbose when you start using them but soon it becomes visible how that little bit of extra code makes them so much cleaner, predictable and also reusable.</p>\n\n<p>Instead of hooking them directly into the persistence layer, callbacks are separate classes that operate on the twin API to find out when they apply.</p>\n\n<p>Even though we define and talk about events, please don't confuse Trailblazer's callback system with a full-blown event dispatcher that magically triggers callbacks in real-time. Imperative callbacks are passive, you say when you need them to be run.</p>\n\n<p>Also, callback groups are just a simple abstraction. Further dispatching has to happen in a different layer. For example, I would never implement a complex notification system with dependencies, pushing, etc. directly in callbacks. The operation will identify events, pick that up in a callback and can then delegate that to a notifications class.</p>\n\n<p>For now, let's go and discover the crazy world of authentication!</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>The <code>persisted?</code> method is a concept found in every standard ORM. This allows using the <code>Persisted</code> module in any environment, without being limiting to ActiveRecord. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>If you're curious now, learn more from the <a href=\"http://trailblazerb.org/gems/operation/callback.html\">API docs</a>. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn3\">\n<p>You might be wondering why caching happens in the class and not in the view, as Rails does it. Fragment caching is <a href=\"http://nicksda.apotomo.de/2011/02/rails-misapprehensions-caching-views-is-not-the-views-job/\">not implemented in Cells per design</a> - Cells enforces an object-oriented design rather than cluttering your views with caching blocks. <a href=\"#fnref3\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn4\">\n<p>By the way, the Cells caching notifications are a result of community effort and came from a <a href=\"https://github.com/apotonick/cells/issues/64\">pull request</a>. I didn't even know that notifications existed back then and now I'm glad someone else solved this for me in Cells. <a href=\"#fnref4\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn5\">\n<p>For completeness, I have to mention that I modified <code>Thing::Cell</code> slightly: I added the <code>description</code> property to the view. When a user edits a thing and changes the description this requires the grid to update. Both <a href=\"https://github.com/apotonick/gemgem-trbrb/blob/chapter-8/app/concepts/thing/views/show.haml\">implementation</a> and <a href=\"https://github.com/apotonick/gemgem-trbrb/blob/chapter-8/test/concepts/thing/cell_test.rb\">tests</a> can be found in the Gemgem repository. <a href=\"#fnref5\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn6\">\n<p>Including the <code>Writer</code> into the contract might feel messy. You can use a separate uploader object for the actual processing. The minimal code change <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-08-separate-uploader\">is here</a>. <a href=\"#fnref6\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn7\">\n<p>You need to configure where Paperdragon should store files. This happens in a separate initializer <a href=\"https://github.com/apotonick/gemgem-trbrb/blob/chapter-8/config/initializers/dragonfly.rb\">dragonfly.rb</a>. <a href=\"#fnref7\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>We have grown up and it is time to establish some policies and rules in Gemgem. The next two chapters will talk about authentication and authorization, topics relevant for every web application.</p>\n\n<p>Users should be able to sign in and out, register themselves for Gemgem and have a different experience when signed in. Also, implicitly created users, for instance when commenting, should be able confirm their account in a separate workflow.</p>\n\n<p>The branch for this chapter can be found <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-09\">in the repository</a>.</p>\n\n\\n\n\n<p>So far, when adding comments on the thing page it is a requirement to add the user's email. After submission, besides creating a new comment row, this will also build a brand-new user object, regardless of whether or not the email belongs to an exisiting user of Gemgem.</p>\n\n<p>The first step for a coherent user integrity is to create new users only when the comment author's email is unknown. If that's not the case, the existing user should be associated with the new comment. Of course, we need to find this existing user.</p>\n\n<p>In order to do so, we need to replace the comment's <code>Create#setup_model!</code> method, where we statically added the <code>User</code> instance to a comment. We substitute it with a combination of a prepopulator and a populator.</p>\n\n\n;;;\n\n<p>The <code>:prepopulator</code> makes sure that, once we call <code>prepopulate!</code>, the comment form will always contain a nested <code>User</code> instance (line 4). When processing the submitted form in <code>validate</code>, the <code>:populator</code> option allows us to hook in our own code to populate the form. Instead of a lambda, I define an instance method <code>:populate_user!</code> to be invoked for that (line 5).</p>\n\n<p>As discussed in earlier chapters, the <code>:populator</code> option works similar to <code>:populate_if_empty</code> but is invoked at a lower level. Also, <code>:populator</code> is invoked in <code>validate</code>, whereas prepopulation gets triggered via <code>prepopulate!</code></p>\n\n<p>In a populator, you have to do everything by hand. It is always called, and you need to manually assign values to the form. This is a different to what we've learned with <code>:populate_if_empty</code>, which only gets invoked when the corresponding nested form is not found, and automatically assigns the result to the object graph.</p>\n\n<p>In the <code>:populator</code> I try to find a <code>User</code> by the email that was submitted. Note that <code>fragment</code> represents the nested hash of the form. If the <code>find_by</code> is unsuccessful, I instantiate a new user. The instance must then be assigned via the respective setter, otherwise it will be lost and the nested user form will be empty (line 10).</p>\n\n<p>In an instant, a test for this goes to <code>test/concepts/comment/operation_test.rb</code>. Otherwise, we're gonna forget we added this feature, bugs start coming, and the world is gonna explode. Or, at least, it stalls.</p>\n\n\n;;;\n\n<p>An extremely simple test. I create two comments subsequentially with the same params (line 2-8). By asserting that the first and second operations' user model have the same ID I can make sure there was no additional user created in the second call (line 10).</p>\n\n<h3>Sleeping Users</h3>\n\n<p>Gemgem allows to create and update things and authors thereof. Authors, or users, won't be created twice. Once they exist in the database, the existing user will be associated to a thing if emails match.</p>\n\n<p>A few checks are run to make sure users can only have a maximum of five unconfirmed authorships, and so on.</p>\n\n<p>When commenting, the specified user will be created or an existing one found and associated analogue to how we did it with things authors. We won't have any duplicates of users in the database.</p>\n\n<p>Whenever a user gets created <q>on-the-fly</q>, either when adding things or comments, the user will get notified to join us. Instead of calling this <q>unconfirmed</q> I named it <u><q>sleeping user</q></u>: An implicitly created user that exists in the system, has a thing or a comment associated to it, but whose account is not confirmed, yet.</p>\n\n<p>I played with many names, <q>unconfirmed</q>, <q>needs password</q>, <q>deactivated</q>, just to name a few. <q>Sleeping user</q>, I have no idea why, makes me think of the correct state of affairs.</p>\n\n<p>Instead of letting sleeping users confirm their account to become full-blown <u>Gemgemonites</u> I decided to walk you through the manual sign up process, first. The manual sign up allows users to explicitly register for Gemgem and then start playing with it.</p>\n\n<p>We will explore the sign up screen and its validations, creating a user and signing in.</p>\n\n\\n\n\n<p>For the entire authentication system we refrain from using Devise. In chapter 2 I already discussed what makes me refuse this gem: It is lacking a clean object design and levarages global Rails concepts like callbacks, filters, and monkey-patching, techniques that are not appreciated in Trailblazer.</p>\n\n<p>An alternative to Devise is <a href=\"https://github.com/apotonick/tyrant\">Tyrant</a>. This gem is an extraction from Gemgem and its foundation was laid when writing this book.</p>\n\n<p>Tyrant comes with all common authentication features like sign in, sign up, password change, brute-force protection, and more. It does provide its functions as Trailblazer operations, its public API is exposed with twins, and views are implemented using Cells.</p>\n\n<p>Validations, post-processing logic and internal behavior can be customized by using Trailblazer's polymorphism. In other words, you override operations, contracts and methods with plain Ruby instead of having to hack its source code.</p>\n\n<p>Tyrant has zero coupling to Rails and can be used in any Ruby environment. Despite a high degree of encapsulation, it doesn't feel clumsy and fits smoothly into Rails applications.</p>\n\n<p>To make you better understand how Tyrant works, we're going to implement two functions ourselves, and then I show you how this is done with Tyrant.</p>\n\n\\n\n\n<p>Let's discuss the sign up form and the processing first.</p>\n\n<p>In Gemgem, all functions related to authentication will be invoked from the same controller <code>SessionsController</code>. In this controller, expressive actions will delegate to Tyrant operations. I gave up trying to fumble the different authentication functions into a <q>RESTful</q> style as I will discuss in a second.</p>\n\n<p>As a first step, users will usually want to browse to a URL to hit the sign up form. I added a few manual routes to <code>config/routes.rb</code>.</p>\n\n\n;;;\n\n<p>As you can see, I only use POST and GET routes where the names speak for themselves.</p>\n\n<h3>Breaking <q>RESTfulness</q>, part II</h3>\n\n<p>Again, I'm breaking Rails' <q>RESTfulness</q> and again I feel good about this. A controller action with the same named view <code>sign_up_form</code> is simply more intuitive than <code>create</code>. Likewise, a GET that can be sent from an HTML link to <code>sign_out</code> instead of a DELETE request to <code>destroy</code> makes more sense.</p>\n\n<p>To the same effect, when adding more steps like <q>change password</q> or <q>activate accout</q>, I am struggling to map those functions and workflows to resources with CRUD operations.</p>\n\n<p>Authentication is a UI-specific workflow and has barely any overlapping with REST concepts. The opposite is the case: The central notion of our authentication is manifested in a cookie, an asset that has no place in the REST world at all.</p>\n\n<p>Therefore, I create manual routes that are a tiny bit more explicit, I restrict myself to GET and POST requests and I actually understand what I do.</p>\n\n<h3>SignUp Operation</h3>\n\n<p>The sign up process will start with a form to enter your credentials. You've seen that kind of screen before. You enter your email, enter your desired password twice in two fields, click submit, and you're in.</p>\n\n<p>That is, given you entered the password identically in both fields.</p>\n\n<p>Here's the initial part of our first authentication operation. I put all operations related to this into <code>concepts/session/operation.rb</code>. Trailblazer will load this file automatically without trying to find and preload a corresponding model class.</p>\n\n<p>This operation will represent the signup form, and the processing thereof.</p>\n\n\n;;;\n\n<p>This is a plain operation in good ol' Trailblazer style.</p>\n\n<p>I include <code>Model</code> to let the operation create a <code>User</code> instance for <code>process</code> so we don't have to do that. Also, by specifying the model it will automatically work with <code>simple_form</code> as the operation and the form object now know their <q>model name</q> (line 2-3).</p>\n\n<p>After specifying the <code>email</code> property, I declare both <code>password</code> and <code>confirm_password</code> as virtual (line 7-8). These fields don't exist on the <code>User</code> instance the form wraps and we only need them during the operation run. This is exactly what the <code>:virtual</code> option was made for.</p>\n\n<p>All three fields can't be blank in the form submission, which is asserted with the <code>presence</code> validation (line 10).</p>\n\n<p>The special <code>password_ok?</code> validation will compare password and the confirmed password. They need to be identical, but you already got that.</p>\n\n\n;;;\n\n<p>Whenever the <code>SignUp</code> operation is run, the <code>password_ok?</code> will be run, too, regardless of whether or not earlier validations have failed. This is why I first check that email and password were actually submitted (line 4).</p>\n\n<p>If the two submitted passwords are not identical, a message gets added to <code>errors</code>, marking the validation as invalid (line 5-6).</p>\n\n<h3>Creating a new User</h3>\n\n<p>After the validations have been sorted, I move on to processing. This means, in case of a successful form submission with valid input, we need to create a new user and assign the password to it, so they can login the next time.</p>\n\n<p>In Gemgem, I decided to not use the confirmation workflow popular in many websites, where, after sign up, you need to click a confirmation link, first. This is handled by Tyrant and easy to integrate in your application, should you want that.</p>\n\n<p>Gemgem lets you signup immediately. In trade, several new steps are to be implemented, for example, sleeping users need to be able to activate their account. I do all this non-conform behavior to show you how to customize Tyrant.</p>\n\n\n;;;\n\n<p>The first part is the familiar invocation of the form validation. Note that the operation expects input under the <code>:user</code> key (line 4). In case of a successful valiation, a mysterious method <code>create!</code> is called (line 5).</p>\n\n<p>Where I could have used a callback, I decided a method before saving the contract will do.</p>\n\n<p>The <code>create!</code> method uses a part of Tyrant's public API to accomplish its job of creating a user with a password. This public API is available via the <code>Tyrant::Authenticatable</code> twin. When instantiated, this class requires a user model, that's why I pass in <code>contract.model</code> (line 11).</p>\n\n<p>Invoking <code>digest!</code> and passing in the submitted password will use the bcrypt algorithm to generate a password digest. This cryptic string is kept in the twin, nothing happens to the user instance, yet (line 12). I will discuss the internals of <code>Authenticatable</code> in a minute.</p>\n\n<p>When calling <code>confirmed!</code> on that twin, all that happens is the twin will mark itself as confirmed - what a surprising thing, given the name of the method. That basically involves storing the confirmation date internally. Again, nothing happens to the user (line 13).</p>\n\n<p>Only when calling <code>sync</code> on the <code>Authenticatable</code> twin, its internal state is written to the <code>User</code> instance. This will assign a hash containing all information necessary to the <code>User</code>'s <code>auth_meta_data</code> field, which is the only requirement Tyrant has to your user model.</p>\n\n<p>To persist this state change and write the <code>auth_meta_data</code> hash to its field in the database, I call the contract's <code>save</code> (line 6). This will first sync the <code>email</code> field from the contract to the user instance since it is the only non-virtual property. It then calls <code>save</code> on the <code>User</code> instance which will persist the new email and the authentication data to a new row in the database.</p>\n\n<p>This won't work, though, without defining <code>auth_meta_data</code> on the <code>User</code> class.</p>\n\n<p>I created a migration to add this field.</p>\n\n\n;;;\n\n<p>This will add <code>auth_meta_data</code> to the <code>users</code> table and allow arbitrary text in it (line 3).</p>\n\n<p>Since we will store a serialized hash in it, this needs to configured on the model.</p>\n\n\n;;;\n\n<p>We already encountered the <code>serialize</code> class method in the last chapter. By declaring the <code>auth_meta_data</code> serializable, Rails will automatically render it to a JSON hash for persistence and parse it back to a hash when querying it. This works identical to the <code>image_meta_data</code> field used by Paperdragon.</p>\n\n<h3>Summary SignUp</h3>\n\n<p>To understand the overall control flow in <code>SignUp</code>, have a look at the diagram.</p>\n\n\n;;;\n\n<p>The operation and its form are responsible for creating the user object and validating the email (1).</p>\n\n<p>Tyrant's <code>Authenticatable</code> twin is then called in the operation and computes the <code>auth_meta_data</code> field. The hash is written back to the model when the twin <code>sync</code>s (2).</p>\n\n<p>Once the model is ready to be persisted, the operation takes back control and calls <code>save</code> on the user (4). Implicitly, the email field from the contract gets written to the user before it is persisted (3).</p>\n\n<p>You might still be struggling to understand what exactly is the <code>auth_meta_data</code> field about. Why not have a look at the <code>Authenticatable</code> twin that comes with Tryrant?</p>\n\n\\n\n\n<p>How does the twin generate and store the password for the user, and how does all the data get back to the database and associated to the user?</p>\n\n<p>It's <code>Authenticatable</code>'s job to expose a small API of methods related to authentication. While this could have also been done with a set of operations, this all comes in one object. I use twins a lot with small groups of business logic - this is way easier to use than invoking clumsy operations for every step.</p>\n\n<p>Here's, again, how the <code>Authenticatable</code> twin gets instantiated.</p>\n\n\n;;;\n\n<p>The <code>Authenticatable</code> twin wraps, or decorates, a <code>User</code> instance. This actually is more than just a decorator, as the twin also writes to the decorated object. We will see that in a minute.</p>\n\n<p>Here's an excerpt from the <code>Authenticatable</code> class and its schema definition.</p>\n\n\n;;;\n\n<p>As you can see, this is simply a subclass of <code>Twin</code>. It defines one property <code>:auth_meta_data</code> on the top level (line 2). This property is the only interface to the <code>User</code> model, <code>User#auth_meta_data</code> and <code>User#auth_meta_data=</code> have to be defined on the model.</p>\n\n<p>In the nested twin, the <code>Struct</code> feature gets included making <code>auth_meta_data</code> a hash field (line 3). A handful of properties then let you divine what this all might be about (line 4-7).</p>\n\n<h3>Hash Fields</h3>\n\n<p>To understand <code>Struct</code> twins, or hash fields, we have to understand what happens when initializing the twin.</p>\n\n<ol>\n<li><p>The <code>Authenticatable</code> twin will ask the decorated user instance for its <code>auth_meta_data</code> field. On the <code>User</code> model, this is a <code>serialize</code> field. Consequentially, when the twin invokes <code>user.auth_meta_data</code> this will return a hash, for instance <code>{password_digest: \"abc\"}</code>.</p></li>\n<li><p>As we include <code>Struct</code> the twin knows this is going to be a hash, and it converts it into a decent nested twin object. This allows you to read the nested values via reader methods:</p></li>\n</ol>\n\n\n\n\n;;;\n\n<ol>\n<li>Vice-versa, we can also write to all the defined properties using setter methods instead of clumsy hash fumbling.</li>\n</ol>\n\n\n\n\n;;;\n\n<p>This won't write to the model, yet.</p>\n\n<ol>\n<li>After working on the twin via its object-oriented API, we can write changes back to the model.</li>\n</ol>\n\n\n\n\n;;;\n\n<p><code>Authenticatable</code> will compile <code>auth_meta_data</code> back to a hash and push it to the model by invoking the setter, as illustrated in the above snippet.</p>\n\n<p>The twin provides a convenient API to the hash field and delays writing until you say so. By using a <code>Struct</code> twin I can be sure that there will only be one model write operation, once I call <code>sync</code>.</p>\n\n<h3>Authentication Logic on Twin</h3>\n\n<p>Besides abstracting the persistence layer, the twin is an OOP asset that allows to add behavior. In Tyrant, <code>Authenticatable</code> exposes a minimal API for handling authentication maintenance with a persisted object. Let's recall the <code>SignUp</code> operation's <code>create!</code> method once more.</p>\n\n\n;;;\n\n<p>You have an idea now what is actually happening here. For completeness, I want to run through the implementation of the methods used in this example.</p>\n\n\n;;;\n\n<p>The <code>digest!</code> method is the first method dispatched in <code>SignUp</code>. It digests the incoming form password using the bcrypt library and assigns it to a virtual field <code>password_digest</code> on the hash field.</p>\n\n<p>Analogously, the <code>confirmed!</code> method doesn't do anything big, either.</p>\n\n\n;;;\n\n<p>When invoking the <code>confirmed!</code> method in the <code>SignUp</code> operation, the twin will reset the <code>confirmation_token</code> field and mark it as confirmed by setting a <code>confirmed_at</code> timestamp (line 4-5).</p>\n\n<p>The last step in <code>SignUp</code> is calling the <code>sync</code> method on the twin.</p>\n\n\n;;;\n\n<p>The <code>Authenticatable</code> twin used in Tyrant is really simple and the implementation straight-forward. Nevertheless, it encapsulates any knowledge about the <code>auth_meta_data</code> field and only exposes methods to query or change state.</p>\n\n<p>By using this twin, you don't need to think about the format or the meaning of the <code>auth_meta_field</code> at all, and this is a great improvement to Devise and its fellow gems.</p>\n\n<p>Instead of letting users change arbitrary fields manually, probably altering state to an invalid combination, <code>Authenticatable</code> provides an API to reach any possible state without having to learn about the semantics of <code>auth_meta_data</code>, or, as in Devise, <code>password_digest</code>, <code>confirmation_token_sent_at</code> and all the other columns that are not covered by any API.</p>\n\n<p>Now that we've learned everything, literally everything, of the internals of the SignUp process we should hook that into the controller and our UI. The next step is to render the signup form and process it.</p>\n\n\\n\n\n<p>In the <code>SessionsController</code> action <code>sign_up_form</code> we implement the form where users enter email, password and password confirmation. This is for the file <code>app/controllers/sessions_controller.rb</code>.</p>\n\n\n;;;\n\n<p>Presenting the sign up form couldn't be any simpler. We simply pass the <code>SignUp</code> operation to the controller's <code>form</code> method and move on to the view to render the fields.</p>\n\n<p>The view resides in <code>app/views/sessions/sign_up_form.html.haml</code> and is a standard controller view.</p>\n\n\n;;;\n\n<p>Again, this is so simple I won't waste any paper. As always, the form object of the operation is available as <code>@form</code>. Also, I need to point simple_form to the correct processing <code>:url</code> since I do not use <q>RESTful</q> style resources that do not make any sense here (line 2).</p>\n\n<p>When filled out and submitted, the form gets validated and processed in <code>SessionsController#sign_up</code>.</p>\n\n\n;;;\n\n<p>This time, I run the <code>SignUp</code> operation (line 4). When valid, a physical <code>User</code> gets created as discussed earlier, and the user gets redirected to the login page where they will see a message telling them to sign in (line 5-6).</p>\n\n<p>If invalid, the form gets rerenderd using the <code>sign_up_form</code> view and displays errors, e.g. when the passwords mismatch (line 9).</p>\n\n\\n\n\n<p>I have written many tests for signup since I was nervous. What would the suits tell me if users could login without being authorized? Better to write a few tests too many. That's why I test the <code>SignUp</code> operation in <code>test/concepts/session/sign_up_test.rb</code>.</p>\n\n\n;;;\n\n<p>Running the operation with valid input, I assume that the user model got persisted (line 4-10). I also make sure the email was set correctly (line 11). To make it 100% safe, I pass the created user model to <code>Authenticatable</code> and compare <code>digest</code> with the real password (line 12).</p>\n\n<p>Internally, the bcrypt library will now encrypt <code>\"123123\"</code> the same way it encrypted the old password, and compare it to the <code>auth_meta_data.password_digest</code> field. How that works, I have no idea, but again, I see the benefit of the <code>Authenticatable</code> twin and how it hides hideous details from me.</p>\n\n<p>In the test file, I have several more invalid cases tested which really do not need to be discussed here as they're all straight-forward.</p>\n\n\\n\n\n<p>The manual sign up works. Users can enter their credentials and when valid they get redirected to sign in screen. That we need to implement now.</p>\n\n<p>As a reminder, here are the two routes that connect our new <code>SignIn</code> operation to a form and processing action.</p>\n\n\n;;;\n\n<p>Looking at the <code>sign_in_form</code> action of the <code>SessionsController</code> you will see that this is really just another form-rendering action.</p>\n\n\n;;;\n\n<p>For completeness, I want to run through the contract definitions and the controller view to render the sign in form, real quick.</p>\n\n\\n\n\n<p>The <code>Session::SignIn</code> operation I put into the <code>app/concepts/session/operation.rb</code> file where we also keep <code>SignUp</code> and friends.</p>\n\n\n;;;\n\n<p>The only fields declared in the operation's contract are email and password (line 4-5). Both are virtual, meaning they won't be read from the model (and will not be written back in <code>#sync</code>).</p>\n\n<p>In our case, this means the contract can be initialized with a <code>nil</code> model and will still work as no values are attempted to be read from the <q>model</q>. This in turn implies our contract can successfully be rendered in the login screen even though we don't have a model for the contract.</p>\n\n<p>When initializing the contract in the controller using the <code>form</code> method, what basically happens is the following.</p>\n\n\n;;;\n\n<p>This is, of course, not the real implementation but shows all necessary steps. As we didn't define any model for this operation, the contract will be instantiated with nil. This works since all its fields are virtual.</p>\n\n<p>The corrensponding controller view <code>app/views/sessions/sign_in_form.html.haml</code> is incredibly sophisticated.</p>\n\n\n;;;\n\n<p>Most of the work goes into urging SimpleForm not to wildly assume names and routes, which I find quite inconvenient and makes me want to write my own form builder on some days. I configure the <code>:url</code> option and also need to tell the form builder to put all form fields under the <code>:session</code> key using the <code>:as</code> directive (line 1).</p>\n\n<p>I allow the user to enter email and password, and a submit button makes sense, too, here (line 2-4).</p>\n\n<p>Rendering forms is boring. Let's see how we handle the login process in our <code>SignUp</code> operation, the controller and Tyrant.</p>\n\n\\n\n\n<p>When submitting, the form gets sent to <code>SessionsController#sign_in</code>. Again, this is a simple delegation to the sign in operation.</p>\n\n\n;;;\n\n<p>In case of an invalid operation run, the user will be presented with the login form, again (line 8). If the operation is valid, a block of code is executed. First, a strange <code>tyrant</code> object is used and apparently executes the login process, and then the user gets redirected to the home page (line 4-5).</p>\n\n<p>Before discussing this <u>logic</u> in the controller in more detail, we should explore how the operation finds out about its validity. Here's the rest of the <code>SignIn</code> contract.</p>\n\n\n;;;\n\n<p>In addition to the properties we've already met there is a presence validation for both email and password to make sure these are always filled out (line 5). A custom validation named <code>password_ok?</code> will do the main work of this form.</p>\n\n<p>First, I need to verify that both fields are filled out, again (line 11)<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>.</p>\n\n<p>Then, something strange: I use the <code>User</code> model's finder to actually retrieve an object from the database. Since we need the model for verifying the password, there currently is no other place than the validation to find this (line 12).</p>\n\n<p>While this could happen in the operation, too, you'd have to access <code>params</code> there by hand to get the email. I don't like doing this as I prefer relying on the form's deserializing and then conveniently grab the submitted email via the contract's <code>email</code> reader.</p>\n\n<p>Also note that I assign the user object to an instance variable and expose a public reader for that (line 12 and 8).</p>\n\n<p>The last line is the actual validation. I check that a user was found and hand it to <code>Authenticatable</code> where I use the <code>digest?</code> method and pass in the submitted password (line 13-14). If <code>Authenticatable</code> decides this is the correct password the validation will be valid, otherwise, the contract and operation are marked as invalid.</p>\n\n<p>Form and validations are completed, the last step is the <code>SignUp#process</code> method.</p>\n\n\n;;;\n\n<p>The validations we just coded are run using the operation's <code>validate</code> method (line 4). I pass in the <code>:session</code> key of the <code>params</code> hash because I named the form <code>session</code>, as explained earlier.</p>\n\n<p>If the validations are successful and valid, all I do is assign the operation's instance variable <code>@model</code> by copying the user from the contract (line 5). This is simply the <code>User</code> instance we used in the validation.</p>\n\n<p>We processed the form submission, validated the data, found a user object, all we need now is to log it in. This happens in the controller.</p>\n\n\n;;;\n\n<p>Remember, the block passed to <code>run</code> is only invoked for a successful operation with a valid state. I simply pass the model, originally from the operation's contract, to the <code>sign_in!</code> method (line 3).</p>\n\n<p>Now, where does this <code>tyrant</code> object come from? You will agree with me that every application needs a tyrant, but what exactly is that?</p>\n\n\\n\n\n<p>Signing in a user works by passing a cookie to the browser after a successful login. The cookie will then, per request, authenticate the browser with a certain user in the backend.</p>\n\n<p>Cookies are very HTTP-specific concepts and I believe that operations should not know about this low-level mechanism unless you really need to replicate this behavior in other environments of your application, for instance, in a cookie-backed document API - which is not really what REST is about.</p>\n\n<p>That being said, I made three technical decisions for Gemgem authentication.</p>\n\n<ol>\n<li>The app-wide <code>tyrant</code> object acts as binding between application and authentication. It is managed in <code>ApplicationController</code> as controllers are the place where we may deal with the transport layer (HTTP) to access cookies.</li>\n<li>Physically invoking sign in and sign out, too, happens in the controller. In the <code>sign_in</code> action, you can see how the <code>tyrant</code> object is used to log in the user. While this could go into operations, I like it better here.</li>\n<li>Sign-in specific authorization, e.g. showing or rejecting the sign in form, goes into a <code>before_filter</code> in the involved controller. As we will learn in the next chapter, a policy could be used here, too. However, this is so HTTP-specific that I won't bother my operation code with it.</li>\n</ol>\n\n\n;;;\n\n<p>The <code>tyrant</code> method is the first <q>helper</q> I add to Gemgem. It returns a <code>Tyrant::Session</code> object and as input it requires a part of the request (line 4). The <code>request</code> is only available in controllers which is why I allow this single helper to be here.</p>\n\n<p>As our views are not completely cells-based, this method is also allowed to be called in views (line 6).</p>\n\n<p>The <code>tyrant</code> object exposes a minimal, super simple API to manage authentication. Its public methods are <code>sign_in!</code>, <code>sign_out!</code>, <code>signed_in?</code> and <code>current_user</code>. Behind the scenes, <code>Session</code> will implement these functions using the global Warden object.</p>\n\n<p>Recall the <code>sign_in</code> action of our sessions controller.</p>\n\n\n;;;\n\n<p>Not sure if that needs any explanation. If the <code>SignIn</code> operation decided that the email/password tuple is valid, the user found in the operation is signed in using <code>sign_in!</code> (line 2). From now on, a cookie handled by Warden will sit in the user's browser and authenticate the session in each request, providing us with a current user object.</p>\n\n<h3>Before_filter</h3>\n\n<p>Signing in should only be allowed for sessions that are not logged in, yet. This isn't really security-relevant but a good time to discuss why I very rarely use a before_filter to protect entire controller actions from unauthenticated access.</p>\n\n\n;;;\n\n<p>The <code>tyrant</code> object is queried if a user is signed in. If this is true, requests to <code>sign_in_form</code> and <code>sign_in</code> are redirected to the home page and prevent <q>double logins</q> that theoretically wouldn't hurt at all, but anyway (line 2-4).</p>\n\n<p>Why am I using a filter here? Didn't we say <u><q>No business logic in controllers!</q></u>?</p>\n\n<p>Think of an operation as a reusable function. Reusable not because you could use them across different applications, but reusable within your Rails app in different environments. You will surely remember how we use operations in controllers and in tests as factories and how great this feels.</p>\n\n<p>All operations in the <code>Session</code> namespace are relevant to HTTP environments, though. It really doesn't make sense to call them on the command line as there is no concept of authentication in CLIs. Likewise, this doesn't apply to unit tests.</p>\n\n<p>Don't confuse <u>authorization</u> with <u>authentication</u> here! We will learn at the end of this chapter and in the following one how we definitely need to differentiate between different user roles. Nevertheless, this has nothing to do with HTTP cookies.</p>\n\n<p>In other words: Technically, I could have implemented the <code>SignIn</code> operation in the controller itself as it won't be used anywhere else. I would have to replicate the form behavior, though, and hence use an operation here too, but leave HTTP-specific logic in the controller.</p>\n\n<p>This is why filter and the actual sign in code sits in the controller.</p>\n\n\\n\n\n<p>Now that we can login, it'll be cool to have some kind of visible indicator that we're signed in. I add a welcome message to the navigation bar in <code>views/layouts/_navigation_links.html.haml</code>.</p>\n\n\n;;;\n\n<p>A classic Rails view here does the trick. With a rather ugly if/else block I put two different contexts into the same view. Admittedly, this is becoming unpretty and should be refactored to a cell. Soon!</p>\n\n<p>I use the <code>tyrant</code> helper that we defined earlier in <code>ApplicationController</code> and differentiate between signed in and public user (line 3 and 9). The <u><q>Hi, jonny@trb.org</q></u> string is only rendered for a signed in user (line 5).</p>\n\n<p>This is a massive change to the view and requires a functional test. We will write it shortly when we test sign in and out.</p>\n\n\\n\n\n<p>Before we see this all in action in one of our wonderful integration tests, here's a quick rundown of signing out a user. This is so simple I won't waste more than half a page for this - let's save another tree, instead.</p>\n\n\n;;;\n\n<p>I add one route to the <code>sign_out</code> action of the sessions controller. Note that this is done with a simple <code>GET</code> so we can easily sign out following a link. If you still think you have to implement that with a fake <code>DELETE</code> request to a <code>session</code> <q>resource</q>, feel free to hook <code>SignOut</code> into any action you like.</p>\n\n\n;;;\n\n<p>Given the <code>SignOut</code> operation is valid, which is currently always true, we sign out the session via the <code>tyrant</code> object (line 3).</p>\n\n<p>The operation itself is empty.</p>\n\n\n;;;\n\n<p>No validations or processing are found here. I still map this to an operation in case we want to add behavior, for example, logging the sign out of the user. Mainly, this operation is here for consistency.</p>\n\n\\n\n\n<p>As I won't use <code>SignIn</code> other than for the controller, I test the entire sign in/out process via an integration test, only. This will give me maximum security and since there's not many edge cases, a few smoke tests won't be too hard to implement.</p>\n\n<p>Both sign in and sign out go into <code>test/integration/session_test.rb</code>. Here, I will only discuss the happy path, but you can find several negative tests in the repository.</p>\n\n\n;;;\n\n<p>I first sign up and log in using the UI (line 4-6). In order to do so, I wrote two helper methods <code>submit_sign_up!</code> and <code>submit!</code> to automate form submissions. These helpers sit directly in the test class and you can find them in the repository.</p>\n\n<p>Sending the correct credentials I assert that the page now shows the welcome message in the navigation bar (line 8). This is enough test code to make sure logging in works. I explicitly do not check for cookies or anything hidden but only test for strings or selectors that I could <q>see</q> in a real click test.</p>\n\n<p>After that, I make sure the sign in screen isn't accessable for signed in users and we get redirected to the home page (line 11-12)</p>\n\n\n;;;\n\n<p>As a last step, I click the sign out link which should redirect me back to the home page (line 1-2). Again, I don't check for hidden values but simply make sure there ain't no greeting on the page, anymore (line 3).</p>\n\n\\n\n\n<p>In the last part of the chapter I want to focus on sleeping users and, of course, waking them up and activating their account.</p>\n\n<p>When we implicitly create users when commenting or adding authors to things, so far we literally only <q>create</q> them without marking them as sleeping. This needs to be fixed before we move on to waking them up.</p>\n\n<p>In the <code>app/concepts/comment/operation.rb</code> file, I add a callback to put the user to sleep once it got created when commenting.</p>\n\n\n;;;\n\n<p>Using a <code>callback</code> block I instruct the operation to invoke <code>sign_up_sleeping!</code> when a change was detected (line 4). However, this <q>change</q> is limited to the <code>user</code> property of the contract twin by using the <code>:property</code> option.</p>\n\n<p>The <code>:property</code> option in combination with <code>on_change</code> is a nice trick to trigger a callback only when a nested property has changed. In our example, this callback is always invoked since we always have to add an email to the comment's user, which will be regarded as <q>changed</q>.</p>\n\n<p>The implementation of the callback goes into the <code>Comment::Create</code> operation.</p>\n\n\n;;;\n\n<p>Since the callback method always receives the form twin it was detected on, I invoke <code>comment.user.model</code> to retrieve the actual user model and pass it to <code>Authenticatable</code> (line 2). The <code>confirmable!</code> method will take care of marking this model as <q>sleeping</q> (line 3). In order to write that to the model, I call <code>sync</code> on the twin (line 4).</p>\n\n<p>The user model's <code>auth_meta_data</code> hash now contains all data needed to interpret this user as confirmable, or <q>sleeping</q>, as we call it.</p>\n\n<p>As a last step, we need to actually trigger the callback group so the <code>on_change</code> gets detected and the above logic gets run. As always, this happens in the operation's <code>process</code> method.</p>\n\n\n;;;\n\n<p>The call to <code>dispatch!</code> will invoke the default callback group we just created, find the user object that has changed and call <code>sign_up_sleeping!</code> (line 3).</p>\n\n<h3>Callback in Thing::Create</h3>\n\n<p>The analogue we need to implement when adding authors to things. Again, I add a callback to <code>Thing::Create</code> in its callback file <code>app/concepts/thing/callback.rb</code>.</p>\n\n\n;;;\n\n<p>In addition to the <code>:upload_image!</code> callback that was there before, I add <code>sign_up_sleeping!</code> (line 5-7). Here, I use the <code>on_add</code> hook in the <code>users</code> collection which will trigger this callback for every user that has been added in <code>process</code> .</p>\n\n<p>The callback itself is very similar to the one in <code>Comment::Create</code>.</p>\n\n\n;;;\n\n<p>First, I need to check whether or not this user has been created just now. I do this by calling <code>persisted?</code> on the user twin, which will return false if the model hasn't been written to the database, yet (line 4). That in turn means the user is new and needs to sleep, as it has been created implicitly.</p>\n\n<p>The rest of the code is identical to the callback above. In the next chapter, we will extract common logic to a separate class.</p>\n\n<p>Since the <code>:before_save</code> callback already gets invoked in <code>Thing::Create#process</code>, no other changes are needed here.</p>\n\n<p>For both cases, commenting and adding authors to things, new users will now be marked as sleeping, or, as Tyrant calls it, <q>confirmable</q> and will allow them to set a password and activate their account.</p>\n\n\\n\n\n<p>We covered all major concepts of authentication: signing up new users, implicitly creating <q>sleeping users</q> when commenting and when adding new things, signing in and out, the only function missing to finish this chapter is allowing users to activate their sleeping account.</p>\n\n<p>This works by following the link in the email that points to <code>SessionsController#wake_up</code> and passes on the confirmation token. If the latter is correct and matches the sleeping user's token, a form is displayed to let the user set a password. Submitting two identical passwords will activate, or <q>wake up</q> the user's account.</p>\n\n<p>Here's the two routes I added to implement the form and the processing endpoints.</p>\n\n\n;;;\n\n<p>I left out some noise required by Rails' routing weirdness. The wake up link will point to the <code>wake_up_form</code> controller action and have a format similar to the following.</p>\n\n\n;;;\n\n<p>Both user id and confirmation token are embedded in the URL. The action first needs to check whether the confirmation token is valid and only then render the form to set the password.</p>\n\n\n;;;\n\n<p>With a <code>before_filter</code> I restrict access: only when params contains the correct confirmation_token for the provided user, the form is rendered. Otherwise, a redirect to the home page happens (line 3-5).</p>\n\n<h3>Validating Operation</h3>\n\n<p>I use an Operation here to validate the confirmation token. This is used in other places, too, so it is legit to model that behavior in an operation. Note that I use <code>Operation</code>'s <code>reject</code> class method here instead of <code>run</code>. <code>reject</code> will do the exact same thing as <code>run</code> but execute the passed block when the result is invalid.</p>\n\n<p>In the actual controller action, we use <code>form</code> to render the password form (line 7-9).</p>\n\n<p>Let's see what the <code>IsConfirmable</code> operation looks like and then inspect the password form.</p>\n\n\n;;;\n\n<p>Since the incoming params hash contains the sleeping user's ID I use <code>CRUD</code> to do the model finding for me (line 3). This won't work unless I configure that this is a find-only operation (line 4).</p>\n\n<p>When running the operation, the user model will automatically be available via <code>model</code> (line 7). I use <code>Authenticatable</code> to find out whether or not this user is confirmable. The <code>confirmable?</code> method requires the token to be passed in and will then check the <code>auth_meta_data</code> field for the <code>confirmation_token</code>, do the comparison and return the result (line 8).</p>\n\n<p>If this is all correct, I return (line 7-8). This will leave the operation as valid and thus won't trigger a redirect in the before_filter.</p>\n\n<p>Otherwise, I invoke <code>invalid!</code> to mark the operation as failed. This will redirect the browser prohibiting access to the change-password form.</p>\n\n<h3>WakeUp</h3>\n\n<p>To understand the rendering of the form we need to have a look at the <code>WakeUp</code> operation, first.</p>\n\n\n;;;\n\n<p>Again, this uses CRUD and finds the user object according to the <code>:id</code> field in the incoming params (line 3-4).</p>\n\n<p>The contract then defines two fields <code>password</code> and <code>confirm_password</code>, both virtual, to allow the user to enter their desired passphrase (line 7-8).</p>\n\n<p>The form view in <code>app/views/sessions/wake_up_form.html.haml</code> is simple, too.</p>\n\n\n;;;\n\n<p>The form's URL points to <code>SessionsController#wake_up</code> to initialize the user's password. Since this URL needs a user ID, I directly access <code>params[:id]</code> which is a bit dirty but does the trick for now (line 1). Usually, I never allow views to access <code>params</code> and I really should do this via the operation or the form.</p>\n\n<p>I add the two password fields and a submit button (line 2-4). What's more important is that I add a hidden field named <code>confirmation_token</code> (line 5-6). Its value I grab from <code>@operation.confirmation_token</code> (line 6) and we will see how that is set in a minute.</p>\n\n<p>The reason I do this is to allow users to resend the form should it be invalid. The <code>wake_up</code> action always needs a confirmation token to be sent, so we have to embed it into the form using this trick.</p>\n\n<h3>Processing Wake Up</h3>\n\n<p>When submitted, the <code>wake_up</code> controller action is hit.</p>\n\n\n;;;\n\n<p>If the <code>WakeUp</code> operation wasn't run successfully, the form is rerendered (line 8). Otherwise, a valid processing will redirect the awaken user to the login page (line 5). I added a flash message to indicate my excitement about this very moment (line 4).</p>\n\n<p>Let's now discuss the rest of the <code>WakeUp</code> operation.</p>\n\n\n;;;\n\n<p>A presence validation makes sure both fields are filled out (line 6). The custom validator <code>password_ok?</code> will check if both passwords match (line 7 and 9-13). I will replace this redundant code with a module later, as this is almost identical and copied from <code>SignUp</code>.</p>\n\n<p>The next part of the <code>WakeUp</code> operation will validate and set passwords in case of success.</p>\n\n\n;;;\n\n<p>A private method <code>wake_up!</code> only gets invoked when validations returned a true result (line 4).</p>\n\n<p>To set the password and confirm the user, I use <code>Authenticatable</code> and pass in the <code>User</code> instance of the operation (line 10). Using our old friend <code>digest!</code> the password is set (line 11). <code>confirmed!</code> marks the user as <q>awake</q> (line 12). A <code>sync</code> on the <code>Authenticatable</code> instance writes the <code>auth_meta_data</code> to the user model and <code>save</code> on the contract will persist all changes made to the user (line 13-14).</p>\n\n<p>In order to allow the form view to render the confirmation token, we need to add a bit of code here. This time, I won't access <code>params</code> but provide it from the operation. I do this to demonstrate different ways of how to access data from the operation.</p>\n\n\n;;;\n\n<p>In the <code>setup_params!</code> hook I simply grab the respective params element and assign it to an instance variable of the operation object (line 5). By exposing a public reader, this can be read in the view (line 4).</p>\n\n<p>As long as the params value and the operation's token don't diverge, you can safely use the <code>params</code> hash directly in the view. However, often, data gets further processed in an operation and then you shouldn't use global data but access it via the operation. Or, and that's the clean way, with a cell, as we will learn it in the next chapter.</p>\n\n\\n\n\n<p>The wake up function deserves tests. Again, all testing happens on the top-level in integration tests as we don't use any of the functions outside the HTTP environment, yet.</p>\n\n<p>This will change in the next chapter, by the way, where we will add some admin pages and expose functionality like <u><q>Wake up user!</q></u> to the web UI.</p>\n\n<p>Tests for the wake up operation go into <code>tests/controller/session_integration_test.rb</code>. I only explain one test case, the happy path. The failing ones are in the repository and so simple that we don't discuss them here.</p>\n\n\n;;;\n\n<p>In the first part of the test I create a thing with an implicit user using the <code>Thing::Create</code> operation (line 3-5). Note how I grab the sleeping user using the <code>users</code> association on the thing model.</p>\n\n<p><code>Authenticatable</code> then helps me to grab the confirmation token from the newly created user (line 7).</p>\n\n<p>I then compute the wake up URL by hand and open this page (line 9). Admittedly, I could utilize a URL helper here, but since I won't change the URL layout, I find the compilation doesn't break any DRY principles.</p>\n\n<p>In the following three tests I make sure that we really see a positive <u><q>Activate your account, [email]!</q></u> header and the form (line 11-13).</p>\n\n\n;;;\n\n<p>By entering two identical passwords and submitting the form, I hopefully wake up my sleeping author (line 1-3).</p>\n\n<p>I then check the flash message (line 5). Again, <code>Authenticatable</code> comes to help me with checking if the user is confirmed, now, which should be the case after submitting the password form successfully (line 6).</p>\n\n<p>By testing the current path I assert that we're now on the sign in page and ready to log in (line 8).</p>\n\n\n;;;\n\n<p>The last part signs in using the form (line 1-3). It is followed by the same tedious test we had a hundred times before where I make sure the welcome message is visible (line 5).</p>\n\n<hr>\n\n<p>Hang on, did we really finish this chapter? It seems so, because we now create sleeping users implicitly in several functions in Gemgem. These users can then, later, confirm their account.</p>\n\n<p>They can also sign up manually, and we have a beautiful login page in place. And, eventually, when people get sick of Gemgem, there's a sign out button.</p>\n\n<p>The amount of code needed for this is surprisingly little. This is partly because we reuse a lot of Trailblazer's structuring and can focus on the authentication logic instead of figuring out where to put this or that code.</p>\n\n<p>Another reason is Tyrant. We do not use many features of Tyrant, yet, but it already saved us a lot of hassle. All logic related to authentication management, like password, confirmation flags, and tokens are encapuslated by <code>Authenticatable</code>. And in the next chapter, we will learn how to save even more code by simply subclassing Tyrant operations and customizing the well tested classes from this gem.</p>\n\n<p>Speaking of the next chapter! Let's move on and learn some more things about authorization in business logic, views and operations.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>This is very likely to get replaced with nested validations that will soon be available in Reform and make chained conditional validations simpler. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>Now that we can log in and out, sign up as new users or wake up sleeping users that were implicitly created, it is about time to add some more user-specific features. This chapter discusses how we can use polymorphic techniques to change the look and behavior of application functions for specific users.</p>\n\n\n;;;\n\n<p>Signed-in users will see a <u><q>I'm the author!</q></u> checkbox when creating or editing a thing, making them an author without having to fill in their email address into one of the author fields.</p>\n\n<p>Consequently, signed-in thing authors, and only those, can edit and delete things. They will see links to do so on the thing show page, but again, only for things they authored.</p>\n\n<p>Anonymous users won't be able to update or delete things anymore, the only allowed action is create.</p>\n\n<p>We then introduce the concept of an admin user. The admin can edit and delete any thing. As a superuser, it can even change the name of a thing after creation, a feature that we restrict to admins exclusively.</p>\n\n<p>The forms will have a conspicuous orange background when logged in as admin to remind you of your power, acting as a nice example how not only operation logic can be changed according to the configured rules, but also views.</p>\n\n\n;;;\n\n<p>A cool feature that I found extremely helpful while writing Gemgem is <q>impersonation</q>. As an admin user, you will be able to live out your multiple personalities to the fullest, as you can switch users on the fly while browsing. The application will now treat you as the impersonated user with the respective subset of rights.</p>\n\n<p>The navigation menu will display a star with a tooltip showing who you actually are and who you're pretending to be. Crazy stuff, I know.</p>\n\n\\n\n\n<p>The first step when introducing user-specific functionality in a Trailblazer app is usually adding a policy to every operation that needs access control. A policy is a Ruby class that contains methods which represent rules. Policies have access to the current user and an arbitrary model and can thus compute permissions.</p>\n\n<p>The way policies are designed in Trailblazer was greatly inspired by the excellent <a href=\"https://github.com/elabs/pundit\">Pundit</a> gem that introduced the idea of policy classes in Ruby. However, in Pundit policies are usually installed per model, whereas in Trailblazer, you have policy classes per concept or per operation.</p>\n\n<p>Here's how the <code>Thing::Create</code> operation looks after I add a policy.</p>\n\n\n;;;\n\n<p>The <code>Policy</code> module comes from Trailblazer and needs to be included to import the <code>policy</code> class method and additional logic that is discussed in the following section (line 3).</p>\n\n<p>To activate the policy, I reference the policy class <code>Thing::Policy</code> and the rule that has to pass (line 4). Before we start learning how that all plays together, let's have a quick look into the policy class which is located in the concept directory at <code>app/concepts/thing/policy.rb</code>.</p>\n\n\n;;;\n\n<p>A policy object does nothing fancy. It is to be initialized with the user and model (line 4-6), you can query different rule methods on it and expect a boolean return value representing whether or not to allow this action in the context of the user/model tuple.</p>\n\n<p>Our first rule <code>create?</code> will always return true, which is why I don't even access <code>user</code> or <code>model</code> in the rule method. That means any user, even not signed-in, can run the <code>Create</code> operation.</p>\n\n<p>Creating and evaluating the policy object is all done automatically by the operation. You are wondering now, where is that policy object instantiated, how do user and model get into it, where is the policy applied and what happens when it returns <code>false</code>?</p>\n\n<p>Imagine we were running the <code>Thing::Create</code> operation with the following input.</p>\n\n\n;;;\n\n<p>Without a policy, the operation's <code>setup!</code> method would create a fresh model, the subsequent <code>process</code> method would run your business code and we're done.</p>\n\n<p>However, with a policy being configured, things work a tiny bit different.</p>\n\n<p>The important part for us right now is: the policy is run in the operation's <code>setup!</code> method which is called right after the operation object got instantiated, but before <code>process</code> is invoked.</p>\n\n<p>Here's roughly what it looks like when running the operation. Please note that this code just illustrates the workflow.</p>\n\n\n;;;\n\n<p>As you can see, both the current user and the model are passed into the policy constructor (line 3). Per default, the operation will use the <code>:current_user</code> hash key from <code>params</code> to find the signed in user. This means, in case you run an operation manually, you need to pass in this object using the correct hash key.</p>\n\n<p>After the policy creation, the configured rule method is called (line 4). If the result is falsey, an exception is raised.</p>\n\n<p>The fact that the policy is evaluated in <code>setup!</code>, potentially throwing a <code>NotAuthorizedError</code>, will prevent your business code in <code>process</code> being run in case of a policy violation.</p>\n\n<p>Coming back to our example, this particular policy will always pass since the <code>create</code>? method simply returns true. This means, the operation can be run regardless whether or not anyone is signed in.</p>\n\n\\n\n\n<p>Even though this policy is more than boring and nothing exciting is gonna happen, I add it on purpose to <code>Create</code>. First, it is good to have some convention and I find it easier to add an empty policy which can then later be changed than having to rewire things once you need restrictions.</p>\n\n<p>Second, policy objects in Trailblazer are not only useful for restricting access per operation. They are also extremely helpful in <u>builders</u> that resolve which concrete operation subclass to instantiate.</p>\n\n<p>Hang on, what subclasses am I talking about? So far, we only inherit between different function operations. The <code>Thing::Update</code> class is derived from the <code>Create</code> class and inherits methods, contracts and the other components that an operation orchestrates.</p>\n\n<h3>Context</h3>\n\n<p>Builders, whatsoever, are meant to differentiate between different contexts for one function and then compute the matching subclass.</p>\n\n<p>A <u>context</u> is usually refering to different users types like admins or moderators. With a different logged in user <u>context</u> comes a different behavior of UI and application. Nevertheless, contexts can also be the refinements for differing model types in case you're using STI, where subclasses change their semantics.</p>\n\n\n;;;\n\n<p>In this chapter, we are going to exploit the polymorphic characteristics of Traiblazer and take advantage of how subclassing or composites allow to refine a generic operation to a concrete context.</p>\n\n<p>For instance, <code>Create</code> will have two subclasses <code>Create::SignedIn</code> and <code>Create::Admin</code> to fine-tune the contract and callbacks to the respective user type.</p>\n\n<p>Allow me to quickly add these two new subclasses in order to demonstrate you how polymorphic operations and builders simplify your code.</p>\n\n\n;;;\n\n<p>Here, we have the good ol' <code>Create</code> operation in all its beauty. The <code>SignedIn</code> class I put inline into the create class. That way, I will get the desired name <code>Thing::Create::SignedIn</code>. By inheriting from <code>self</code> it will be derived from the containing class (line 4). I could have simply said <code>class SignedIn &lt; Create</code> but using self is less redundant and part of my OCD.</p>\n\n<p>Likewise, <code>Admin</code> inherits from <code>SignedIn</code> and is namespaced as <code>Thing::Create::Admin</code>.</p>\n\n<p>As we learned in chapter 3, inheriting from another operation will copy all methods to the new class in a plain Ruby way. In addition to that, the contract, callbacks, policies and representers will be copied and can be refined in the subclass without affecting the original.</p>\n\n\\n\n\n<p>The point about using subclasses and polymorphism is the avoid ugly <code>if/else</code> deciders throughout your code as seen in every Rails application. We will soon see how much better organized our code is by applying simple OOP instead of maintaining all contexts in one class and then manually dispatch and modify semantics with deciders.</p>\n\n<p>The caller of your polymorphic operation doesn't even know that there's different subclasses to handle different contexts. <u>Builders</u>, a concept that originates from the Cells gem and proved to be very popular, takes the configuration of what subclass to create into the super class.</p>\n\n<p>Applying this new concept to <code>Thing::Create</code> will change the class header a bit.</p>\n\n\n;;;\n\n<p>Inside the <code>builds</code> block is where different contexts get identified and then dispatched to the respective subclass (line 6-9). As a matter of fact, this block is executed in class context before the actual class gets instantiated.</p>\n\n<p>It receives the model, policy object and the params being passed to the operation call. How that all works and why the model is already available at this early point I will explain in a minute.</p>\n\n<p>In the block you can run arbitrary code, inspect the incoming params, and so on to figure out what's the environment. <code>if/else</code> in a builder is required but it will be the only central place to differentiate between contexts.</p>\n\n<p>In my block, I extensively make use of the policy object and call methods like <code>admin?</code> and <code>signed_in?</code> on it. These methods I had to add the the <code>Thing::Policy</code> class.</p>\n\n\n;;;\n\n<p>I add two methods to the policy. The <code>signed_in?</code> method accesses the <code>user</code> and makes sure it's present (line 3-5). Remember, both user and model get passed into the policy and are available at any point.</p>\n\n<p>The <code>admin?</code> rule method checks if the signed-in user is an admin - in this example, this is a lame, hard-coded check of the user's email (line 7-9). You're free to run arbitrary logic here to figure out the user's role, I use the admin email for simplicity.</p>\n\n<p>We'll get to the <u><q>How did the user and model get into the policy?</q></u> in the next section. Now that we understand how to query the policy for different environments, we can use that to build different operations.</p>\n\n\n;;;\n\n<p>In case of a logged-in admin user, the builder block will return <code>self::Admin</code>. The <code>self</code> namespace is a technique to dynamically evaluate a constant and it will make more sense when we get to the <code>Update</code> operation in a few pages.</p>\n\n<p>Given our current environment, the <code>builds</code> block will return the constant <code>Thing::Create::Admin</code> for an admin user. Analoguely to that we build a <code>SignedIn</code> operation for that particular case. If the block doesn't return anything, the original class <code>Thing::Create</code> is instantiated.</p>\n\n<p>Note that the operation's main policy rule <code>create?</code> is not run at this point, the policy object is just instantiated for your convenience. The builder only works out what class to instantiate, the actual operation rule is run at a later point.</p>\n\n\\n\n\n<p>Having the builder in place, you can play around with your operation to really understand how builders work. Since both new classes are empty, you can run the operation and it will perform the exact same thing for all three contexts. However, the operation's class will change.</p>\n\n\n;;;\n\n<p>Again I want to note how this changes things from the operation user having to know about contexts to a user simply passing arguments to the operation which, in turn, figures out internally what concrete class to instantiate.</p>\n\n<p>We've created a strong interface while minimizing error sources.</p>\n\n<p>This is called <u>polymorphism</u> as we will have different behavior without having to know what exactly is changing from the outside.</p>\n\n<p>Now, to fully understand builders, we need to go a step back. In the <code>Create</code> class I included <code>Resolver</code> instead of <code>Policy</code>. A result of mixing in <code>Resolver</code> is that both policy and model are instantiated before the operation and therefore are available in the builder block.</p>\n\n<p>Here's another pseudo flow snippet of what happens when you run the <code>Thing::Create</code> operation with <code>Resolver</code> being mixed in. It explains which steps are involved in order to give you a convenient setup for the operation dispatch.</p>\n\n\n;;;\n\n<ol>\n<li>The first thing, and that's different to the workflow we've learned before using <code>Resolver</code>, is that the model gets found or created on the class level (line 2), before the operation is instantiated. Other than that, CRUD semantics are identical.</li>\n<li>Using the model and the params hash that got passed into the operation, the policy object is instantiated (line 3). Since the params hash contains the <code>:current_user</code>, the policy object has access to user and model and is ready to answer questions about rules.</li>\n<li>Now, the <code>builds</code> block is run. You now understand where all the block arguments come from. The builder will always return a valid class constant (line 4).</li>\n<li>This constant is then instantiated which results in an operation object that is being run (line 5).</li>\n</ol>\n\n<p>The nice thing about builders is that we don't need to change our application code at all. This also applies to the tests. The caller of an operation shouldn't even know about the different subclasses, and therefore, our controller actions don't change at all.</p>\n\n\n;;;\n\n<p>So far, we've created three operation classes for three different contexts: anonymous, signed-in, admin. However, they are still identical, so we should now start refining the signed-in and admin operations so our polymorphic dispatch actually makes sense.</p>\n\n\\n\n\n<p>Earlier, I mentioned that the create and update form for <code>Thing</code> should have a <u><q>I'm the author!</q></u> checkbox when a user is signed in. This means we have to add a boolean field to the contract and we have to add logic to the operation that adds the current user to the freshly created thing if this box is checked.</p>\n\n<p>Again, these are semantics for signed-in users, only, and must not be mixed with the operation for anonymous users. This is why I have different operations <code>Thing::Create</code> to handle anonymous users and <code>Thing::Create::SignedIn</code> for the registered counterpart.</p>\n\n<p>Refining <code>SignedIn</code>'s contract could happen just in the particular class, as we did it in chapter 3. However, admin users should experience the same behavior, and we're also gonna need this for the <code>Update</code> operations, so I will put the refinement code into an <u>operation module</u> that sits at <code>app/concepts/thing/signed_in.rb</code>.</p>\n\n\n;;;\n\n<p>The separate file is a simple Ruby module in the <code>Thing</code> namespace (line 1). To allow using the operation API I include <code>Trailblazer::Operation::Module</code> (line 2). I can now refine my contract and all other composite objects of any operation.</p>\n\n<p>As for the contract, all I do is adding an additional property <code>is_author</code> (line 5). It's a virtual field which won't get read and written to the model and defaults to zero. This in particular means: when the form is created for rendering or validation, this value will always default to zero.</p>\n\n<p>The virtual field alone won't change anything in the including operations. To actually extend the behavior, too, I add a callback using the <code>callback</code> API in the operation module.</p>\n\n\n;;;\n\n<p>Using an <code>on_change</code> event I register the new method <code>add_current_user_as_author!</code> in the <code>:before_save</code> callback group. According to the configuration, this method is only called when the <code>is_author</code> field has changed after validating the form (line 4). This is a very convenient way to add behavior to the operation without having to override any code.</p>\n\n<p>The callback method receives the <code>thing</code> twin (actually, the contract, which is a twin) and also the <code>params</code> hash, so I can add the <code>:current_user</code> to the twin's users list (line 6-8). Since this is happening before we save, the added user object will be associated and persisted on the ActiveRecord level once we call <code>form.save</code>.</p>\n\n<p>This code is beautiful, but it is still completely useless as we have to plug the new module into an actual operation to make it come into effect.</p>\n\n\n;;;\n\n<p>To enable the changes and additions, I <code>include</code> the new module into the <code>SignedIn</code> operation class (line 4). This will, at compile-type, extend the original class with the code from the module, add the property to the contract and push a new callback into the <code>:before_save</code> group.</p>\n\n<p>Since <code>Admin</code> inherits from that class, nothing needs to be done there (line 7-8).</p>\n\n\\n\n\n<p>With Trailblazer, testing is fun! At least, that's what I keep telling myself. Since test files are getting bigger and bigger, I split them up into <code>test/concepts/thing/create_test.rb</code>, <code>update_test.rb</code>, and so on.</p>\n\n<p>To assure that we didn't break anything and our <code>SignedIn</code> module does what we want, I add a new test block to <code>test/concepts/thing/create_test.rb</code>.</p>\n\n<p>At the top of the test file, I add some fixtures we're gonna need throughout the tests.</p>\n\n\n;;;\n\n<p>Remember the policy that identifies admins via the special email address? I know it'sketchy, but to minimize redundancy I create this special user once (line 3).</p>\n\n<p>To test the <code>:is_author</code> feature, I add a new describe block.</p>\n\n\n;;;\n\n<p>In the first test case, I make sure that <code>Thing::Create</code> doesn't process the <code>is_author</code> property. Even though it's set to <code>\"1\"</code> it doesn't crash (line 9). This is because we don't pass in a valid <code>current_user</code> which in turn will instantiate the <q>normal</q> <code>Thing::Create</code> operation and not one of the two subclasses that process this new property (line 10).</p>\n\n<p>By testing that there's only one author - the user we passed in via <code>users:</code> - this test assures that our builder works and the original operation didn't get screwed up. To be honest, I probably wouldn't even test this since I trust Trailblazer and its builder pattern, but I thought it is a great way to demonstrate the power of polymorphism.</p>\n\n\n;;;\n\n<p>The next case passes in an existing current user and hence instantiates <code>Thing::Create::SignedIn</code> (line 5). Given that <code>is_author</code> is a true value, I now require the operation to have two authors, the one I explicitly passed via the <code>users</code> fields, and the current user (line 6).</p>\n\n<p>I added more tests with zero values for the <code>is_author</code> field to assure that those values are not processed and the current user won't get added. These tests are in the repository and very similar to the ones above.</p>\n\n<p>The tests for admin semantics are identical. For the sake of understanding, here's another case I added for you, and not for the actual application as it tests redundant facts.</p>\n\n\n;;;\n\n<p>This time, it's the admin user that gets passed into the operation as current user (line 5). After testing that both users are added as authors I do something completely unnecessary (line 6). In the last line, I test if the actual operation is of type <code>Admin</code> (line 7).</p>\n\n<p>Personally, I wouldn't write such an assertion as it tests internals. Anyway, say you had very complicated builder code and you don't want to test them via asserting side effects, you could also inspect the concrete operation class.</p>\n\n<hr>\n\n<p>We've successfully finished the first chunk of work of this chapter. Dependent on the current user different operation subclasses get instantiated and expose differing behavior. Sharing generic logic happens via inheritance and modules in a very rubyesque way. The tests only assert public semantics and do not know anything about the internals and how the desired result is achieved.</p>\n\n\\n\n\n<p>After all this dry operation and test coding, let's put those changes into practice. It'll be cool to see different forms for the operations. Signed-in and admin users have to see that <u><q>I'm the author!</q></u> checkbox. Going further, I want the form to have an orange background if an admin is logged in.</p>\n\n<p>When being confronted with a context-sensitive view that is supposed to change its apparel with different user types there's three options to tackle this problem.</p>\n\n<p>We could simply use a Rails controller view with <code>if</code>s and partials, and pass around locals and instance variables. We will have a hard time at some point figuring out what is the dependencies we need for the view.</p>\n\n<p>Dependencies, that word is crying for view components. We could encapsulate the view in a polymorphic cell and use view inheritance to override parts of the template with user-specific content. We'd have a clearly visible interface. However, the view inheritance often produces more classes and view files than necessary.<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup></p>\n\n<p>The third solution is combining the two above. Why not use a cell with some <code>if</code>s, solving this problem of presenting a context-sensitive form in a pragmatic, yet clean way? Let's do that!</p>\n\n<p>To convert the thing form into a cell, I literally rename the <code>app/views/things/new.html.haml</code> template and convert it to a cell view in <code>app/concepts/thing/views/form.haml</code>.</p>\n\n<p>Here's the view top part after I <q>cellified</q> it.</p>\n\n\n;;;\n\n<p>This view is identical to the old view, only that I changed the instance variable <code>@form</code> into <code>contract</code>. Also, I added a block adding the <code>is_author</code> checkbox (line 10). This field is only rendered when <code>signed_in?</code> is true (line 9). Again, I decided a simple <code>if</code> is more efficient than making it overly complex with view inheritance and a truely polymorphic view component. Know your tools, use them in moderation.</p>\n\n<p>After moving this view the controllers need to be updated. First, I add a new method <code>render_form</code> to <code>ThingsController</code>.</p>\n\n\n;;;\n\n<p>I use the <code>concept</code> method to render the <code>Thing::Cell::Form</code> view model, something we still have to create (line 5-6). The cell's model is the operation object (line 5). Hereby, I clearly define a visible dependency.</p>\n\n<p>The controller normally seeks to render a template file. Since we've sorted that using a cell, we need to use <code>render text:</code> to prevent the controller from being to passionate (line 5). As this render instruction will per default only display the HTML fragment of the cell, we need to pass <code>layout: true</code> to that call to embedd the cell nicely.</p>\n\n<p>We can now use this method in all actions that are supposed to render the thing form. Here's how <code>ThingsController#new</code> now looks.</p>\n\n\n;;;\n\n<p>Instead of the <code>render</code> statement you can now find the call to <code>render_form</code>. This almost completely bypasses the <code>ActionController</code> rendering stack and uses a cell for the content markup, instead.</p>\n\n<p>I changed <code>create</code>, <code>update</code> and <code>edit</code> accordingly, please refer to the repository here.</p>\n\n<p>Theoretically, the entire controller view is now handled by the new cell. The problem is: we still need to write that cell class. It goes to <code>app/concepts/thing/cell/form.rb</code>.</p>\n\n\n;;;\n\n<p>A brand-new cell <code>Thing::Cell::Form</code> maps the entire controller view to a class. Normally, the cell would look up its views in <code>app/concepts/thing/cell/views</code>. In order to share the view directory with <code>Thing::Cell</code>, I instruct it to change its view path using <code>inherit_views</code> (line 2). The cell will now pick views from <code>app/concepts/thing/views</code>.</p>\n\n<p>To satisfy Simpleform a few helpers need to be included manually (line 4-5). The main <code>show</code> method renders the <code>form.haml</code> view we just wrote (line 7-9).</p>\n\n<p>Looking back into the <code>form.haml</code> view, you will see a couple of method calls that are undefined, yet. For example, <code>signed_in?</code> needs to be implemented. Let's write the rest of the cell.</p>\n\n\n;;;\n\n<p>As we pass in the operation instance into the cell, I declare <code>contract</code> as a property (line 2). This will allow using <code>contract</code> in the view and delegates the call to <code>model.contract</code>, grabbin the form object from the operation.</p>\n\n<p>Another method in the view is <code>css_class</code>. Only when <code>admin?</code> returns true, I add the CSS class <code>admin</code> to the form tag's classes (line 4-7).</p>\n\n<p>In both view and cell code I extensively use <code>signed_in?</code> and <code>admin?</code> to differentiate between different contexts. Those methods are defined on the cell and literally just direct the call to <code>model.policy</code> (line 9-11 and 13-15). Since <code>model</code> is pointing to the operation instance, there must be a <code>Operation#policy</code> method defined.</p>\n\n<p>This <code>policy</code> method does exist and returns the exact same policy object that we were using in our builder earlier (line 10 and 14).</p>\n\n<p>Policies in Trailblazer are supposed to embrace all authentication-relevant code in a small-scoped object. They are also meant to be passed around, from the top-level operation down to the rendering cell or representer. By giving operation users access to it, we're allowing policy-based decisions outside of the operation object while holding to the same rule-set that was used throughout the process.</p>\n\n<hr>\n\n<p>Without being logged in, you will see the old, tedious form on <code>/things/new</code> that only gives you title, description and three author fields. Signed-in, you will observe an additional <u><q>I'm an author!</q></u> checkbox. As an admin, the whole form will be unreadable because of its bright orange background along with the same fields the signed-in user sees.</p>\n\n<p>For different user contexts, we have three different semantics now. While this is pretty awesome, we can't go nuts just now. We should write functional tests verifying the different renderings and processings from the integrated request perspective.</p>\n\n\\n\n\n<p>Even though we replaced the entire controller view with a cell, there's no need to write an isolated cell test. This global cell I will test on the functional level in integration tests.</p>\n\n<p>We used to keep integration tests in one big <code>test/integration/thing_test.rb</code>. I split them up into separate assets to make it easier to navigate.</p>\n\n<p>The <code>test/integration/thing/create_test.rb</code>. This is where we have test blocks for every function. Let's revisit this file. I am not going to explain every test as they have been covered in earlier chapters but will focus on new assertions.</p>\n\n<p>I put the testing of functions like <code>new</code> or <code>create</code> into <code>describe</code> blocks. Within those blocks, <code>it</code> blocks will embrace assertions for one user type, resulting in a very clear test layout.</p>\n\n\n;;;\n\n<p>The first to test is the <code>new</code> form page (line 2) in a <code>describe</code> section. We have discussed this before. However, I extracted several assertions into a method <code>assert_new_form</code> so we can reuse it for signed-in and admin user tests (line 6). Additionally, I make sure the form does not contain the <u><q>I'm the author!</q></u> checkbox (line 7). Also, the <code>admin</code> CSS class must not be set in this form as we are displaying for an anonymous, not signed-in user (line 8).</p>\n\n<p>The <code>assert_new_form</code> method I put directly into the test class. It contains assertions from the earlier test and don't need to be discussed, again.</p>\n\n\n;;;\n\n<p>We basically mimic a quick browser test using our smoke test and make sure the form to create things works. Now, the same for a signed-in user.</p>\n\n\n;;;\n\n<p>This is almost identical to the anonymous test except for two things. I sign in using the familiar <code>sign_in!</code> method (line 4). Since we're logged in, I make sure the checkbox is visible (line 7).</p>\n\n<p>Another <code>it</code> block will test the admin form in a similar way.</p>\n\n<h3>Lifecycle Smoke Test</h3>\n\n<p>Of course, testing the form rendering, only, is not enough. Next challenge is to test the creation lifecycle of things.</p>\n\n<p>Say you were testing this manually. You'd click through the form with valid and invalid data, correct it, resubmit, check the box, and so on. Eventually, you would sign in as a user, do the same again, and then again as an admin. Tedious, but you can make sure all contexts work.</p>\n\n<p>We do just this with a lifecycle smoke test. Just imagine you transcribe your manual click test to a Capybara test. Again, the <code>describe</code> block embraces the whole lifecycle test whereas <code>it</code> blocks cover different user roles.</p>\n\n\n;;;\n\n<p>As an anonymous user, I try to create an invalid thing, assert the rendering of an invalid form, and so on. We already tested this. However, I added one more test where I make sure the <u><q>Edit</q></u> link is not rendered for a random user (line 8). Remember, this is only done for authors from now on.</p>\n\n<p>Now, a bit more complex for a signed in user.</p>\n\n\n;;;\n\n<p>Our <code>sign_in!</code> helper makes me a valid, logged-in user on the HTTP level (line 4). I then test the submission of incorrect data, then correct data (line 8-12). To go completely nuts, I check the new checkbox (line 13). This will implicitly make sure this box is actually there, so I don't need to write another CSS test for that.</p>\n\n<p>I submit the form and verify that the signed-in user is now the author (line 17). In another implicit test, I click the <u><q>Edit</q></u> link. This would, again, raise an exception if that link wasn't there and is the perfect way to make sure the cell renders the correct links following to the policy object's dictate.</p>\n\n<p>The admin click path test is similar and can be admired in the repository.</p>\n\n<p>We implemented some new, refined operations for different user contexts and tested those in operation unit tests. The wiring into the UI is thorougly asserted using our smoke tests. Now that we know that creating of things works for all three user types, we can move on to editing, updating and deleting things with policies.</p>\n\n\\n\n\n<p>The <code>Thing::Update</code> operation we implemented over a few chapters sits in <code>app/concepts/thing/update.rb</code>. So far, this is only one class inheriting from <code>Create</code> that has a slightly changed contract along with some changed post-processing logic allowing to delete authors from a thing, and so on.</p>\n\n<p>Analoguely to the <code>Create</code> structure, I will now introduce <code>Update::SignedIn</code> and <code>Update::Admin</code> to embrace the three different contexts we have.</p>\n\n<p>Here's the new class header for the basic update operation that applies to not signed-in users.</p>\n\n\n;;;\n\n<p>Inheriting from <code>Create</code> will copy contract, policy, representers and callback objects to the new class.</p>\n\n<p>Builders in Trailblazer are not inherited, though. Manually, I have to reference create's builder block using <code>builder_class</code> (line 3). The main thought behind that is in most cases when using operation inheritance, you do not want to replicate builders in subclasses as the building should only happen once.</p>\n\n<p>The <code>CRUD</code> module in this operation is supposed to find the correct model for us, which is why I set <code>:update</code> as the action. We've discussed that in earlier chapters (line 4).</p>\n\n<p>To make <code>Update</code> use the correct policy, I configure <code>update?</code> as the new rule that is evaluated when the operation is run (line 5). Here's the new rule in <code>app/concepts/thing/policy.rb</code>.</p>\n\n\n;;;\n\n<p>In our policy class, I map <code>update?</code> to <code>edit?</code> for consistency as I like to make updating operations use the <code>update?</code> rule, whereas in views, the <code>edit?</code> rule feels more intuitive (line 2-4). They are identical, though.</p>\n\n<p>The <code>edit?</code> rule is valid if, and only if, there is a current user being passed into the operation and if that particular user is either an admin or is an author of the <code>Thing</code> we're trying to update (line 6-8).</p>\n\n<h3>Policy and Models</h3>\n\n<p>It is important that we encapsulate this kind of logic in a policy object, and it is totally fine to use model-specific code here. The policy is exactly the place for decisions about environments identified by different user types in combination with decisions about model state.</p>\n\n<p>Going further, the code in the policy object is not to be replicated anywhere else. If you need rule-based decision code, you have to use policy objects in Trailblazer. This is why the operation makes it easy to access its policy object using the <code>policy</code> method. We've seen one example already where that is being used outside of the operation: in the cell we built in the last section.</p>\n\n<p>That being said and implemented, the <code>Update</code> action will now raise a policy breach whenever it is run with a not signed-in, anonymous user. We will test that shortly.</p>\n\n\\n\n\n<p>To have a consistent structure of operations, we want to introduce <code>Update::SignedIn</code> and <code>Update::Admin</code> now. The following snippet shows the code for the operation handling the signed-in case in <code>app/concepts/thing/update.rb</code>.</p>\n\n\n;;;\n\n<p>I simply moved the original class code from <code>Update</code> in the earlier chapters into the <code>SignedIn</code> class. To illustrate that I added some of that code to the above snippet (line 4-7). In other words: The old <code>Update</code> is now <code>Update::SignedIn</code>.</p>\n\n<p><code>SignedIn</code> inherits from <code>Update</code> exactly as we did it with <code>Create</code> and its subclasses before. This inherits the contract and all other parts. The contract I added makes the name field read-only and adds the <u><q>Remove!</q></u> author function. We discussed all that in earlier chapters.</p>\n\n<p>However, the crucial change here is, and of course you've noticed that already: the <code>SignedIn</code> operation does not include the <code>Thing::SignedIn</code> module whichs adds the <u><q>I'm the author!</q></u> field and its associated logic to the. Why do I skip this for this operation?</p>\n\n<p>Well, the answer is quite simple. This particular operation class only handles signed-in users. Per policy, signed-in users can only edit things they authored - there simply is no need to have this checkbox in this context, so I skip including this module.</p>\n\n<p>This is a helpful example of how operation modules let you compose operations for different contexts. In this case, the <code>Update::SignedIn</code> simply doesn't need this function, it's the other way round: if we had this field, we would allow users to add them multiple times and we would have to throw in additional logic to protect them from doing so. Instead, I simply do not include this module which will result in an operation that doesn't process the <code>is_author</code> field.</p>\n\n<p>It might be easier to discuss the opposite case now. The <code>Update::Admin</code> operation is only used for admin users. That means an admin user can edit any record, whether they are author or not, and hence the <code>is_author</code> checkbox does make sense in this context.</p>\n\n<p>This is why I include the module for the <code>Admin</code> operation.</p>\n\n\n;;;\n\n<p>By deriving it from <code>SignedIn</code> we inherit all configuration and code (line 1). As I do want the author checkbox, I include the <code>Thing::SignedIn</code> module that we wrote in the beginning of this chapter (line 2). This will simply add the new field to the contract and import the additional business methods.</p>\n\n<p>The last change is to make the <code>name</code> field writeable. While normal, signed-in users can't change the name of things, admins can. I simply override the original property without the <code>writeable</code> option (line 5).</p>\n\n<p>Ok, this was a lot of inheritance and composition. What do we actually have? Three operations that do slightly different things.</p>\n\n<ol>\n<li>\n<code>Thing::Update</code> was only introduced for consistency. This operation inherits all code from <code>Create</code>. The builder is copied, too. It keeps the policy configuration and the CRUD-specific setting. <code>Update</code> can be called but will always bail out with a policy exception making it a virtual operation with declarative value, only.</li>\n<li>\n<code>Thing::Update::SignedIn</code> inherits from the latter, adds contract configuration and code specific to signed-in users which allows them to edit the description, and add or delete authors, only.</li>\n<li>\n<code>Thing::Update::Admin</code> inherits all of that, adds the <u><q>I'm the author!</q></u> checkbox and its process code by including <code>Thing::SignedIn</code>, and makes the title field writeable.</li>\n</ol>\n\n<p>As the root operation <code>Update</code> contains the builder configuration, controllers can remain as they are. The correct subclass will be instantiated internally in the operation.</p>\n\n<h3>Contract-specific Views</h3>\n\n<p>In the create and update form, we no longer can ask the policy whether or not to display the <code>is_author</code> checkbox. While we used to find that out by asking <code>policy.signed_in?</code> this doesn't apply to our requirements anymore. Even when signed in, this field should not be shown in the cases we discussed.</p>\n\n<p>It is best to make the view template not know about internals, anyway, so I change <code>form.haml</code>.</p>\n\n\n;;;\n\n<p>The query method is now <code>has_author_field?</code> and <q>verbally</q> decouples the view from the internal implementation (line 3). This method needs to be implemented in <code>Thing::Cell::Form</code> now.</p>\n\n\n;;;\n\n<p>And now, listen up. We've done this before, but what I use here does highly couple the view to the contract. I use <code>options_for</code> on the contract object to find out whether the operation's contract does have a <code>is_author</code> field (line 3). If so, the cell will render the visual counterpart.</p>\n\n<p>Relying on contract internals can be dangerous and might lead to unexpected results. In my case, I find this totally fine, though. I know that the operation's contract will reflect the policy settings, and I am aware that I am passing an operation instance into the cell. All I do now is using part of the public APIs of operation and contract and combining it with knowledge about the operation's contract semantics.</p>\n\n<p>To simplify that, you could expose a reader <code>has_author_field?</code> directly on the operation, which would make the operation part of the presentation. Or you could introduce a context object that reflects those settings. As Trailblazer is still quite young, both solutions are subject to experimenting and the emerge of best practices.</p>\n\n<p>You may now sign in as different users, and you will see: the form will only show the <code>is_author</code> field for admins. Nice work. Now, tests!</p>\n\n\\n\n\n<p>Luckily, we wrote a bunch of tests for <code>Update</code> when we implemented it back then, without the concepts of user roles, though. I left those tests as they are.</p>\n\n<p>In the top, I define some factories for different user types.</p>\n\n\n;;;\n\n<p>Using the <code>User::Create</code> operation several user roles are set up (line 2-4) which will come in handy in the tests.</p>\n\n<p>Again, I structure the test file <code>test/concepts/thing/update_test.rb</code> with <code>describe</code> blocks for the different user roles. I start with anonymous.</p>\n\n\n;;;\n\n<p>The first <code>let</code> defines a thing with an author (line 3-4). I run the <code>Update</code> operation without passing in a <code>:current_user</code>, though (line 8-10). As the operation's policy will detect that breach I catch and assert that using <code>assert_raises</code> (line 7 and 11).</p>\n\n<p>If I wanted, I could add more tests where the thing doesn't have authors, and so on, but I trust my super simple policy object and assume this is enough to verify the security works for anonymous users.</p>\n\n<p>For signed-in users, I write more tests as the policy is a bit more complex here. I will omit some of them as they are conceptually identical: Test if the operation raises a <code>NotAuthorizedError</code> when run with the incorrect signed-in user.</p>\n\n<p>I define a <code>thing</code> factory as I reuse this particular combination several times.</p>\n\n\n;;;\n\n<p>This is the same factory we used for the anonymous user. However, I still copy it to the new <code>describe</code> block (line 2-3). Every block embraces a separate test environment, and I find it simpler to just copy factories and then later, when you change one, you don't break the other blocks, instead of trying to be super-DRY and then run into problems and having to figure out factory dependencies.</p>\n\n<p>Here's a test for a valid processing the <code>Update</code> operation with a signed-in user.</p>\n\n\n;;;\n\n<p>In the <code>Update</code> call, I use <code>thing.id</code> which will make sure the actual <code>Thing</code> row gets created before getting updated (line 3). I then pass in the current user which is, according to our factory, also the author of this model (line 5). Being lazy, I test two more things in this test case: I pass in <code>:is_author</code> and <code>:name</code>, too (line 4). In a real project I would probably write separate test cases illustrating this.</p>\n\n<p>For the assertion part I test that all that was changed was the description field, all other arguments must be ignored by the operation (line 9-11).</p>\n\n<p>Since the admin tests are very similar, I will save this room for more interesting things.</p>\n\n<h3>Testing Side-Effects</h3>\n\n<p>We've tested many things in few, concise and intuitive test cases. We know the builders work. However, we didn't write explicit builder tests which would equal to testing private internals. Instead, we verified this works by testing the implicit side-effects which will allow us refactoring more easily.</p>\n\n<p>By injecting unsolicited parameters in combination with different user roles, we can make sure the correct operation is instantiated leveraging the correct contract.</p>\n\n<p>The nice thing is: we also tested the proper working of our operations at the same time. This saves us from writing complicated unit tests while exposing knowledge about the operation's architecture.</p>\n\n<p>As for the smoke tests I will limit myself to pure rendering assertions to make sure forms get rendered the way the current user should see it.</p>\n\n<p>The tests for to edit form rendering go into <code>test/integration/thing/update_test.rb</code>. In the first case, the policy breach is tested where an anonymous user tries to access an edit form.</p>\n\n\n;;;\n\n<p>In good Trailblazer manner one <code>describe</code> block per function (line 2-8). Similar to the create tests I have a <code>let (:thing)</code> factory defined in the test which you can look up in the repository. I then simply visit this thing's edit path (line 5). Since we're not signed in, I'm redirected to the root page (line 6). I will speak about this redirect after the tests are green.</p>\n\n<p>Analoguely, I test this case for the signed-in author of this particular thing.</p>\n\n\n;;;\n\n<p>Sign-in and browsing to the form is now something we've discussed sufficiently (line 4-5). I make sure the orange background is not present by asserting the absence of the <code>.admin</code> CSS class (line 6). Then I test the form is present, the title field is readonly, and other tests that I extracted into <code>assert_edit_form</code> the way we've done it for create. We went through all these tests earlier.</p>\n\n<p>Likewise, the admin <code>it</code> block bores me and doesn't need to be printed here as it mostly identical to the above test. One thing worth mentioning is that I explicitly test that the title field now is readonly with the following assertion.</p>\n\n\n;;;\n\n<p>This is a weak test, but so far, I haven't found out how to find an element and then make sure it does <u>not</u> have a certain CSS class. Anyway, this is also covered in the lifecycle smoke tests that are the last thing to do for this section.</p>\n\n<p>Instead of repeating the lifecycle again in a different test file, I put additional tests into <code>test/integration/thing/create_test.rb</code>.</p>\n\n<p>This snippet shows the extended click path test of a signed in user working on a <code>Thing</code>.</p>\n\n\n;;;\n\n<p>This goes into the original <code>it</code> block that represents the signed-in lifecycle. After we arrive on the thing's show page, I click the <u><q>Edit</q></u> link and assure the edit form is there (line 6-8). Filling out the description field and submitting the form represents the new part of the test (line 9-10). After the submission we should be back on show page of the thing (line 11). Given our logic works, the description should now be updated (line 12).</p>\n\n<p>A similar test for admin is in the same <code>describe</code> block.</p>\n\n<p>Our entire logic and rendering is now tested with all three possible user roles. Time to celebrate! But wait, when a policy exception is raised, how does that redirect to the root page? This code sits in <code>ApplicationController</code> and, again, is stolen from Pundit.</p>\n\n\n;;;\n\n<p>The <code>rescue_from</code> method allows to configure a declarative handler if a <code>NotAuthorizedError</code> is encountered (line 2). The <code>user_not_authorized</code> method to handle this is purely HTTP-related and hence not encapsulated in an operation. It redirects to the root page and notifies the user with a flash message (line 4-7).</p>\n\n\\n\n\n<p>After having implemented all those nifty features to add and edit things the database keeps growing and growing with test entries. As I am a minimalist when it comes to technical experiences my 4-year old laptop keeps getting slower with every minute. We need a delete function to relieve my jurassic hardware!</p>\n\n<p>This almost is a no-brainer. <code>Thing::Delete</code> goes into <code>app/concepts/thing/delete.rb</code>.</p>\n\n\n;;;\n\n<p>And here, I am breaking my own conventions. Even though we introduced this best practice of having one class per function and user role, our delete will do the very same for signed-in and admin, and it will simply raise a policy exception for anonymous ones as they can't delete anything.</p>\n\n<p>Note that I did <u>not</u> include the <code>Resolver</code> here as we don't have a builder block.</p>\n\n<p>It would add a lot of classes, builder code and indirection for the sake of sticking to the convention. This is not necessary here, and you will soon see why.</p>\n\n<p>I do inherit from the <code>Operation</code> class and not <code>Create</code> which is why I need to include <code>CRUD</code> andredefine the <code>model</code> configuration (line 1-3). Again, inheriting from one of the other CRUD classes would introduce a lot of unnecessary assets. I prefer to have a clean class for simple things.</p>\n\n<p>The policy rule is <code>delete?</code> and will be the next thing to implement (line 4).</p>\n\n\n;;;\n\n<p>That was easy. I simply map the <code>delete?</code> rule to <code>edit?</code>, which we defined earlier. To refresh your memory that's already stuffed with polymorphic concepts, contract fields and what not: the <code>edit?</code> rule checks if the user is an admin, and also allows signed-in users to delete if they are author of the thing model. And this policy is exactly what I want for delete, too.</p>\n\n<p>Here is the <code>process</code> part of <code>Thing::Delete</code>, and after that we will learn how that all plays together and why we don't need a builder here.</p>\n\n\n;;;\n\n<p>The main task of this operation is to delete the model, or, in ActiveRecord speak: destroy it (line 4). As post-processing logic, I add dispatches to <code>delete_images!</code> and <code>expire_cache!</code> (line 5-6).</p>\n\n<p>As you have guessed already, <code>delete_images!</code> will physically remove the uploaded files.</p>\n\n\n;;;\n\n<p>I reuse the handy <code>ImageProcessor</code> class, pass in the <code>thing</code> instance's <code>image_meta_data</code> hash and use Paperdragon's <code>image!</code> processor which allows me to unlink all attached files with the <code>delete!</code> method (line 2)<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n\n;;;\n\n<p>The <code>expire_cache!</code> method is imported from the module we already built (line 2).</p>\n\n<h3>Unit Test: Delete</h3>\n\n<p>It's probably best to discuss the overall function of <code>Delete</code> while we go through some unit tests in <code>test/concepts/thing/delete_test.rb</code></p>\n\n\n;;;\n\n<p>I define several factory methods of user types we're gonna need throughout the test (line 2-3).</p>\n\n<p>In this test file, I structure by thing states where the first block is to test against a thing without any authors. I wouldn't add this test in a real app, as our policy is thoroughly tested already but it is great to demonstrate the operation policy.</p>\n\n\n;;;\n\n<p>In the first test, I run the <code>Delete</code> operation with an existing thing id (line 6). I omit passing in a user here, which makes this an anonymous context. Given our operation policy <code>delete?</code> works, this should raise an exception and not run the operation (line 5-7).</p>\n\n<p>I do the same for a signed-in user and for admin. The latter will work, because admins are allowed to delete just anything. The signed-in case will raise an exception, too, as the user is not an author.</p>\n\n<p>The following test case block is for a thing with an author. Most of the test cases verify that only authors and admin can delete things.</p>\n\n<p>Here's how I test that the images of a thing actually get deleted, too.</p>\n\n\n;;;\n\n<p>The test setup is a thing with the current user being author, and it comes with an uploaded image, too (line 3-6). After calling invoking the delete operation, I assert the model actually got destroyed (line 8-9).</p>\n\n<p>Using the <code>Attachment</code> class manually, I make sure the files were physically unlinked by calling the <code>exists?</code> method (line 10).</p>\n\n<h3>Binary Operation Context</h3>\n\n<p>Why didn't we need a builder in this operation? Think about what the operation actually does. We have a simple, binary setup here: the operation either shouldn't be run at all, or it will do the exact same for any context. The operation doesn't care if it's an admin or an author deleting, it will bust the model along with its assets.</p>\n\n<p>The only problem is to figure out whether or not to run, and this is exactly what the operation's policy does! Since the policy is the first stop when invoking an operation, we can authorize the call or raise a policy violation before anything else is run.</p>\n\n<p>To delete things from the web UI I will insert the <u><q>Delete</q></u> link right after the <u><q>Edit</q></u> link on the thing's show page in <code>app/views/things/show.html.haml</code>.</p>\n\n\n;;;\n\n<p>The link for deletion is completely analogue to the edit one, except for instructing Rails to fake a <code>DELETE</code> request (line 5). This will route the click to <code>ThingsController#destroy</code> without having to add routes. Note that I reuse the <code>delete?</code> rule on the policy object to find out if we should render this link (line 6).</p>\n\n<p>I feel its almost unnecessary to discuss the <code>destroy</code> action in the controller, but here is it anyway.</p>\n\n\n;;;\n\n<p>If the <code>Delete</code> operation is run successfully, a flash message will inform the user and they are redirected to the homepage (line 3-6).</p>\n\n<p>Tests for the wiring all go into the lifecycle tests in <code>test/integrartion/thing/create_test.rb</code>. In the anonymous block I make sure the <u><q>Delete</q></u> link is not rendered, right after I tested the same for editing.</p>\n\n\n;;;\n\n<p>By asserting the delete link is absent, I know the policy decider in the view works (line 7).</p>\n\n<p>I also test, for both signed-in and admin, if I can click the delete link and if that redirects me. The extended admin case looks as follows.</p>\n\n\n;;;\n\n<p>The last two lines implement just that. I click the link and hope I get redirected (line 6-7).</p>\n\n<p>Our application now allows saving, with is another reason to throw another party! We tested all this new behavior and can be sure it works.</p>\n\n\\n\n\n<p>However, when writing the example app and playing with ideas, I benefited a lot from one Tyrant feature. The ability to impersonate other users. In other words, when being logged-in as admin, you can view pages as if you were another user.</p>\n\n<p>This is the last feature for this chapter and it will greatly help you when experimenting with all the learnings about polymorphic operations and policies as it makes it super-simple to simulate other users browsing the app.</p>\n\n<p>To activate impersonation all I have to do is change some lines in <code>ApplicationController</code>.</p>\n\n\n;;;\n\n<p>I replaced the call to <code>Tyrant::Session::Setup</code> with <code>Impersonate</code> (line 2). This does exactly what the old call does, with the exception if the key <code>:as</code> exists in the <code>params</code> hash.</p>\n\n<p>Given we were browing to the URL <code>/things/new?as=jimmy@trb.org</code> Tyrant will now find the new user by its email and replace <code>params[:current_user]</code> with the found user. After that, a new key <code>params[:real_user]</code> is set to the original user.</p>\n\n<p>That is all that happens. When passing params to other operations now, they will see the new <code>:current_user</code> value and run the respective code for that role. It's a bit as when you unit-test your operations and pass in different users.</p>\n\n<p>The important thing here is: Tyrant doesn't even bother to change any global variables. In Trailblazer, there are no global variables. Operations, view models, and representers will always receive an explicit <code>current_user</code> object or a policy instance that was created before, again, in an operation. There is no need to magically reset globals after the request is run, the way it is done in other authentication frameworks. We simply change the params hash locally.</p>\n\n<p>You can test this now and you will see that you can view pages as any kind of user, even if you're not an admin. That's why we should throw in our own <code>Impersonate</code> implementation in  <code>app/concepts/session/impersonate.rb</code>.</p>\n\n\n;;;\n\n<p>This new operation simply inherits all behavior from Tyrant (line 1). By adding a policy that uses the familiar rule <code>admin?</code> I make sure no-one but admin can run this (line 2-3). In the Tyrant implementation, the original <code>Setup</code> is run before the policy is evaluated, allowing everyone to get authenticated, but not to impersonate.</p>\n\n<p>To activate it, we have to change the application controller.</p>\n\n\n;;;\n\n<p>I replaced the operation dispatch with our own implementation (line 2).</p>\n\n<p>When signed-in as a non-admin now, you will be kicked to the homepage when trying to impersonate.</p>\n\n<p>The way Tyrant operations can be customized just by subclassing and extending or overriding parts using pure Ruby is what I love about the Trailblazer architecture. Imagine you had to change behavior in Devise - this becomes a nightmare once you need to move beyond the declarative interface due to the lack of clean encapsulation of the functions and its hardcore-coupling to Rails in combination with global variables.</p>\n\n<h3>NavigationCell and Impersonate</h3>\n\n<p>As promised in the beginning of this chapter, we will now add some more logic to the <code>Navigation::Cell</code> to make it render differently when you are actually using this feature. Being impersonating someone else, the tooltip on a star icon next to the welcome message should say <u><q>You really are: admin@trb.org</q></u>.</p>\n\n<p>To do so, we need to extend the arguments we pass into the navigation cell in <code>app/views/layouts/application.html.haml</code>.</p>\n\n\n;;;\n\n<p>The real user is now passed into the cell, too (line 3). As the session setup will always populate the <code>:real_user</code> I do not have to worry about anything here.</p>\n\n<p>In the cell code, a little change will bring a cool, very helpful feature.</p>\n\n\n;;;\n\n<p>I add the <code>real_user</code> property so we have convenient access to it in the cell (line 4).</p>\n\n<p>Then, I extend the <code>welcome_signed_in</code> method that renders the hello message.</p>\n\n\n;;;\n\n<p>As you can see, I simply added a call to <code>impersonate_icon</code> that will render the necessary markup (line 2).</p>\n\n<p>The implementation is basic cells logic.</p>\n\n\n;;;\n\n<p>The method won't return anything unless <code>real_user</code> is present. So, in case this is nil, nothing additional is rendered (line 2). I then manually compose an HTML string where I use a Foundation icon with a tooltip revealing the real users email address (line 3-4).</p>\n\n<h3>Testing Impersonation</h3>\n\n<p>I know exactly that you already tried this feature right away, without any tests. This is alright, but let's finish this chapter with a quick functional test in <code>test/integration/session/impersonate_test.rb</code></p>\n\n\n;;;\n\n<p>As always, a test user is defined in the test header (line 2). To create it explicitly, I use <code>before</code> so it is around in every test case (line 3). When trying to use the impersonate feature as an anonymous user, you won't be lucky. The system will still ask you to log in (line 6-7).</p>\n\n<p>A similar test I write for a signed-in user.</p>\n\n<p>As a last test case I login as an admin.</p>\n\n\n;;;\n\n<p>After signing in, and using the <code>as</code> key, the system must welcome us as a different person (line 2-4).</p>\n\n<hr>\n\n<p>And that's it, we have a closed system now that only exposes a subset of its functionality to anonymous users. Implementation of contexts is not done with deciders spreading all over the layers of the framework, but cleanly separated in different classes.</p>\n\n<p>By using inheritance between classes that implement the same function, but different user roles, we can easily share contracts and policy objects without the dreaded <q>black-hole inheritance</q> that you were probably thinking of when you started reading this chapter.</p>\n\n<p>And if you don't like inheritance, you are free to use Trailblazer's compositional features where you can copy and inherit parts of other operations, as we did in several places in this chapter.</p>\n\n<p>After operations have been run, the presentation layer can leverage policy objects to reflect restrictions visually, again, without any redundancy as the policy object is passed between the layers.</p>\n\n<p>The operation users don't even know there is different subclasses implementing the requirements. By applying builders to the top class, the polymorphic dispatch happens internally. This was also beneficial in our tests. Remember, we didn't test any internals, only the side-effects on the application state.</p>\n\n<p>This is applied object-orientation in a real system, but without the pain that Rails makes you think there is.</p>\n\n<p>In the next, two final chapters we will learn how to build a document-based HTTP API on top of what we've developed. After reading that, you're more than ready to jump on your own projects and apply Trailblazer like a pro!</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>In a future version of Cells there will be <u>view block inheritance</u> which allows overriding parts of the original view with template blocks being defined in the overriding cell itself. The result is a much simpler implementation without the problem of <q>too many files</q>. I will speak about that in the <u>Cells Field Guide</u>. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>I am reusing the <code>ImageProcessor</code> that I extracted from the <code>Thing::Contract</code> in a <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-08-separate-uploader\">separate branch</a>. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>When writing modern applications, it often is not enough to provide a neat user interface that we can leverage by clicking buttons in a web browser. We've come to the conclusion that applications must expose more than one way for being operated.</p>\n\n<p>Letting machines, or real users, query and modify appliation state by pushing documents back and forth between endpoints, is a fantastic architectural approach which can be added to an existing system, or be used to physically separate an highly coupled, complex software.</p>\n\n<p>Adding API code on top of existing HTML-based user interface implementation gives you two options.</p>\n\n<p>One way would be to mix your new code into the old code. Most of the merging would happen in controllers, as they act as endpoints for HTTP. This would mean you have to render HTML and JSON in the same controller, and differentiate between the two formats.</p>\n\n<p>Rails tried to implement this using responders and leveraging a clumsy format DSL in controllers. Both are extremely unpopular - an indicator that it's not a good idea to mix concerns here.</p>\n\n<p>The other way is pretty much what we've done so far. For different environments, introduce different objects to handle. In other words: leave your HTML code where it is and add additional <q>API</q> controllers to process document requests.</p>\n\n<p>And as you already have guessed, my dear reader, we're gonna choose the second way. Now that we have different operation classes to handle all the various environments, why would we intermingle user interface and API code?</p>\n\n<p>Code for the following two chapters can be found <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-11\">in our repository</a>.</p>\n\n\\n\n\n<p>After having played a lot with different file layouts, I decided it's best to organize API-specific code in a completely separate directory while still following the Trailblazer convention.</p>\n\n<p>I think about the API code as a completely different component in our application, a different component that could even be a separate application.</p>\n\n<p>The dependencies are one-directional, where the API code will use the old code from the last chapters, but the operations and contracts and whatnot we've written so far won't be changed, they won't even know there's API code depending on it.</p>\n\n\n;;;\n\n<p>So it's best to put that API code into its own directory.</p>\n\n<p>The way we organize code for the API is straight-forward. We will introduce a new super concept <code>app/concepts/api</code>, add another level of separation, the folder <code>v1</code> and then save our operations and representers in this directory.</p>\n\n<p>I introduce the <code>v1</code> directory and namespace to make it easier to push out new versions of our API. In this chapter, fortunately, we're only going to write one version. Nevertheless, API code, which is a publicly used concept, should be organized by versions. This is not me speaking but the opinion of a bunch of very experienced API developers I've interviewed exlusively to provide you the lastest best practices in this read.</p>\n\n\\n\n\n<p>As a light-weight introduction to representers and Trailblazer, why not start with a simple render-only endpoint? Let's implement a controller action that sits on the route <code>/api/v1/comments/:id</code> and delegates the JSON serialization to a Trailblazer operation? Does that sound good?</p>\n\n<p>When writing API code, it can get quite hard to test your code. You could install the Postman extension and issue requests against your endpoints from it, and then check the headers and JSON bodies manually.</p>\n\n<p>But why do that? It's awkward, tedious and error-prone. What I usually do is I start with an integration test. And this is what we do right now.</p>\n\n<p>The API integration test I put into <code>test/api/v1/comments_test.rb</code>. In the file name, I am reflecting the URL which makes it very easy to find tests for endpoints.</p>\n\n\n;;;\n\n<p>In the comments integration test, I use <code>describe</code> blocks to structure the different endpoints, so I have test blocks for rendering, creating, updating, and so on, in line with our test layout for pure operations.</p>\n\n<p>First, I setup the application state by creating a thing and a comment. As always, operations help me to instantiate a realistic scenario, and I use both <code>Thing::Create</code> and <code>Comment::Create</code> with the well-known syntax (line 5-12).</p>\n\n<p>The actual test is pretty much self-explaining.</p>\n\n\n;;;\n\n<p>Calling <code>get</code> with a provided path will literally send a <code>GET</code> request to that endpoint. This happens without hitting the network, but there's no mock magic involved to fire that request.</p>\n\n<p>By including the comment's id, creation of the comment and the associated thing is assured (line 3).</p>\n\n<p>To verify the returned document, I use <code>last_response.body</code> and really just compare it to a string (line 5-10). The string is constructed by defining a hash and then transforming it to JSON by calling the global <code>to_json</code> method (line 6-9). I do this mainly for readability: it is nicer to see a physically formatted hash that replicates the structure of the JSON document, and then convert that into a string, instead of having to wade through a 3000-character, one-line, string.</p>\n\n<p>Please note that this is a full-blown integration test. However, it is based on <code>rack-test</code>, and not Rails' <code>ActionController::TestCase</code>. Rack-test is a very simple wrapper that fires real requests at a Rack app (which is our Rails application) and then provides the returned document and request headers.</p>\n\n<p>It really doesn't do anything else, whereas <code>ActionController::TestCase</code> is implemented with more than 600 lines of code that try to guess many things, sometimes convert hashes into JSON, sometimes not, and so on. I've had so many bad experiences with the latter test concept that I completely banned it from my test suites.</p>\n\n<p>Especially when it comes to testing consuming parts of our API you will see how trivial rack-test makes this task as it simply expects a document string as the request body that's being sent to the endpoint. Trying the same with Rails' built-in <code>TestCase</code> was a nightmare.</p>\n\n\\n\n\n<p>One thing you've probably noted is that the <code>_links</code> section in the document has a certain format. That's right! Instead of coming up with my own document syntax, I decided to use a well-defined existing one.</p>\n\n<p><a href=\"http://stateless.co/hal_specification.html\">HAL</a> does not only define how nested relation objects get render, i also has a format for embedding links into documents. This is usually something along the following.</p>\n\n\n;;;\n\n<p>The special <code>_links</code> key marks the hypermedia section, links are keyed by their <u>rel</u>, which indicates their semantic or meaning, followed by various attributes for that link. In this book, we're only using the <code>href</code> attribute which contains the actual <q>clickable</q> URL or path of the link.</p>\n\n<p>Also, what's the whole links thing about? Why am I putting links or URLs into that document? We'll discuss that more in a few minutes, but it is a unwritten law in the hypermedia community to always embedd the URL that exposes the document into the document itself. This is called a <u>self link</u>.</p>\n\n\\n\n\n<p>Now that we got a test in place, and we understand how and why the expected document looks the way it looks, how do we actually render that representation of the comment?</p>\n\n\n;;;\n\n<p>In Trailblazer, rendering happens via the operation. <u><q>Hey, that's too many concerns in one object, operation is a god class!</q></u> you might find yourself yelling at me, now. Hang on, I didn't say the rendering is implemented in the operation, I said rendering is orchestrated by the operation.</p>\n\n<p>The operation that embraces logic for that particular HTTP endpoint simply keeps references to all objects it needs to render a document and instructs those to do so.</p>\n\n<p>Let's go the other way round, ask yourself how would you manually implement the JSON serialization of a comment in Rails.</p>\n\n\n;;;\n\n<p>You'd go grab the particular model instance and throw it into a serializer.</p>\n\n<p>Now, let's convert that to Trailblazer. In order to do so, first, I add a <code>Show</code> operation in <code>app/concepts/api/v1/comment/operation.rb</code>.</p>\n\n\n;;;\n\n<p>By including <code>Model</code> and setting the <code>:find</code> action, the operation will take care of retrieving the correct model. If you wanted to, you could use this operation with your own serializer.</p>\n\n\n;;;\n\n<p>Here, the operation fetches the record and exposes it via <code>model</code> (line 1). The external serializer renders the document (line 2). The latter could be from any framework, Yaks, ActiveModel::Serializer, you name it. This is absolutely legit. If you don't want to benefit from Trailblazer's representation framework, feel free to manually render documents.</p>\n\n\\n\n\n<p>Anyway, this chapter wouldn't have so many pages if that was it. Trailblazer comes with a very thin binding to Representable<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup>, a gem that provides what we call <u>representers</u>. A representer is a document declaration that allows rendering and parsing documents following the document specs.</p>\n\n<p>Representers are usually classes with declarative definitions. Here's a quick example. Note that this code is absolutely not depending on Trailblazer.</p>\n\n\n;;;\n\n<p>Following the example from above, you could apply this representer to the operation's model.</p>\n\n\n;;;\n\n<p>Again, the operation provides the model (line 1). After the decorator has been instantiated with the model, I call <code>to_json</code>. This call will invoke the representer's rendering and traverse its internal properties to compile a JSON document. In our simple example, this will end up as one read on the model where the representer invokes <code>model.body</code> and places that into the document.</p>\n\n<h3>Using Representer</h3>\n\n<p>Trailblazer allows to integrate representers directly into an operation. This works by including the <code>Representer</code> module that adds two methods.</p>\n\n\n;;;\n\n<p>The existing <code>Show</code> operation gets extended with <code>Representer</code> (line 7). This allows me to define representers inline using the <code>representer</code> method. As this will simply create an anonymous <code>Roar::Decorator</code> class behind the scenes, I can use the exact same API in the block (line 8-10).</p>\n\n<p>We will soon learn that there's other ways to reference representers, but before talking about compositions, here's how you'd render this document.</p>\n\n\n;;;\n\n<p>In fact, the <code>Representer</code> module also imports a <code>to_json</code> instance method into the operation for your convenience. Don't panic, this does absolutely not break any responsibiliy scopes, but simply orchestrates the representer and model.</p>\n\n<p>Here's what happens inside the <code>to_json</code> method.</p>\n\n\n;;;\n\n<p>Now this is really convenient. The operation's <code>to_json</code> method does the decorating for you, as well as it dispatches the actual rendering. It grabs the representer class from the operation and instantiates the representer. The operation's <code>model</code> is being passed into the representer (line 4-5). The call to <code>to_json</code> will invoke the representer's rendering, just as we did it manually before (line 6).</p>\n\n<p>To sum that up: an operation can take care of the JSON rendering if you want that. All you need to do is include <code>Representer</code>, define a representer and call <code>to_json</code> on the operation instance.</p>\n\n\\n\n\n<p>We now understand how operation, model and representer play together to serialize a JSON document. How are we gonna hook this into our API endpoint?</p>\n\n<p>Well, in Rails, every journey starts with a route.</p>\n\n<p>Here's what I add to <code>config/routes.rb</code>.</p>\n\n\n;;;\n\n<p>I'm not a Rails routing expert, however, the new nested configuration will, among others, give us the route <code>/api/v1/comments/1</code> which leads to <code>API::V1::CommentsController</code> and its <code>show</code> action.</p>\n\n<p>The new controller sits in <code>app/controllers/api/v1/comments_controller</code>.</p>\n\n\n;;;\n\n<p>That is sufficient code to plug the operation with its representer to a controller and let it render JSON documents.</p>\n\n<p>Step by step, what will happen now? When requesting the URL <code>/api/v1/comments/1</code> the above controller's <code>show</code> method will be run. In that action, I invoke the <code>Comment::Show</code> operation manually and pass the <code>params</code> hash into it.</p>\n\n<p>Because of the way I arranged the namespace nesting, the <code>Comment::Show</code> here will be resolved to <code>API::V1::Comment::Show</code>, which is the operation with the representer we just wrote.</p>\n\n<p>The operation will run its <code>present</code> code, find the model from <code>params</code> and return itself, completely analogue to what we did manually earlier.</p>\n\n<p>Now, the tricky part. <code>render json:</code> thinks it is working with a model, and will invoke <code>to_json</code> on it. Anyway, the model here is the operation instance, but it still responds to <code>to_json</code> and returns the document which becomes the response body.</p>\n\n<p>And here goes our first Trailblazer API endpoint!</p>\n\n\\n\n\n<p>Instead of having to manually invoke the rendering in the controller, Trailblazer provides the <code>respond</code> controller method. Note that you have to have the <code>responders</code> gem installed.</p>\n\n\n;;;\n\n<p>Using the <code>respond</code> approach, the first steps are identical. The operation gets instantiated and invoked by passing in the controllers <code>params</code>. Then, the operation is passed to a responder. Here's what happens internally.</p>\n\n\n;;;\n\n<p>The <code>respond_with</code> part is a bit hard to understand. Note that it receives the operation instance as first argument. The internal responder will now figure out a few things and query the operations about its <code>persisted?</code> state, and so on. Based on these information, the responder not only invokes <code>to_json</code> on the operation, but also sets <code>Location:</code> headers and more in the request.</p>\n\n<p>In other words, the responder takes away quite some work to make that action comply with HTTP standards.</p>\n\n<p>To allow the operation to communicate with the responder, you need to include the <code>Responder</code> module.</p>\n\n\n;;;\n\n<p>The inclusion will import some readers like <code>persisted?</code> for the responder (line 5).</p>\n\n<p>Personally, I prefer the <code>respond</code> method as it unifies the way we invoke operations in API controllers and takes away the pain of returning the correct HTTP status code, content type, and other headers.</p>\n\n\\n\n\n<p>It might sound funny, but you now may run the test we wrote at the beginning of this chapter. And - it will break! That's because our representer and the expected document structure do not match. Before fixing this, I want to show two other ways how to specify representers.</p>\n\n<p>A representer and a contract have much in common. They use the same declarative API, and even the same internal schema library. This allows to quickly infer a representer from a contract without having to write it yourself. To use this feature, the inferring operation needs a contract defined.</p>\n\n<p>One way to provide a contract would be by inheritance.</p>\n\n\n;;;\n\n<p>Inheriting from <code>::Comment::Create</code>, the operation we implemented in earlier chapters, will copy its contract to the new <code>Show</code> operation. Since the <code>Representer</code> module is included, it will automatically provide an inferred representer as we do not provide one ourselves.</p>\n\n<p>When rendering this operation, the following document will be generated from the inferred representer.</p>\n\n\n;;;\n\n<p>As you can see by the included properties, the representer must have been roughly defined along the following lines.</p>\n\n\n;;;\n\n<p>And this is exactly the structure of the inherited contract from <code>Comment::Create</code>.</p>\n\n<p>Representer inferal is a nice way to quickly get a stub endpoint set up. Usually, I end up writing an explicit representer, even though I have some redundancy in it. Also, most forms are a subset of the properties desired in a representer. Inferring is mostly helpful in an API-only application where you have a contract defined that maps to your document, and from that let Trailblazer build a representer automatically<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n\\n\n\n<p>The third alternative, and this is the way we will go, is to keep representers in separate files and reference them from the operation. By maintaining external representers, we minimize coupling between the components and I simply find it easier to navigate since I instantly know where to look for representers.</p>\n\n<p>Per concept, I keep all representers in one file. As always, it is totally up to you whether or not you like one file per class, but as we will soon see, sometimes a representer is nothing but a few lines of code, so for me it's fine to group them in one physical file.</p>\n\n<p>For the <code>API::V1::Comment</code> concept, representers go into <code>app/concepts/api/v1/comment/representer.rb</code>. And, to finally get our test green, here's the content of that file.</p>\n\n\n;;;\n\n<p>The main asset here is the <code>Show</code> class, derived from <code>Roar::Decorator</code> (line 4). This is what happens behind the scenes when you use the <code>representer</code> block in your operation class. I namespace this representer in the <code>Representer</code> namespace the way we did it with contracts, too (line 3).</p>\n\n<p>The included <code>Roar::JSON::HAL</code> module imports basic JSON semantics, plus support for hypermedia (line 5). Apparently, we can add hypermedia links with the <code>link</code> class method. In this block, we can use Rails URL helpers to specify the <code>href</code> value of the rendered link. Where you'd normally pass the model's id into the path helper, we use <code>represented.id</code>, which will reference the actual <code>Comment</code> model's id that the representer decorates (line 9)<sup id=\"fnref3\"><a href=\"#fn3\" rel=\"footnote\">3</a></sup>.</p>\n\n<p>Now that we have the representer in place, all that's missing is reference that class in the operation.</p>\n\n\n;;;\n\n<p>Plugging the external representer into the <code>Show</code> operation is no more than passing the constant to <code>representer</code> (line 5). Note how I have to reference the constant <code>Representer::Show</code>, only. Ruby will look in the <code>API::V1::Comment</code> namespace automatically.</p>\n\n<p>Running the integration test will result in a nice, a bit too flashy, but motivating green output on the console. We've everything implemented to present a comment as a JSON document via HTTP.</p>\n\n\\n\n\n<p>Before we move on to the fun part of implementing document APIs, which is definitely the parsing, let's finish up the comment document. It should also show the comment author as a nested document fragment.</p>\n\n<p>I extend the first test case for this.</p>\n\n\n;;;\n\n<p>The comment document now contains the <code>user</code> as a nested fragment (line 10-13).\nThat user fragment itself has a <code>_links</code> property that points to the user's path (line 12). In HAL, nested objects can contain links, too, helping the client browsing to nested resources without having to guess the URL.</p>\n\n<p>We also have an <code>_embedded</code> key nesting the user in the document into a separate section (line 9-14). Another HAL semantic I've added to the document without telling you. HAL specifies a top-level object, which is the comment's properties, but it allows nested, associated objects. Those are listed under the <code>_embedded</code> key.</p>\n\n<p>Don't confuse that with associations. While in most cases, the embedded fragments represent models that are associated with the top level model, this could also be arbitrary data that might be needed on the client side.</p>\n\n<p>Anyway, our test now fails, 3 minutes after we fixed it eventually.</p>\n\n<p>The fix is simple and happens in <code>app/concepts/api/v1/comment/representer.rb</code>. Here is the updated code for the comment API representer.</p>\n\n\n;;;\n\n<p>Unmissingly, I've added the nested user property and its <code>email</code> property (line 5-8). The nested <code>link</code> renders the user link (line 7). Here, I use a different URL helper. In this context, <code>represented</code> will refer to the nested user model.</p>\n\n<p>We can configure the <code>HAL</code> mechanics to treat the nested user as an <q>embedded</q> property by adding <code>embedded: true</code> to the property declaration (line 5).</p>\n\n<p>To make this work, I had to change <code>include Roar::JSON::HAL</code> to <code>feature HAL</code> (line 2). Using the <code>feature</code> to include a module will automatically include this particular module into nested representers. That way, I can use <code>link</code> in the user representer, too.</p>\n\n<p>Since we use the <code>api_v1_user_path</code> helper, a resource has to be added to <code>config/routes.rb</code>.</p>\n\n\n;;;\n\n<p>Tests are green again after this change, and after cheering for a few seconds we can finally move on to something more exciting.</p>\n\n\\n\n\n<p>An interesting requirement would be to implement an index operation that lists things, as in <code>GET /api/v1/things</code>. That alone is a quite straight-forward task, let's spice it up by allowing different data sets. Those data sets will be instructed using query parameters like <code>things?sort=recent</code> and sort the things as specified.</p>\n\n<p>A test speaks more than a thousand words. What I do is I add another describe block to <code>test/api/v1/things_test.rb</code>.</p>\n\n\n;;;\n\n<p>I first setup 20 random things with names <q>Thing 1</q>, etc. Each thing has an author with a similarly structured email address (line 3-8).</p>\n\n\n;;;\n\n<p>This test case sends a <code>GET</code> request to the <code>/api/v1/things</code> route, but adds the <code>sorted=oldest</code> query parameter that we're going to process in the <code>Index</code> operation (line 4).</p>\n\n<p>The remaining test asserts in a very awkward way that correct items are embedded in the document (line 6-17). Also, note the <code>self</code> link that refers to this resource itself, includes the dynamic request parameter <code>sort</code>.</p>\n\n<p>To allow this new <code>GET</code> route, I add a few lines to <code>config/routes.rb</code>.</p>\n\n\n;;;\n\n<p>The <code>things</code> resource will now route requests to <code>/api/v1/things/</code> to the <code>index</code> action of the <code>API::V1::ThingsController</code>, which gets extended as follows.</p>\n\n\n;;;\n\n<p>Fairly simple, we just delegate the main work to <code>API::V1::Thing::Index</code>, which will be implemented in <code>app/concepts/api/v1/thing/operation.rb</code>.</p>\n\n\n;;;\n\n<p>A plain new operation class will implement the index logic (line 3). Including <code>Representer</code> and <code>Responder</code> allow to specify a representer and integrate <code>to_json</code> with the representer and model (line 4).</p>\n\n<p>Using <code>representer</code>, I reference the external <code>Index</code> representer that we still have to implement.</p>\n\n\\n\n\n<p>Since this is a collection operation, we can't use the <code>Model</code> module to help us finding the correct rows. We could, but it would be more pain than doing it manually.</p>\n\n<p>To find models with your own logic, you can simply override <code>Operation#model!</code> which is designed for just that.</p>\n\n<p>I access the methods <code>params</code>, which are the arguments being passed into the operation call, and find out what the <code>:sort</code> value looks like (line 7-10). Depending on the value, I dispatch to either the <code>oldest</code> or <code>latest</code> scope of the <code>Thing</code> model. While I could also introduce a query object or construct queries in the operation, I find ActiveRecord's scopes pretty handy.</p>\n\n<p>Note that I do need to address the model class using the root notation <code>::Thing</code>, otherwise Ruby will resolve this to <code>API::V1::Thing</code> which is a namespace and not a model.</p>\n\n<p>Also, in order to access the sorting parameters in the representer to render a proper <code>self</code> link, we need to pass in the parameters into the <code>to_json</code> call when invoking the representer instance. This is why I override <code>to_json</code> in the operation (line 12-17). I create a nested hash that looks like the following snippet.</p>\n\n\n;;;\n\n<p>This is Representable's API to inject dynamic options into render and parse calls. Any non-library options go into the <code>:user_options</code> value, and I pass the entire params under the same-named key. I access the operation's params using the instance variable <code>@params</code>.</p>\n\n<p>I then call <code>super(options)</code> to invoke the operation's original rendering with my own options (line 16). In pseudo code, the rendering invocation of the operation will resolve to the following snippet being executed.</p>\n\n\n;;;\n\n<p>As a next step, we need to implement the search logic  in the model class by adding the <code>oldest</code> scope. That happens in <code>app/models/thing.rb</code>.</p>\n\n\n;;;\n\n<p>This is just another scope on the model, and as ActiveRecord does a great job at that, it's not incorrect to put that into the model class (line 3).</p>\n\n<hr>\n\n<p>Quite important is to understand that <code>model!</code> is the place to combine dynamic request parameters with query logic. This is where pagination, scoping, sorting, and filtering happens. We will see more of that in the next example, again.</p>\n\n<p>To round up this implementation step, we need to implement the representer in <code>app/concepts/api/v1/thing/representer.rb</code>.</p>\n\n\n;;;\n\n<p>The <code>Index</code> representer is derived from a plain <code>Roar::Decorator</code>, but I include the <code>HAL</code> module to make it compliant to our desired media format (line 4-5).</p>\n\n<p>I then define a collection property <code>to_a</code>, that I alias to <code>:things</code>, mark it as an embedded fragment, and provide an explicit representer instead of using an inline representer (line 7). Don't you worry, we'll discuss this odd piece of code in a second.</p>\n\n<p>The last block of this representer defines the <code>self</code> link for the rendered document (line 9-14). Blocks for <code>link</code> can contain arbitrary code and receive an optional hash. This hash passed into every <code>link</code> block is the <code>:user_options</code> argument we gave into the top-level <code>to_json</code>.</p>\n\n<p>By using keyword arguments I let Ruby filter out the <code>params</code> value (line 9). I then create a hash <code>options</code> that I pass into the URL helper (line 10-13). In this hash, I add <code>:sort</code> so the URL helper will include our dynamic request option into the rendered document.</p>\n\n<p>It is pretty common in the Roar world to have more than just a call to a URL helper in a <code>link</code> block. What we do here could be nicely abstracted, but as always, this book shows the explicit way for a better understanding.</p>\n\n\\n\n\n<p>Let's talk a bit more about the representer property.</p>\n\n\n;;;\n\n<p>To understand what is going on here we need to take a step back and have a look at how we use the representer. The <code>Index</code> operation will fetch a collection of <code>Thing</code> models and pass this array to the representer.</p>\n\n<p>If you were to use the normal <code>Thing::Create</code> representer to render the collection, Representable would try to call property getters on the array.</p>\n\n\n;;;\n\n<p>It is quite obvious that a singular representer can't be applied to a collection as it will treat the array as the <q>model</q> itself, and this won't work.</p>\n\n<p>Representable comes with built-in support to generate a collection representer for you on-the-fly. However, this would literally render an array of things. The structure we require is bit more complicated as we want a real HAL document with exactly one embedded property, which is our collection of items.</p>\n\n\n;;;\n\n<p>According to my friend Mike Kelly, the creator of HAL, this is best practice for representing collections in HAL.</p>\n\n<p>Achieving this structure is relatively simple by using a <code>collection</code> property and mark it as <code>embedded: true</code>. So far, so good. Since we pass an array into the representer, Representable will now call <code>ary.things</code> to retrieve that collection. To avoid a <code>MethodMissing</code> exception, I simply call the property <code>:to_a</code> and alias it to <code>:things</code>.</p>\n\n<p>When rendering the document for an array of things, the representer will call <code>ary.to_a</code>, which will return the array itself, and then render it with the key <code>:things</code>. Exactly what we wanted.</p>\n\n<p>The actual items need a representer, too. While I could use an inline representer, I reference the existing one using <code>decorator: Create</code>. Using the <code>:decorator</code> option is another technique to compose representers without creating redundancy.</p>\n\n<p>Anyway, running the test suite will now pass, our sorted collection is serialized exactly the way we need it, and even contains dynamic parameters in the self link. Pretty cool.</p>\n\n\\n\n\n<p>It actually wasn't too hard to implement sorting, was it? Once you grasp that the operation is responsible for collecting, and it's the representer's job to serialize that object graph, the layering starts making sense.</p>\n\n<p>As a last requirement, I want to allow API users to skip rendering of specific fragments of the index document. As per now, that document contains things, which in turn are composed of author and comment fragments.</p>\n\n<p>Assuming that Gemgem gains a lot of traction, and many comments might be embedded per thing, it might be a good idea to allow turning off rendering for comments and/or authors.</p>\n\n<p>I will skip huge parts of the test code here as they are big chunks of JSON, and only some parts are relevant for understanding. Speaking of, here's the next test I put into <code>test/api/things_test.rb</code>.</p>\n\n\n;;;\n\n<p>I first create a massive fixture with several things from different authors (line 4-9). To some, I add comments so we can test the rendering (line 6-8).</p>\n\n\n;;;\n\n<p>Using <code>GET /api/v1/things?include=comments</code> I retrieve the document that must only contain the thing's attributes plus nested comments, and no author details (line 3).</p>\n\n<p>In a convoluted matching test I make sure that no author fragments and only comments are to be found in that document (line 5-18). Again, I spare you the details of the hashes here, as they're accessable in the repository.</p>\n\n<p>To make this example as brief as possible, I also left out including query parameters in the self link here (line 20).</p>\n\n<p>Representable allows to instruct inclusion and exclusion of properties. As an additional service, you can also nest this, and thus fine-tune the inclusion of fragments. For example, when rendering a thing, here's how you could include the nested comments' bodies, only, and exclude the weight and author.</p>\n\n\n;;;\n\n<p>A really handy mechanic to provide filtered documents for nested data structures.</p>\n\n<p>Implementing this feature doesn't touch the representer directly. Instead, we use the <code>:include</code> option of Representable that we just discussed. The filtering, from our perspective, takes place in the <code>Index</code> operation.</p>\n\n\n;;;\n\n<p>In the overridden <code>to_json</code> method, I add including options (line 13-14). The <code>options</code> hash will look like the following fragment in our test.</p>\n\n\n;;;\n\n<p>Since it's passed to the original <code>to_json</code> method, Representable will take care of filtering for us (line 17).</p>\n\n<h3>Representable's Internal API</h3>\n\n<p>A bit of manual work is necessary to include the instructed nested comments, and the original scalar values. Even though this code is a bit ugly, I decided it's a good chance to teach you some more about Representable's internal public API.</p>\n\n<p>To make the representer include the nested comments along with the scalar properties of the thing - which is <code>name</code>, only, in this example - we need to find out those scalars at runtime. We could simply provide them hard-wired, but going the complicated, dynamic way is way more fun.</p>\n\n\n;;;\n\n<p>I can access the operation's representer using <code>self.class.representer</code> (line 1). There's only one property named <code>to_a</code>, which I can grab using <code>definitions.get</code> (line 2). This is an instance of a <code>Definition</code> and contains the nested representer (where we define the thing's actual properties, like <code>name</code> and <code>link</code>) via <code>representer_module</code> (line 3).</p>\n\n<p>This, again, is just another representer. Actually, that's <code>API::V1::Thing::Representer::Create</code>. I access all of its property definitions with <code>definitions.values</code> (line 3). To filter out nested properties I use <code>reject</code> and test for nestedness using <code>typed?</code> (line 4).</p>\n\n<p>The result is a set of definitions that are not nested. I read out the names and symbolize it (line 5).</p>\n\n<p>The <code>scalars</code> variable will now be a one-element array that looks like <code>[:name]</code>. A lot of work for a little array.</p>\n\n<p>Representable has that built in, but, you must admit, this was interesting!</p>\n\n<p>When running the test, the operation will find out if a request parameter instructs filtering, compute the set of properties to render, pass that to the representer using the <code>:include</code> option and the resulting document is exactly what we were expecting.</p>\n\n<p>We know everything about rendering now, and can move on to parsing, which I find more fascinating.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>The way I mix Roar and Representable might be confusing, but it's actually very simple. Representable is the gem that provides almost 95% of the representer mechanics. Roar extends that to a certain extend and adds support for hypermedia and media formats. In other words: Almost all features from Roar actually come from Representable, so bear with me and pardon the confusion. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>Traiblazer gives you a rich set of functions to infer, inherit and refine representers. Please refer to <a href=\"http://trailblazer.to/gems/operation/representer.html\">the docs</a> to learn more about this. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn3\">\n<p>Currently, you need to manually mix in Rails' URL helpers to use them. While this will most probably be done automatically in trailblazer-rails, you can check out how I do it <a href=\"https://github.com/apotonick/gemgem-trbrb/tree/chapter-11/config/initializers/trailblazer.rb\">here</a>. <a href=\"#fnref3\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>After having discussed the essentials of rendering documents using representers, we should focus on a much harder part in software development: parsing, or deserialization, of incoming documents.</p>\n\n<p>Deserialization means to parse a document into fragments, and then assign those fragments to an object graph. This object graph, as an example, could be a nested model. The fragments could be attributes.</p>\n\n\n;;;\n\n<p>In Rails, there simply is no deserialization. In a PUT, PATCH or POST request, <q>deserialization</q> is reduced to a parsed, deeply nested <code>params</code> hash that is either thrown into an unhappy <code>update_attributes</code> hoping that all will go well. Or it is a messy manual traversal of the <code>params</code> hash where many ifs and elses will try to set up an object graph that is close to the models nested in the incoming representation.</p>\n\n<p>While this might look nice with one level of simple attributes, the madness quickly begins when it comes to creating or retrieving nested objects from the document, adding, replacing or deleting particular items in collections, or invoking special finders or setters on nested objects.</p>\n\n<p>It really gets amusing when you have to whitelist parameters, too, since <code>strong_parameters</code> usually breaks down here.</p>\n\n<p>The real funs starts when you need to add items to collections but need to validate that new collection before persisting it. For example, when the restriction is <u><q>Only 3 items maximum in this collection!</q></u> things get really hairy in Rails when <q>deserializing</q>.</p>\n\n<p>Every project I've worked on so far solved this in a different way. I've seen attempts to utilize <code>accepts_nested_attributes_for</code>, manual traversals using the Hashie gem or other half-baked approaches that simply do not hide the fact that deserialization is completely ignored in Rails (and almost all <q>REST</q> gems).</p>\n\n<p>Not only does the complete lack of a crucial layer defeat the purpose of a framework, it also creates redundant code: Knowledge about structure and semantics of your document is now hard-wired into serializers or Rabl templates, and into the parsing code. If you change anything, you have to fix it in both places, and at some point will forget to do so.</p>\n\n<p>What a horrible picture am I painting here? Let's forget about all that. In Trailblazer, deserialization is a first-class citizen of our workflow and we've thought many years about how to do this neatly, and have it working in many production apps backed by the Representable gem.</p>\n\n\\n\n\n<p>You surely remember our examplary mini representer from earlier, the one that could render a comment document.</p>\n\n\n;;;\n\n<p>This class is called <u>representer</u> because it <u>represents</u> an object graph. That means, it can render and parse. Internally, two completely separated components will take care of those two tasks, but they will both use the same representer definition as the document structure, so they know which properties to render or parse, where to apply nesting logic, and so on.</p>\n\n<p>You already know how to use the representer for rendering, therefore, let's discuss the parsing aspect.</p>\n\n\n;;;\n\n<p>Parsing<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup> with representers is super simple. The representer will grab all fragments it knows from the document and assign them to the decorated object by calling a setter method.</p>\n\n<p>In that example, this will be a <code>comment.body = \"I love it!\"</code> - nothing more. The document could be loaded with other bogus properties and fragments, the representer will simply ignore those, giving you a whitelisting mechanism for free.</p>\n\n<p>This sounds pretty familiar, doesn't it? It feels like Reform. And that's because Reform internally uses a representer for deserializtion in <code>validate</code>. We'll speak about this soon enough.</p>\n\n<p>Before discussing how parsing, the form object and the operation play together, let me quickly show you how a nested parsing would take place.</p>\n\n<p>What if the JSON document looked like this?</p>\n\n\n;;;\n\n<p>There now is a scalar property and a nested user object in the document. Representers can have nested representers, and once you tell Representable what object type they are, it will be able to parse a nested document.</p>\n\n\n;;;\n\n<p>I simply nest another representer into the existing one (line 5-7). The <code>:class</code> option will help Representable parse the nested fragment into a <code>User</code> object. This is the most primitive parsing mechanism, but it helps understanding its concepts.</p>\n\n\n;;;\n\n<p>When parsing, the nested <code>user</code> fragment is <q>turned into</q> a <code>User</code> object, and the nested properties are deserialized onto that newly created model.</p>\n\n<p>Again, this is a very primitive mechanic, Representable can do rich population, find models by arbitrary fields instead of creating them, and so on. Since Reform uses representers for deserialization, the semantics here are almost identical<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>.</p>\n\n\\n\n\n<p>We're about to implement the deserialization of a comment with a nested user, similar to the comment form we created in the earlier chapters, the one that sits on the thing's show page.</p>\n\n<p>As a first, yet triumphant, step, I add another test to <code>test/api/comments_test.rb</code>. Again, it all goes into its own <code>describe</code> block.</p>\n\n\n;;;\n\n<p>First, I create the thing we're going to comment (line 2). In the second <code>let</code> I define the <code>POST</code> document body that will be pushed to the endpoint (line 3-6). As you can see, I nest a user into the document. Please note that right now, I'm <u>not</u> HAL-conform since the document is missing the <code>_embedded</code> level. I chose to go that way for the sake of clarity. We'll correct the wrong input document format in a minute.</p>\n\n\n;;;\n\n<p>Once the environment is set up, a <code>post</code> will invoke the request we want to test (line 4). See how the <code>things/:id</code> is prefixing the actual <code>comments</code> endpoint? I use a nested route here so I don't have to pass the thing ID as a parameter. Remember, in order to create a comment, we need <code>thing_id</code> and Rails helps us with that by providing nested routes.</p>\n\n<p>I know, you're impressed by my testing discipline. But be honest, it is so much simpler to write this little, automatic test than having to fumble around with Postman or Curl.</p>\n\n<p>After the request went through, I grab the comment that we hopefully created (line 6).</p>\n\n<p>The next two tests make sure the response was a <code>201: Created</code> HTTP status code (line 7). The <q>RESTfulness</q> of my response is tested when I assert that the <code>Location:</code> header points to newly created resource. This is another best practice in the hypermedia world.</p>\n\n<p>In order to verify that the <code>POST</code> worked, I add two simple assertions for now.</p>\n\n\n;;;\n\n<p>The test makes sure the correct data was persisted and the right nested objects got created (line 4-5).</p>\n\n<p>Alternatively, you could issue another <code>GET</code> request to the new URL and test the response document. I added an example in the repository for that.</p>\n\n<p>Making this test pass is surprisingly simple, thanks to some nice features in Trailblazer.</p>\n\n<p>As always, we need to define the new <code>POST</code> route in <code>config/routes.rb</code>.</p>\n\n\n;;;\n\n<p>I added a nested resource (line 3-5) which will route requests to <code>/api/v1/things/:id/comments</code> to <code>Api::V1::CommentsController</code>. This is one of Rails features that I actually do appreciate.</p>\n\n<p>The API comments controller is extended with a <code>create</code> action to intercept <code>POST</code> requests.</p>\n\n\n;;;\n\n<p>To run the operation, I use the familiar <code>respond</code> and reference the <code>API::V1::Comment::Create</code> operation (line 4). The mysterious <code>:namespace</code> option is directly passed to Rails' responder when the response is compiled and sent. The responder includes a <code>Location:</code> header in the response and needs some fine-tuning to find the correct URL helper.</p>\n\n<p>Next, I add the <code>Create</code> operation to <code>app/concepts/api/v1/comment/operation.rb</code>.</p>\n\n\n;;;\n\n<p>Note that I inherit from <code>::Comment::Create</code>, the original form processing operation from earlier chapters (line 3). I include the <code>Representer</code> and <code>Responder</code> module to make the operation work with the responder, as discussed earlier (line 4).</p>\n\n<p>And, believe it or not, but this is enough code to make the test run.</p>\n\n\\n\n\n<p>There's two things to note here. First, we send in the wrong document, it doesn't follow the HAL specifications and is missing the <code>_embedded</code> key.</p>\n\n\n;;;\n\n<p>Second, since we inherit from another operation, the contract is inherited. As we use <code>Representer</code>, a representer will automatically be inferred, allowing us to deserialize a JSON document, validate it using the form, process and persist it using the inherited operation mechanics.</p>\n\n<p>Now, why on earth does this work without us having to do anything?</p>\n\n<p>The contract that we inherited from the <code>Comment::Create</code> operation doesn't really care whether its input comes from a form submission, from the command line, or a JSON document!</p>\n\n<p>Here's what happens from top to bottom.</p>\n\n<ol>\n<li>We fire a <code>POST</code> request at the <code>create</code> action. Its body is a JSON document.</li>\n<li>The controller action parses that document into a <code>params</code> hash. It then dispatches to the API <code>Create</code> operation and passes in this very <code>params</code> hash.</li>\n<li>In the operation, the inherited <code>process</code> method is called and in it, the <code>validate</code> method will receive this hash. The operation knows that it needs a special representer since we mixed in <code>Representer</code> and instantiates it.</li>\n<li>Now, the representer is called to deserialize this hash, which means it traverses it and assigns known fragments to known properties.</li>\n<li>Remember, the structure of the JSON document is <q>accidentially</q> identical to the form hash that we normally have to deal with. That means the representer that was automatically inferred from the contract <q>understands</q> this hash and knows what properties to deserialize.</li>\n<li>The crucial point to understand this whole cycle is: the representer deserializes the hash <u>to the contract</u>. In other words, it goes through the hash, grabs the <code>body</code> fragment and writes it to the contract using a setter as in <code>contract.body = \"Love it!\"</code>. The contract doesn't even know its being reused for a JSON API, since it doesn't see the incoming document.</li>\n<li>When inferring the representer from the contract, populator options are considered, too. When the representer reaches the nested <code>user</code> fragment, it reaches out to the contract, invokes its populator, and continues the nested deserialization. All private population logic happens on the form, not in the representer.</li>\n<li>After the contract is populated with all the attributes and nested instances, the normal <code>process</code> flow will continue, unaware that it is validating and persisting a JSON document request.</li>\n</ol>\n\n<p>By separating representer and contract, we can reuse the same form with different input sources. While the representer knows about the incoming document structure and traversal rules, the form provides setters for properties and will handle the population for nested objects.</p>\n\n\\n\n\n<p>I know this was a huge chunk of information. Let me briefly explain to you how deserialization and validation in a normal Reform form work, in a much simpler environment, cutting out all the Traiblazer operation noise. This will help understanding that we simply replace the representer in a JSON environment.</p>\n\n<p>Normally, when you invoke a Reform form, you call its <code>validate</code> method and pass in a hash that matches its property structure.</p>\n\n\n;;;\n\n<p>Internally, Reform will now assign all scalar values via its setters.</p>\n\n\n;;;\n\n<p>Nested fragments work slightly different. First, Reform will invoke the populator to create the nested form. In our case this will be a nested user form that itself wraps a <code>User</code> model.</p>\n\n<p>It then simply passes the nested hash to the nested form's <code>validate</code> method and, recursively, the cycle starts again.</p>\n\n<p>In pseudo code, this roughly looks as follows.</p>\n\n\n;;;\n\n<p>The difference between what I just illustrated<sup id=\"fnref3\"><a href=\"#fn3\" rel=\"footnote\">3</a></sup> and the real code is: Reform internally <u>always</u> uses a representer to deserialize the hash.</p>\n\n<p>So, a bit closer to reality, this happens.</p>\n\n\n;;;\n\n<p>Regardless of all the details that happen here, Reform uses a genuine representer to do the deserialization, even in a non-JSON environment. You've used this mechanism many times before without knowing it.</p>\n\n<p>The internal representer will do exactly the same I did by hand in the first pseudo code snippet. It assigns scalar values to the form, and calls the contract's populator code which returns the nested form. It then recurses on that nested object.</p>\n\n<p>The validation after that is completely unaware of the former deserialization. Validation checks the form's state and decides about validity.</p>\n\n<p>Likewise, deserialization is completely decoupled from validation.</p>\n\n<p>Now, why am I explaining this? The reason we suddenly can read, validate and process documents in the HAL format is because we swap the form's internal representer. This especially makes sense when the document format and the form's structure diverge - and that is the case when we use <q>real</q> HAL for our <code>POST</code> request.</p>\n\n\\n\n\n<p>You're still with me, and that's great. As a next step, I want to <code>POST</code> a valid HAL document to the <code>Comment::Create</code> operation. I'm back in the <code>test/api/comments_test.rb</code> file.</p>\n\n\n;;;\n\n<p>All I do in this file is change the <code>json</code> fixture slightly. Instead of pushing the <code>user:</code> key as a top-level property, I nest it in under the <code>_embedded</code> key the way HAL specifies it (line 5).</p>\n\n<p>The test will now break, as we send a HAL document. Our operation still uses an inferred representer that has no clue about HAL. It simply doesn't <q>see</q> the <code>_embedded</code> fragment, hence it does not add a user, the form's validation fails, the operation will be invalid, customers will be angry and the earth will collapse.</p>\n\n<p>To escape this dark apocalypse, we should use a representer that knows HAL in the <code>API::V1::Comment::Create</code> operation.</p>\n\n<p>The API's <code>Create</code> operation gets slightly enhanced.</p>\n\n\n;;;\n\n<p>I simply reference the representer from the <code>Show</code> operation which is a valid HAL representer. Remember, we added the <code>embedded: true</code> options, hyperlinks and all that in <code>Representer::Show</code> earlier.</p>\n\n<p>Now, there's one tiny more thing I have to do in this representer.</p>\n\n<p>I open <code>app/concepts/api/v1/comment/representer.rb</code> and add one line.</p>\n\n\n;;;\n\n<p>The representer is exactly as it was before except for the <code>:populator</code> option I added to the <code>user</code> property (line 5).</p>\n\n<p>When running the tests this time, everything will pass. We parsed an incoming HAL document with a specialized representer, deserialized the data to the unknowing form, and persisted the changes reusing operation logic we wrote chapters ago.</p>\n\n<p>To summarize this, again, here's an even quicker run-through. This time, I'll skip the request to controller to operation steps.</p>\n\n<ol>\n<li>The HAL hash is passed into <code>API::V1::Comment::Create</code>'s <code>#process</code> method. This method is inherited from <code>Comment::Create</code>, and it will further pass this HAL hash into <code>validate</code>.</li>\n<li>The operation has the <code>Representer</code> module included and therefore is expecting HAL. It instantiates the HAL representer <code>API::V1::Show::Representer</code> that we reference in the operation class.</li>\n<li>This representer will now deserialize the hash with all its HAL internals to the contract instance. The contract is inherited from the generic form operation and does not know a thing about HAL. This doesn't matter, as the representer takes care of this.</li>\n<li>When the representer encounters a nested fragment, it calls the respective populator. I defined <code>populator: Reform::Form::Populator::External.new</code>, which means the representer will call the form's populator. We don't have to copy the complicated logic.</li>\n<li>Once deserialization is finished, the contract validates its virtual state.</li>\n<li>If found valid, the contract persists data via the model. This is all happening in logic inherited from the generic operation.</li>\n</ol>\n\n<hr>\n\n<p>Representers are extremely powerful. They are an explicit document description and can render and parse documents without distributing knowledge about document structure and semantics across the entire framework.</p>\n\n<p>They are highly reusable, which we could see the way <code>Show::Representer</code> is used for rendering, but also to deserialize incoming HAL documents. They can be used to transform complicated hypermedia documents to Trailblazer contracts or stand-alone twins.</p>\n\n<p>Most of the processing logic could be inherited, we didn't have to write a single line of code. If requirements should start to diverge for different environments, you can easily override parts or the entire <code>process</code> step.</p>\n\n\\n\n\n<p>In the following sections I want to show you how we can apply our polymorphic operation logic of the <code>Thing</code> concept to API code. You know, where we expose different behavior for anonymous, signed in and admins. This involves allowing users to authenticate. In Gemgem, I use Basic Auth straight from HTTP, but you're free to implement it with any kind of authentication you like.</p>\n\n<p>Let's start to implement <code>POST</code> request processing for the endpoint <code>/api/v1/things</code>.<sup id=\"fnref4\"><a href=\"#fn4\" rel=\"footnote\">4</a></sup> As you might recall, creating things worked without signing in, so we won't see too much polymorphic behavior here.</p>\n\n<p>Test cases for the things API will go into <code>test/api/things_test.rb</code>.</p>\n\n\n;;;\n\n<p>I setup a sample JSON document to <code>POST</code> (line 4-7). Note that this is perfectly formatted HAL, already, so we have to make sure the processing representer is prepared for that.</p>\n\n<p>The document then gets sent to the endpoint (line 9).</p>\n\n\n;;;\n\n<p>In the second part of the test I grab the created Thing's ID as well as the author's ID (line 3-4).</p>\n\n<p>Next, the <code>Location:</code> header is tested (line 6-7). I also make sure the returned HTTP status is 201. This can be tested using <code>created?</code>, too (line 8).</p>\n\n\n;;;\n\n<p>Rails' responders per default return the rendered model in a <code>POST</code> request. In our case, the responder will run the operation and then call <code>to_json</code> on it, exactly the way it works in <code>GET</code> requests, too.</p>\n\n<p>This is the perfect chance to test if the creation worked. This time, instead of asserting database state, I simply test the returned document and make sure IDs are assigned and the author is nested (line 12).</p>\n\n<p>Note that the document says <code>authors</code> and not <code>users</code>. I renamed that fragment on purpose, and you will learn how in the next section.</p>\n\n<p>The test for creating a <code>Thing</code> is hereby completed.</p>\n\n<p>Now, don't get confused, but this time we do not need to add routes. This has been done earlier in this chapter and requests to <code>/api/v1/things</code> get safely routed to the controller that resides in <code>app/controllers/api/v1/things_controller.rb</code>.</p>\n\n\n;;;\n\n<p>This is the same conceptual implementation we had in our <code>CommentsController</code> earlier. I use <code>respond</code>, reference the <code>Thing::Create</code> operation and provide hints for the <code>Location:</code> header for the responder (line 6).</p>\n\n<p>The processing operation, <code>API::V1::Thing::Create</code>, sits in <code>app/concepts/api/v1/thing/operation.rb</code>.</p>\n\n\n;;;\n\n<p>Again, I inherit from the API operation's counter-part, the <q>real</q> operation <code>Thing::Create</code> (line 3). While the inheritance gives me the contract and the remaining behavior of the original <code>Create</code>, I reference an external representer <code>Representer::Create</code> the way we solved that in the comment API (line 6).</p>\n\n<p>As for the <code>Representer::Create</code> code, I put that into <code>app/concepts/api/v1/thing/representer.rb</code>.</p>\n\n<p>The representer structure is pretty close to the <code>Thing::Create</code> contract we implemented in earlier chapters. However, since we include hypermedia and override some attributes, I prefer having a separate, non-inferred representer<sup id=\"fnref5\"><a href=\"#fn5\" rel=\"footnote\">5</a></sup>.</p>\n\n\n;;;\n\n<p>This is really just another representer in the <code>API::V1</code> namespace. After marking the representer as a HAL document, I define the <code>name</code> property and the <code>users</code> collection (line 5-8). The <code>users</code> property should be handled as a embedded element (line 8). Representable allows to rename properties, and by using <code>as: :authors</code>, the users will be keyed as <code>authors</code> in the document and parsed from that name (line 9).</p>\n\n<p>By setting the <code>External</code> populator, I make sure that when parsing, the form's populator for the <code>users</code> fragments is called so I don't have to copy the code to the representer (line 10).</p>\n\n<p>The rest of this representer is old hat and needs no further explanation.</p>\n\n<p>When running the <code>Create</code> test, the representer we just implemented will transform the HAL document into the normal nested structure that the form is expecting. It will also take care of renaming <code>authors</code> to <code>users</code> as the form has no idea about <code>authors</code>.</p>\n\n<p>The inherited code from the non-API <code>Thing::Create</code> implements the processing and persisting. No work has to be done here.</p>\n\n<p>After the operation's been run, the responder will call <code>to_json</code> on it to render the response document. Again, the operation knows that because of the mixed in <code>Representer</code> module, and uses representer and model to compile that.</p>\n\n\\n\n\n<p>I promised you to speak about polymorphism in APIs. You will remember the <code>Thing::Update</code> operation as being polymorph: only signed-in users and admins can update things. Where admins can edit any model, signed-in users can only update their own things.</p>\n\n<p>We implemented this using two subclass <code>Thing::Update::SignedIn</code> and <code>Thing::Update::Admin</code> which were dispatched using a builder. The good news is: plugging together the already implemented polymorph operations and the API-specific representer is all we have to do right now.</p>\n\n<p>When testing the polymorphic aspects of the update operation, please allow me to discuss the admin case, only. The tests for anonymous users and signed-in users can be found in the repository and are almost identical.</p>\n\n<p>Testing the admin's update goes to <code>test/api/v1/things_test.rb</code>.</p>\n\n\n;;;\n\n<p>To actually have an asset to update, I use the <code>Thing::Create</code> operation as factory where I add a user, too (line 2-6). In the test case, I assign IDs to variables to simplify tests later (line 9-10). I then prepare the JSON document to be sent (line 12-15).</p>\n\n<p>Note that there is a <code>remove: \"1\"</code> property in the document exactly where it would be in the form submission. My goal is to update the existing thing's name to <q>Roda</q>, and at the same time delete its only user.</p>\n\n<p>While hypermedia formats like JSON API require two requests for that, one to update the model's attributes, one to remove the association member, in HAL there is no restrictions. It is totally up to my server implementation whether or not to respect this as a delete semantic. If you feel like your media format should not support higher-level application semantics, you could simply ignore the <code>:remove</code> fragment in the representer<sup id=\"fnref6\"><a href=\"#fn6\" rel=\"footnote\">6</a></sup>.</p>\n\n\\n\n\n<p>In the next section of the test, I create an admin user using the <code>Session::SignUp::Admin</code> operation (line 3).</p>\n\n<p>Using the <code>authorize</code> method from Rack-test, the brand-new admin user gets <q>logged in</q> (line 4). Don't confuse that with a session login. This will simply set user and password name for the next test request and mark them to be sent in a Basic Auth header, as if you'd filled out the modal dialog box that usually pops open when accessing a Basic Auth-protected website.</p>\n\n<p>And, finally, after all this setup, I issue a <code>PATCH</code> request to the thing resource and pass the JSON document as request body.</p>\n\n<p>Updating an existing resource in a HTTP context usually works by sending a <code>PUT</code> or <code>PATCH</code> request. While a <code>PUT</code> request is meant to replace the existing document with the submitted document, <code>PATCH</code> supposedly is a <u>partial update</u>. Since I only want to change the name (and remove the author), a <code>PATCH</code> is the way to go.</p>\n\n<p>In Rails, every update is a <code>PATCH</code>, and this ground-breaking convention resulted from a 2-years debate about application semantics, <q>REST</q>, and <code>update_attributes</code> behavior - a debate that I have gladly ignored.</p>\n\n\n;;;\n\n<p>After the <code>PATCH</code> request, I fetch the updated resource using <code>GET</code> (line 3). In the returned document, I make sure the name has changed and there's no users, or authors, referenced anymore (line 5-9).</p>\n\n<p>As for the implementation, I would love to start with a simple route, but we already defined <code>resources :things</code> earlier.</p>\n\n<p>After the route comes the endpoint, or, controller, as we call it in Rails. Here's the <code>update</code> action in <code>app/controllers/api/v1/things_controller.rb</code>.</p>\n\n\n;;;\n\n<p>In the <code>update</code> action that processes the <code>PATCH</code>, I decided to do authentication manually, for educational purposes. I check if a Basic Auth header was sent in the request using <code>request.authorization</code> (line 4).</p>\n\n<p>I then use a Rails function, a very clumsy constant and method, that needs to be spread over three lines to make it format neatly, to retrieve the submitted username and password (line 5-7). Since we authenticate with the user's email, I name the variable accordingly.</p>\n\n\n;;;\n\n<p>To verify the credentials, I reuse the <code>Session::SignIn</code> operation we derived from Tyrant. Please note that I use <code>run</code> here to invoke the operation (line 3). With this invocation style, I can make use of the block, which is only executed when the operation was valid. That means the <code>:current_user</code> value is only set when the login credentials were valid, because that's what <code>Session::SignIn</code> validates (line 4).</p>\n\n<p>An interesting fact here is that I do not set any global variables via Tyrant or Warden. All I do is add the <code>:current_user</code> option to the operations params. As you do remember, the operation's builder and policy will look out for this parameter and base further steps on its existence.</p>\n\n<p>Setting global values is always wrong. In the <u>Authentication</u> chapter I did this to satisfy Rails' addiction to global variables. Here, we don't use any more Rails code so we don't have to set it. Instead, all that happens after the authentication is the call to <code>respond</code>, where the params will be passed to the operation (line 8). So, instead of global state, we explicitly let <code>respond</code> pass the params along with the user object to the operation.</p>\n\n<p>Please note that the authentication code could and should totally be abstracted into a separate class, or we could even use Tyrant's HTTP authentication feature<sup id=\"fnref7\"><a href=\"#fn7\" rel=\"footnote\">7</a></sup>. Nevertheless, I find it a lot better to understand going the manual way.</p>\n\n<h3>Update Operation</h3>\n\n<p>Implementation of the update function you find in <code>app/concepts/api/v1/thing/operation.rb</code>.</p>\n\n\n;;;\n\n<p>Very little code for a lot of behavior, isn't it? And this is where Trailblazer really starts to take off and shows how inheritance and composition is an incredibly helpful tool when used the right way.</p>\n\n<p>The <code>API::V1::Thing::Update</code> operation inherits contract and process behavior from the original <code>Thing::Update</code> class (line 3). In order to make this operation instantiate the correct sub operation, I copy the builder from <code>Thing::Create</code> into this class (line 4).</p>\n\n<p>Whenever we call <code>API::V1::Thing::Update</code> now, which we do in the <code>update</code> action we just introduced, it will instantiate the <code>SignedIn</code> subclass if a current user's passed in the params, and the <code>Admin</code> subclass if that very user is an admin. If none of that is passed, there will be an authorization exception. This has all been implemented before, and we can simply reference that behavior without having to worry about the internals, again.</p>\n\n<p>What we need to do, though, is to implement the operations that handle the different user types. I will only discuss <code>Admin</code> here as you can find the <code>SignedIn</code> in the repository with very similar code.</p>\n\n<p>All the <code>API::V1::Thing::Update::Admin</code> class needs to do is derive itself from the original one <code>Thing::Update::Admin</code>, include the <code>Representer</code> module and then reference the same representer we used for <code>Create</code> (line 6-9).</p>\n\n<p>That is really everything we need to do. I'll walk you through the entire request stack now.</p>\n\n<ol>\n<li>In the test, we instruct the request to carry Basic Auth credentials using <code>authorize</code>.</li>\n<li>We then <code>PATCH</code> a JSON document against <code>/api/v1/things/:id</code>, which is meant to change the title of a formerly created <code>Thing</code> instance, and remove its author. The structure of this document is the same as we used for the update form, but embedded in HAL syntax.</li>\n<li>The <code>update</code> controller action that is being hit by the request uses Rails internals to figure out Basic Auth credentials from the request, authenticates the user and references them as <code>:current_user</code> in the params hash. This follows the same API that we used in the <u>Authentication</u> chapter.</li>\n<li>After the manual authentication, the action delegates to the <code>API::V1::Thing::Update</code> operation.</li>\n<li>This will invoke the operation's builder which will, in our test case, instantiate <code>API::V1::Thing::Update::Admin</code> and pass in the <code>params</code>.</li>\n<li>Since we reference the representer from the API <code>Create</code> operation, this representer will be used to deserialize the incoming document to the contract. Don't forget, it's a HAL representer, so it understands formating like <code>_embedded</code> and will properly write all input to the contract.</li>\n<li>The contract now represents the changed state from the request. It validates itself, runs populators and eventually will also delete the author from the association.</li>\n<li>The inherited <code>process</code> method will write the updated <code>Thing</code> and the association changes to the database by saving the model.</li>\n<li>For the operation, the job is almost done. Now the responder from Rails kicks in and calls <code>to_json</code> on the operation, which was about to go to bed, but now uses the representer, again, to serialize the updated model into JSON.</li>\n<li>The JSON is sent back in the response and we verify it does not contain a user anymore and the title has changed to the name of a very promising Ruby framework.</li>\n</ol>\n\n<p>You might be skeptical as to what would happen if the behavior of the API operation and the normal form-processing operation should be different. The answer is simple: You'd use object-orientation to override the steps you want to change.</p>\n\n<p>This might involve overriding parts of the <code>process</code> method. Or, say you wanted to suppress the deleting of authors, you could override parts of the contract definition and remove the <code>is_author</code> field. Even though it looks almost <q>too easy</q>, the whole conception of operations, builders, representers and contracts is designed to do just that.</p>\n\n\\n\n\n<p>By taking advantage of OOP features, composition and inheritance along with overriding particular hooks, you can reduce code to a minimum where you really want to change specific behavior without running into the trouble of breaking existing code. Every environment, whether that's a form submission for an anoymous author, a signed in user, or an admin user in a JSON environment, is encapsulated in a separate class.</p>\n\n<p>When presenting the OOP design of Trailblazer, many developers criticized this and complained about that <u><q>this will involve too many classes to maintain</q></u>. We just learned the opposite: the classes need to exist, that's true, but their code often is only a handful of lines to plug together the required behavior - something that could be done in the background, automatically and convention-driven, if desired.</p>\n\n<p>If suddenly a particular environment has to change, say the signed in user can no longer delete other authors, this is a matter of extending the particular classes that maps to this environment, only. You would change operation and contract code, maybe callbacks, too, in that specific class without having to worry about breaking other code. This is applied OOP the way it was intended to be used, and I do appreciate that.</p>\n\n<div class=\"footnotes\">\n<hr>\n<ol>\n\n<li id=\"fn1\">\n<p>I will say <u>parsing</u> instead of <u>deserializing</u> every now and then, even if it's not the exact same thing. <a href=\"#fnref1\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn2\">\n<p>I won't discuss populators in Representable and Roar in this book, as population in Trailblazer happens via the form. However, should you need separate mechanics, you can learn everything you need to know in the <a href=\"http://trailblazer.to/gems/representable/3.0/populator.html\">official, free documentation</a>. <a href=\"#fnref2\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn3\">\n<p>The upper part of that method actually is implemented in <code>Form#deserialize</code>. <a href=\"#fnref3\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn4\">\n<p>I've left out discussing implementation of <code>/api/v1/things/1</code> and the <code>API::V1::Thing::Show</code> operation, as it is trivial and analogue to what we've done bere. You can find the code and tests anyway, in the Gemgem repository. <a href=\"#fnref4\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn5\">\n<p>Trailblazer allows to infer representers from contracts, and then refine them afterwards. It comes with a nice API to override specific properties, or to inherit and extend. This is helpful if you have huge contracts and representers where redundancy can become a problem. However, in my example, the inheritance would create more code than rewriting the structure. Make sure to <a href=\"http://trailblazer.to/gems/operation/representer.html\">check out the docs</a> if you're planning to used inferred, but refined, representers. <a href=\"#fnref5\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn6\">\n<p>Personally, I am very interested in a richer media format with application semantics that go beyond primitive CRUD operations on URLs, so I decided to leave this as an inspirational feature in the book. <a href=\"#fnref6\" rev=\"footnote\">↩</a></p>\n</li>\n\n<li id=\"fn7\">\n<p>By the time of writing this chapter, Tyrant did not have the aforementioned feature, yet. As soon as this is shipped, I will reference the documentation here. <a href=\"#fnref7\" rev=\"footnote\">↩</a></p>\n</li>\n\n</ol>\n</div>\n\\n\n\n<p>When presenting Trailblazer at conferences or user groups, I often make the same observation. Either, people are super excited about it. After a talk, someone from the audience asked <u><q>So Trailblazer basically makes everything completely different to Rails? That's awesome!</q></u>. Those people have felt the pain of Rails' lack of a high-level architecture.</p>\n\n<p>A funny side-note here is that I've met many <q>juniors</q> who instantly could see how to place Trailblazer into their existing Rails apps. An eye for architecture sometimes doesn't require decades of engineering practice - often, your gut feeling is just right.</p>\n\n<p>Then, there's people who're absolutely not interested, who're glad the talk is over.</p>\n\n<p>I am guessing these people have built their own higher abstractions and are happy with it. I have zero interest in attracting happy developers to Trailblazer. If someone's confident about their architecture, there is no use in convincing them to use your gems just for the sake of convincing them. I had a number of very interesting discussions about how Trailblazer overlaps with other people's solutions. However, I've never seen the integration of service object, form, and representer, as nicely as in my own framework, but, so be it.</p>\n\n<p>And then, there will be many peope criticizing Trailblazer. They will complain <u><q>It has too many objects!</q></u>, or they fearing <u><q>The garbage collection is gonna collapse!</q></u> and the like, or that <u><q>We now have a god class called operation!</q></u> and they will ask for answers to their clever questions.</p>\n\n<p>Usually, we both agree that more abstraction layers are needed. MVC is just not enough.</p>\n\n<p>However, many people don't understand that objects in Ruby are super cheap. When you parse a JSON document into hashes, there's thousands and ten-thousands of objects being created, hashes, strings, and so on. Ruby doesn't care if an object is a cell, an operation, a hash or a string.</p>\n\n<p>The garbage collection doesn't even know it's cleaning up a Trailblazer application because the few more objects don't really make a difference. The opposite is the case, objects can be disposed of quicker because, unlike Rails controllers or models, they are not needed over the entire request.</p>\n\n<p>When it comes to the <u>God Object</u> discussion, and I've mentioned that earlier in the book, I usually have to explain that orchestration and implementation is not be confused. Just because an operation keeps references to all stakeholders like callbacks, representer, model, contract, and so on, doesn't mean it implements these responsibilities - which contradicts the definition of this anti-pattern.</p>\n\n<p>Trailblazer is definitely not meant to be a solution for every programmer on this planet. But what I found out is: many developers, once they reach a certain mindset, are incredibly anxious of accepting other ideas. This includes myself. It is very hard and challenging to give up your own approach and allow other's thoughts to help solving your problem.</p>\n\n<p>A good way is to talk to each other, identify what issues need to get solved and then discuss what patterns might be helpful. There's many stories I could tell now, for example, why my code has changed radically from a very fuzzy object to functional, strict APIs, where objects often just have one public method. But this is content for another book.</p>\n\n<p>The cool thing about Trailblazer is: you don't have to sell it at once. It can be step-wise introduced, and developers who were initially protesting against it might get convinced by seeing how and where it actually helps.</p>\n\n\\n\n\n<p>Writing this book was an incredible experience. What might sound to you like a classic author's platitude I mean for real.</p>\n\n<p>The traction that Trailblazer got during the writing of this book was beyond any expectations of mine. I did absolutely <u>not</u> believe in the idea that entire companies will base their softwares on the Trailblazer framework at that early stage. I learned that teams used Trailblazer with Webmachine, with Roda, or to refactor classic Rails apps.</p>\n\n<p>It was a very humbling feeling, but at the same time, I got stressed. Trailblazer, in my eyes, still had a long way to go, I wanted to finalize the embraced gems, refactor problematic code I've hated for years, and so on. And yet, entire products were using those gems.</p>\n\n<p>Most teams are still using Trailblazer at the present day. I've heard of a few who've given up due to the - understandably - bumpy ride, but those who stick do not seem to regret it. They now enjoy the matureness and stability of an evolving framework.</p>\n\n<p>Most users report that Trailblazer has dramatically improved their code structure. By introducing <u>Operation</u> and making every public function of the application an enclosed object, teams are forced to communicate in APIs - a fantastic restriction in software development.</p>\n\n<p>Also, the operation container is easy to test, and no longer do you have to think about what to test where: Logic is tested via an operation test, wiring and view in integration tests, and you're done.</p>\n\n<p>The integration of contract in the operation, along with processing logic made developers think in layers. Suddenly, the melting pot of models became different steps: deserialize to a contract, validate the contract, run your business code based on this contract twin, and then let the twin persist the data to your ORM models.</p>\n\n\\n\n\n<p>Often, I get asked why I don't write a new framework for Ruby instead of <u><q>having to integrate Trailblazer</q></u> with all the existing ones.</p>\n\n<p>My question is always: <u><q>Why would I?</q></u> There's a bunch of very promising frameworks out there, many of them battle-tested, fast, cleanly implemented without making monstrous assumptions about your objects. The core teams of those projects have focused years on providing what I call an <u>infrastructure framework</u>: they have spend many thoughts on library file organization, routing, dispatching, automatic tasks, asset pipelining, migrations and bindings to various ORMs, test integration and many things more.</p>\n\n<p>It would be both time-consuming and frustrating to try to compete with existing solutions. Look at it from another perspective: Trailblazer is good at the business, at implementing the high-level architecture of web applications. This is where most frameworks - no offence - have rather half-baked solutions for deserialization, validation or post-processing.</p>\n\n<p>Trailblazer is definitely the strongest framework for those higher level tasks.</p>\n\n<p>This is, because we focused on those architectural layers exclusively, while neglecting the infrastructure. Of course, we knew that there's many other projects to pick from, gems that provide us with dispatching logic we could have never rewritten in such matureness.</p>\n\n<p>In other words: I prefer to focus on making one thing good, instead of trying to deliver a all-in-one solution. Another nice side-effect is: the more you decouple your work from actual frameworks, the better your APIs will get.</p>\n\n<p>And now, developers have the choice of what to pick and where to use their choice with Trailblazer!</p>\n\n\\n\n\n<p>Rails has brought together many many people, huge companies and projects are relying on this framework. The eco-system that has evolved around it is incredible, and it feels great to be a part of it.</p>\n\n<p>In the last couple of years, however, Rails has lost leadership. Personally, I can't identify who's pushing for change, innovation, or critical thinking anymore. There's no big picture. Little features like ActiveJob or ActionCable are added here and there, none of them with structural impact to make us write better software.</p>\n\n<p>Internally, Rails is standing still: it's impossible to refactor parts without having to change concepts or API. This desperately needed <u>change</u> seems to be a no-go for the ruling party - a stubborn attitude that will navigate Rails into a not meaningless, but no more meaningful existence in the next year or two.</p>\n\n<p>Personally, I am not too interested in using or improving Rails anymore. I find everything about the Rails Way is wrong, which I hope to have pointed out in this primer. In hindsight, I've learned many many lessons through Rails, and I do appreciate that. The pain and trouble I've had fighting Rails at basically every point of writing a non-Basecamp application is definitely outweighing the benefits I got from a handful of features like migrations or test integration.</p>\n\n<p>I wish I had better news regarding Rails, that it is on the right path, but the amount of smaller, more innovative companies that are switching to newer frameworks is saying the opposite.</p>\n\n\\n\n\n<p>Webmachine's philosophy is to not provide a DSL, but let users inherit classes and then overwrite behavioral methods - a concept I do appreciate a lot. For a long time, Webmachine was the only framework that implemented the HTTP specification correctly, and it might still be able to claim that.</p>\n\n<p>I've never used it myself except for a brief session side by side with the author Sean Cribbs, where we connected Webmachine with Roar. I know of several companies, though, that use Webmachine and implement every <code>Resource</code> with Trailblazer operations, exactly how we did it in the <u>Hypermedia APIs</u> chapters but without the Rails noise.</p>\n\n\\n\n\n<p>Grape is a framework exclusively to build hypermedia APIs. It comes with a simple, pluggable routing architecture where endpoints implement the representation of the resources. Grape provides its own implementation of rendering, deserialization and validation.</p>\n\n<p>Nevertheless, Grape also allows replacing huge parts with Trailblazer. I am currently working on an API project where Grape provides the routing, only. The entire high-level architecture is implemented in Trailblazer operations. This is one of the most beautiful projects I've ever worked on.</p>\n\n\\n\n\n<p>The ROM project is not really a web framework, even though it is extremely helpful in this environment. It helps modelling persistent objects to arbitrary data structures. ROM's very modular architecture then allows to hook processing and validation logic into that mapping task, making it a very functional-oriented tool that minimizes state.</p>\n\n<p>It works perfectly in Trailblazer's operations and can replace the persistence layer or even higher processing steps. While Trailblazer provides the higher application structure, deserialization and validation, ROM can act as the ideal counterpart for everything that comes after that. I've seen ROM and Trailblazer play together in a few friends' projects and can't wait to start playing with it myself.</p>\n\n\\n\n\n<p>Main focus of Roda is a routing API that allows defining and plugging in your endpoints. Roda, just like Grape and Lotus, doesn't do nasty Ruby work-around but is implemented very cleanly and fast. It also comes with a huge selection of plugins, from serializers to partials and template support.</p>\n\n<p>So far, I have only heard from other developer teams about how nicely Roda and Trailblazer interact, since the operation can be hooked into the routing tree to perform the business logic. Apparently, Cells also plays nicely with this stack and allows a rich UI layer on top of an operation-backed routing tree. It is needless to say that I am intrigued by this partnership and need to try it out in the near future.</p>\n\n\\n\n\n<p>Lotus is a relatively new framework that claims to be <u><q>a complete web framework</q></u>. It is a bit too early to comment on its high-level architecture, which I am missing in Lotus at the moment. However, exactly that makes it a perfect partner for Trailblazer.</p>\n\n<p>Lotus' implementation is incredibly clean, free of monkey-patching and the team focuses on integrating more low level tasks like migrations, asset pipeline or tasks. Its endpoint <code>Lotus::Action</code> is where you can hook in Trailblazer - where Lotus handles the transportation, routing and infrastructure, Trailblazer can do what it's best at: the business.</p>\n\n<p>During the writing of this book I've learned from others that this works pretty neatly. Since Trailblazer doesn't have any Rails bindings, engineers started using Lotus and operations together and seem to be very happy. Another framework on my list to try and get excited!</p>\n\n\\n\n\n<p>A few users have noticed when they started playing with Trailblazer that it felt like they were <q>only moving code around</q>. But even that felt better, since the code moved from messy god-classes into small, maintainable containers. Of course, Trailblazer still requires you to program things, it can't magically write your business logic for you.</p>\n\n<p>However, the way it's architected is designed to streamline common web application development, at a level much higher than Rails or other existing infrastructure frameworks. And once those moaning users learned how to take andvantage of compositions, the Reform contract, twins and callbacks, they all reported that their code base is shrinking and the tests grow - a good sign, I'd say!</p>\n\n<p>My advice is: don't expect to learn everything about Trailblazer in a few days. It took almost 10 years to invent, write and evolve all this technology, so relax and let it sink in.</p>\n\n<p>I'm absolutely confident that Trailblazer will help many companies, teams and freelancers to build better, faster, solid and sustainable software with Ruby, and I'm excited about the future and what stories you're going to tell me.</p>\n\n<p>Thanks for blazing trails with me - and <u>See You On The Trail!</u></p>\n\n<p>Nick</p>\n"
r5.writer = w5
r5.save
